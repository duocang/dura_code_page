---
title: 'Human Dura'
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
date: '`r Sys.Date()`'
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## 1. Setup and Environment

Load necessary packages and define global paths.

```{r eval=FALSE, include=TRUE}
#get started with seurat workflow
library(Seurat)
library(ggplot2)
library(readxl)
library(openxlsx)
library(SingleCellExperiment)
library(scDblFinder)
library(qs)
library(clustree) # for cluster tree
library(openxlsx) #writexlsx
library(dplyr) #left_join
library(readr) #read_csv()
library(writexl) #write_xlsx
library(patchwork)
library(clustree)

#scType
library(tibble)
library(dplyr)
library(HGNChelper)

#Propeller/ cell abundance plots
# BiocManager::install("phipsonlab/speckle")
library(speckle)

#Go enrichment analysis ClusterProfiler
library(clusterProfiler)
library(org.Hs.eg.db)
library(openxlsx)
library(enrichplot)
library(ggplot2)
library(dplyr)
library(readxl)

#ggarrange
library(ggpubr)

#NicheNet
library(Seurat)
library(SeuratWrappers)
library(SingleCellExperiment)
library(multinichenetr)
library(ggplot2)
library(dplyr)
library(readr)
library(circlize)
library(scales)


#Trajectory monocle
library(Seurat)
library(SeuratWrappers)
library(monocle3)
library(ggplot2)
library(dplyr)
library(readr)


#milo
library(miloR)
library(miloDE)


samples_seurat <- qread("39.0_samples_seurat_all.qs")

# Point 11.1-11.4.4
Bc_all_seurat <- qread("39.0_samples_seurat_reclustered_Bc_subset")

# Point 15.1-15.9.1
Fibro_main_seurat <- qread("39.0_samples_seurat_reclustered_Fibro_subset")

# point 14.1-14.6.3
myeloid_main_seurat <- qread("39.0_samples_seurat_reclustered_myeloid_subset")

```

## 1.2 Load Raw Data

_Note: The code below outlines the process for loading raw data, but assumes pre-processed objects are used in this report._

```{r eval=FALSE, include=TRUE}

#download h4 files from ENA
#load individual samples with Read10x_h5() function

```

## 1.3 Define Sample Names

Define sample identifiers and create the initial list of objects.

```{r eval=FALSE, include=TRUE}
sample_names <- c("M43_P9", "C97_H_P9", "M98_H_P9 ", #Pool 9
                  "C76_H_P9_10 ", #Pool9+10
                  "M47_P10", "C115_H_P10", "M3509_P10 ", #Pool10
                  "M31_P11", "C54_P11", "C3606_P11", "M3867_P11", #Pool11
                  "C36_P12", "C42_P12", "M2429_P12", "M4074_P12", #Pool12
                  "C40_P13", "C57_H_P13", "M69_P13", "M82_H_P13", #Pool13
                  "C61_P14", "M94_H_P14", "M99_H_P14", "C3590_P14" #Pool14
)

# Create a list of Seurat objects for each sample, with respective sample names
samples <- list(M43_P9, C97_H_P9, M98_H_P9, #Pool 9
                C76_H_P9_10, #Pool9+10
                M47_P10, C115_H_P10, M3509_P10, #Pool10
                M31_P11, C54_P11, C3606_P11, M3867_P11, #Pool11
                C36_P12, C42_P12, M2429_P12, M4074_P12, #Pool12
                C40_P13, C57_H_P13, M69_P13, M82_H_P13, #Pool13
                C61_P14, M94_H_P14, M99_H_P14, C3590_P14 #Pool14
)|> setNames(sample_names)


```

## 1.4 Initialize Seurat Objects

Create Seurat objects for each sample and assign unique cell identifiers.

```{r eval=FALSE, include=TRUE}
samples <- mapply(function(x, nm) {
  obj <- CreateSeuratObject(x, project = nm)
  obj <- RenameCells(obj, add.cell.id = nm)   # make cell names unique per sample
  obj$sample <- nm                            # add sample name to metadata
  return(obj)
}, samples, names(samples), SIMPLIFY = FALSE)
```

## 2. Quality Control (QC)

Calculate and visualize QC metrics to identify low-quality cells.

```{r eval=FALSE, include=TRUE}

```

## 2.1 Calculate QC Metrics

Calculate mitochondrial, ribosomal, and erythrocyte gene percentages.

```{r eval=FALSE, include=TRUE}
for (i in seq_along(samples)) {
  samples[[i]][["percent_mito"]] <- PercentageFeatureSet(samples[[i]], pattern = "^MT-")
  samples[[i]][["percent_ribo"]] <- PercentageFeatureSet(samples[[i]], pattern = "^RP[SLP]")
  samples[[i]][["percent_ery"]] <- PercentageFeatureSet(samples[[i]], pattern = "^HB[AB]")
}
# Create a list to store QC data
qc_data <- list()
# Run QC on all samples (before filtering)
for (i in seq_along(samples)) {
  # Adding sample name as Ident and other metadata features
  Idents(samples[[i]]) <- sample_names[[i]]
  samples[[i]][["sample_id"]] <- names(samples)[i]

  # Add QC data to the qc_data list
  qc_data[[sample_names[i]]] <- data.frame(
    Sample = sample_names[i],
    Cell_Count = ncol(samples[[i]]),
    Percent_Mito = mean(samples[[i]]$percent_mito, na.rm = TRUE),
    Percent_Ribo = mean(samples[[i]]$percent_ribo, na.rm = TRUE),
    Percent_Ery = mean(samples[[i]]$percent_ery, na.rm = TRUE)
  )
}

```

## 2.2 Save Pre-filtering QC Stats

Save the QC statistics to an Excel file.

```{r eval=FALSE, include=TRUE}
qc_summary_before <- do.call(rbind, qc_data)
openxlsx::write.xlsx(qc_summary_before, file = file.path(result_dir, "2.2_cell_count_preQC.xlsx"), rowNames = FALSE)
```

## 2.3 Visualize Pre-filtering QC

Visualize QC metrics (nFeature, nCount, Percent Mito, etc.) using violin plots.

```{r eval=FALSE, include=TRUE}
#create QC plots before filtering seperated
# pdf("2.3_pre_QC_ViolinPlots_seperated.pdf", width=11.69, height=8.27)
for (i in seq_along(samples)){
  print(VlnPlot(samples[[i]], features = c("nFeature_RNA", "nCount_RNA", "percent_mito","percent_ribo", "percent_ery"), ncol = 5))
}
# dev.off()

#create QC plots before filtering seperated combined
combined_samples <- Reduce(function(x, y) merge(x, y), samples)
# pdf(file.path(result_dir, "2.3_pre_QC_ViolinPlots_combined.pdf"), width = 30, height = 25)
VlnPlot(
  combined_samples, features = c("nFeature_RNA", "nCount_RNA", "percent_mito", "percent_ribo", "percent_ery"), group.by = "sample_id", pt.size = 0.1, ncol = 2
)
# dev.off()

```

## 2.4 Doublet Detection

Use `scDblFinder` to identify and mark potential doublet cells.

```{r eval=FALSE, include=TRUE}
#use scDblFinder to exclude doublets
for (i in seq_along(samples)){
  samples_sce <- lapply(samples, as.SingleCellExperiment)
  samples_sce <- lapply(samples_sce, scDblFinder)
  samples[[i]][["scDblFinder.score"]] <- samples_sce[[i]][["scDblFinder.score"]]
  samples[[i]][["scDblFinder.class"]] <- samples_sce[[i]][["scDblFinder.class"]]
}

```

## 3. Data Filtering

Remove low-quality cells based on the calculated QC metrics and doublet status.

```{r eval=FALSE, include=TRUE}

```

## 3.1 Apply QC Filters

Filter cells based on feature counts, mitochondrial/ribosomal/erythrocyte content, and doublet classification.

```{r eval=FALSE, include=TRUE}
samples_filteredQC <- lapply(samples, function(s) {
  keep <- s[["nFeature_RNA"]] > 200 &
    s[["nFeature_RNA"]] < 4000 &
    s[["nCount_RNA"]] < 8000 &
    s[["percent_mito"]] < 5 &
    s[["percent_ery"]] < 1 &
    s[["percent_ribo"]] < 5 &
    s[["scDblFinder.class"]] == "singlet"

  if (sum(keep, na.rm = TRUE) > 0) {
    return(subset(s, cells = colnames(s)[keep]))
  } else {
    return(NULL)
  }
})
which(sapply(samples_filteredQC, is.null))
samples_filteredQC <- Filter(Negate(is.null), samples_filteredQC)

```

## 3.2 Save Post-filtering Statistics

Save the QC statistics for the filtered dataset.

```{r eval=FALSE, include=TRUE}
# Create a list to store QC data
qc_data_after <- list()
for (sample_name in names(samples_filteredQC)) {
  qc_data_after[[sample_name]] <- data.frame(
    Sample       = sample_name,
    Cell_Count   = ncol(samples_filteredQC[[sample_name]]),
    Percent_Mito = mean(samples_filteredQC[[sample_name]]$percent_mito, na.rm = TRUE),
    Percent_Ribo = mean(samples_filteredQC[[sample_name]]$percent_ribo, na.rm = TRUE),
    Percent_Ery  = mean(samples_filteredQC[[sample_name]]$percent_ery, na.rm = TRUE)
  )
}
qc_summary_after <- do.call(rbind, qc_data_after)
write.xlsx(qc_summary_after, file = file.path(result_dir, "3.2_cell_count_postQC.xlsx"), rowNames = FALSE)

```

## 3.3 Visualize Post-filtering QC

Visualize QC metrics for the filtered dataset.

```{r eval=FALSE, include=TRUE}
combined_filtered <- Reduce(function(x, y) merge(x, y), samples_filteredQC)
# pdf(file.path(result_dir, "3.3_post_QC_ViolinPlots.pdf"), width = 30, height = 25)
print(VlnPlot(
  combined_filtered, features = c("nFeature_RNA", "nCount_RNA", "percent_mito", "percent_ribo", "percent_ery"), group.by = "sample_id", pt.size = 0.1, ncol = 2
))
# dev.off()

```

## 4. Normalization and Integration

Perform SCTransform normalization and integrate datasets using RPCA.

```{r eval=FALSE, include=TRUE}
### ran on the HPC cluster
```

## 4.1 SCTransform

Normalize data using SCTransform.

```{r eval=FALSE, include=TRUE}
samples_SCT <- lapply(samples_filteredQC, SCTransform, vst.flavor = "v2", verbose = T) |>
  lapply(RunPCA, npcs = 30, verbose = T)
qsave(samples_SCT, file.path(result_dir, "4.1_samples_SCT.qs"))

```

## 4.2 RPCA Integration

Integrate samples using Reciprocal PCA (RPCA).

```{r eval=FALSE, include=TRUE}
features <- SelectIntegrationFeatures(object.list = samples_SCT, nfeatures = 3000)
samples_SCT <- PrepSCTIntegration(samples_SCT, anchor.features = features)
anchors <- FindIntegrationAnchors(samples_SCT, normalization.method = "SCT",anchor.features = features, reduction = "rpca")
qsave(anchors, file.path(result_dir, "4.2_integration_anchors_rpca.qs"))
samples_combined <- IntegrateData(anchors, normalization.method = "SCT") |>
  RunPCA(verbose = T)
qsave(samples_combined, file.path(result_dir, "4.2_samples_combined_rpca.qs"))

# ===== 5. Clustering & marker genes =====
```

## 5. Clustering and Marker Genes

Cluster cells and identify marker genes for each cluster.

## 5.1 Clustering and UMAP

Perform graph-based clustering and visualize results using UMAP.

```{r eval=FALSE, include=TRUE}
#use Seurat 5.1 (because e.g. Azimuth is not working with Seurat 5.3)
samples_combined <- FindNeighbors(samples_combined, dims = 1:30)
resolution_check <- FindClusters(samples_combined, resolution = c(0.2, 0.4, 0.6, 0.7, 0.8, 1.0, 1.2))
tree <- clustree(resolution_check)
# pdf("5.1_clusterTree_samples_combined.pdf", width=18, height=8.27)
tree
# dev.off()
samples_seurat <- FindClusters(samples_combined, resolution = 0.7) #change resolution
samples_seurat <- RunUMAP(samples_seurat, dims = 1:30)
DimPlot(samples_seurat, label = T)
qsave(samples_seurat, file.path(result_dir, "5.1_samples_seurat_res0.7.qs"))

rm(resolution_check, samples_combined, tree)

```

## 5.2 Find Marker Genes

Identify marker genes for each cluster using the SCT assay.

```{r eval=FALSE, include=TRUE}
#Idents(samples_seurat) <- "annotated" #change later if I have decided for annotation
Idents(samples_seurat) <- "seurat_clusters"
samples_seurat <- PrepSCTFindMarkers(samples_seurat)
markers <- FindAllMarkers(samples_seurat, assay = "SCT", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted <- markers %>%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list <- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = "5.2_Cluster_Markers.xlsx")

rm(marker_list, markers, markers_sorted)

```

## 5.3 Cluster Cell Counts

Calculate and export cell counts and percentages per cluster across different conditions.

```{r eval=FALSE, include=TRUE}
samples_seurat$annotated <- samples_seurat$seurat_clusters #changed later wiith right annotation --> step.6 and 7
Idents(samples_seurat) <- "annotated"

overall_counts <- table(samples_seurat$annotated)
sample_counts <- table(samples_seurat$annotated, samples_seurat$sample_id)
condition_counts <- table(samples_seurat$annotated, samples_seurat$condition)
cohort_counts <- table(samples_seurat$annotated, samples_seurat$cohort)
biobank_counts <- table(samples_seurat$annotated, samples_seurat$biobank)
diagnosis_counts <- table(samples_seurat$annotated, samples_seurat$diagnosis)

overall_df <- as.data.frame(overall_counts)
colnames(overall_df) <- c("Cluster", "Cell_Count")
sample_df <- as.data.frame.matrix(sample_counts)
sample_df <- cbind(Cluster = rownames(sample_df), sample_df)
condition_df <- as.data.frame.matrix(condition_counts)
condition_df <- cbind(Cluster = rownames(condition_df), condition_df)
cohort_df <- as.data.frame.matrix(cohort_counts)
cohort_df <- cbind(Cluster = rownames(cohort_df), cohort_df)
biobank_df <- as.data.frame.matrix(biobank_counts)
biobank_df <- cbind(Cluster = rownames(biobank_df), biobank_df)
diagnosis_df <- as.data.frame.matrix(diagnosis_counts)
diagnosis_df <- cbind(Cluster = rownames(diagnosis_df), diagnosis_df)

#percentage
calc_column_percent <- function(count_table) {
  percent_matrix <- prop.table(count_table, margin = 2) * 100
  percent_df <- as.data.frame.matrix(round(percent_matrix, 2))
  percent_df <- cbind(Cluster = rownames(percent_df), percent_df)
  return(percent_df)
}

sample_percent_df <- calc_column_percent(sample_counts)
condition_percent_df <- calc_column_percent(condition_counts)
cohort_percent_df <- calc_column_percent(cohort_counts)
biobank_percent_df <- calc_column_percent(biobank_counts)
diagnosis_percent_df <- calc_column_percent(diagnosis_counts)

#save in one excel
write_xlsx(
  list(
    Overall = overall_df,
    By_Sample = sample_df,
    By_Sample_Percent = sample_percent_df,
    By_Condition = condition_df,
    By_Condition_Percent = condition_percent_df,
    By_Cohort = cohort_df,
    By_Cohort_Percent = cohort_percent_df,
    By_Biobank = biobank_df,
    By_Biobank_Percent = biobank_percent_df,
    By_Diagnosis = diagnosis_df,
    By_Diagnosis_Percent = diagnosis_percent_df
  ),
  path = "5.3__Cluster_Cell_Counts.xlsx"
)

#clean enviornment
rm(cohort_df, cohort_percent_df, condition_df, condition_percent_df, overall_df, sample_df, sample_percent_df, cohort_counts, overall_counts, sample_counts, calc_column_percent, biobank_df, biobank_percent_df, biobank_counts, diagnosis_df, diagnosis_percent_df)

```

## 6. Metadata Processing

Clean and update sample metadata.

```{r eval=FALSE, include=TRUE}
#three samples had spaces in their samples_ID --> need to be removed
samples_seurat@meta.data$sample_id[samples_seurat@meta.data$sample_id == "M98_H_P9 "] <- "M98_H_P9"
samples_seurat@meta.data$sample_id[samples_seurat@meta.data$sample_id == "C76_H_P9_10 "] <- "C76_H_P9_10"
samples_seurat@meta.data$sample_id[samples_seurat@meta.data$sample_id == "M3509_P10 "] <- "M3509_P10"

```

## 6.1 Add Patient Information

Integrate patient-level information (age, sex, condition) into the single-cell object.

```{r eval=FALSE, include=TRUE}
patient_info <- openxlsx::read.xlsx("patient_info.xlsx") #you can use Supplement Figure 1
#add meta.data
meta <- samples_seurat@meta.data
# Add cell name as a new column for subsequent reassignment
meta$cell_id <- rownames(meta)
# Merge `information from `meta` and `patient_info`
meta_new <- left_join(meta, patient_info[, c("sample_id", "pool", "condition", "dura_regio", "patient_id", "biobank", "sex", "age", "pmd_h", "diagnosis", "cohort")], by = c("sample_id" = "sample_id"))
rownames(meta_new) <- meta$cell_id
#add to seurat_object
samples_seurat@meta.data <- meta_new

samples_seurat@meta.data$condition <- as.factor(samples_seurat@meta.data$condition)
samples_seurat@meta.data$pool <- as.factor(samples_seurat@meta.data$pool)
samples_seurat@meta.data$dura_regio <- as.factor(samples_seurat@meta.data$dura_regio)
samples_seurat@meta.data$patient_id <- as.factor(samples_seurat@meta.data$patient_id)
samples_seurat@meta.data$biobank <- as.factor(samples_seurat@meta.data$biobank)
samples_seurat@meta.data$sex <- as.factor(samples_seurat@meta.data$sex)
samples_seurat@meta.data$age <- as.factor(samples_seurat@meta.data$age)
samples_seurat@meta.data$diagnosis <- as.factor(samples_seurat@meta.data$diagnosis)
samples_seurat@meta.data$cohort <- as.factor(samples_seurat@meta.data$cohort)

rm(meta, meta_new, patient_info)

```

## 6.2 Add Cell Annotations

Assign biological annotations to clusters based on marker genes.

```{r eval=FALSE, include=TRUE}
samples_seurat$annotated <- recode(samples_seurat$seurat_clusters, "0" = "duraFibro4", "1" = "duraFibro1", "2" = "CAM", "3" = "duraFibro3", "4" = "vSMC1", "5" = "capEndo", "6" = "vascFibro", "7" = "venEndo", "8" = "Tc", "9" = "artEndo", "10" = "duraFibro7", "11" = "vSMC2", "12" = "duraFibro2", "13" = "Myeloid1", "14" = "Myeloid5", "15" = "arach_bordFibro", "16" = "Peri", "17" = "Myeloid3", "18" = "Myeloid2", "19" = "duraFibro8", "20" = "duraFibro5", "21" = "ABC", "22" = "mixVascStroma", "23" = "mixEndo", "24" = "Bc", "25" = "Myeloid4", "26" = "Mast", "27" = "duraFibro6", "28" = "IFN-CAM")

samples_seurat$main_groups <- recode(samples_seurat$seurat_clusters, "0" = "duraFibro", "1" = "duraFibro", "2" = "Myeloid", "3" = "duraFibro", "4" = "vascStroma", "5" = "Endo", "6" = "vascStroma", "7" = "Endo", "8" = "Tc", "9" = "Endo", "10" = "duraFibro", "11" = "vascStroma", "12" = "duraFibro", "13" = "Myeloid", "14" = "Myeloid", "15" = "arach_bordFibro", "16" = "vascStroma", "17" = "Myeloid", "18" = "Myeloid", "19" = "duraFibro", "20" = "duraFibro", "21" = "ABC", "22" = "vascStroma", "23" = "Endo", "24" = "Bc", "25" = "Myeloid", "26" = "Myeloid", "27" = "duraFibro", "28" = "Myeloid")
cluster_order <- c("ABC", "arach_bordFibro", "duraFibro", "vascStroma", "Endo", "Myeloid", "Tc", "Bc")
samples_seurat@meta.data$main_groups <- factor(samples_seurat@meta.data$main_groups, levels = cluster_order)
Idents(samples_seurat) <- samples_seurat@meta.data$main_groups
Idents(samples_seurat) <- "main_groups"
DefaultAssay(samples_seurat) <- "SCT"

```

## 6.3 Define Cluster Colors

Define custom color palettes for visualization.

```{r eval=FALSE, include=TRUE}
#extract colors
p <- DimPlot(samples_seurat, group.by = "annotated")
cluster_colors <- ggplot_build(p)$data[[1]]$colour
cluster_ids <- p$data$annotated
cluster_colors_df <- data.frame(cluster = cluster_ids, color = cluster_colors)
unique_colors <- unique(cluster_colors_df)
unique_colors

#define new colors
cluster_colors <- c(
  "ABC" = "#9584bd",
  "arach_bordFibro" = "#87be4d",
  "duraFibro1" = "#38b083",
  "duraFibro2" = "#5c96d0",
  "duraFibro3" = "#ee756e",
  "duraFibro4" = "#d49005",
  "duraFibro5" = "#828cc5",
  "duraFibro6" = "#ec67a2",
  "duraFibro7" = "#3bab4b",
  "duraFibro8" = "#d88356",
  "vascFibro" = "#9ea71e",
  "mixVascStroma" = "#a27eb7",
  "Peri" = "#06b8e0",
  "vSMC1" = "#bb4d63",
  "vSMC2" = "#8e7eb9",
  "mixEndo" = "#b078b1",
  "artEndo" = "#3caa34",
  "capEndo" = "#29aab5",
  "venEndo" = "#957e25",
  "Mast" = "#e26aa5",
  "inflamMono1" = "#36b39c",
  "inflamMono2" = "#75ae2b",
  "inflamMono3" = "#12b3e8",
  "Granulo" = "#cf6ea8",
  "mixMyeloid" = "#32b6b3",
  "IFN-CAM" = "#ec67a2",
  "CAM" = "#e38803",
  "Bc" = "#bf72ad",
  "Tc" = "#dd4e10")


#cluster_color main groups
cluster_colors <- c( "ABC" = "#9584bd",
                     "arach_bordFibro" = "#87be4d",
                     "duraFibro" = "#f2cf22",
                     "vascStroma" = "#00b8df",
                     "Endo" = "#27a9b5",
                     "Myeloid" = "#e04c73",
                     "Bc" = "#bf72ad",
                     "Tc" = "#dd4e10")


```

## 6.4 Define Cluster Order

Set the order of clusters for plotting consistency.

```{r eval=FALSE, include=TRUE}
ccluster_order <- c("artEndo", "capEndo", "venEndo", "mixEndo", "vSMC1", "vSMC2", "Peri", "mixVascStroma", "vascFibro", "Tc", "Bc", "CAM", "IFN-CAM", "inflamMono1", "inflamMono2", "inflamMono3", "Granulo", "mixMyeloid", "Mast","ABC", "arach_bordFibro", "duraFibro1", "duraFibro2", "duraFibro3", "duraFibro4", "duraFibro5", "duraFibro6", "duraFibro7", "duraFibro8")
cluster_order <- rev(cluster_order)
samples_seurat@meta.data$annotated <- factor(samples_seurat@meta.data$annotated, levels = cluster_order)
Idents(samples_seurat) <- samples_seurat@meta.data$annotated

qsave(samples_seurat, file.path(result_dir, "6.4_samples_combined_meta_data.qs"))

```

## 6.5 Patient Demographics (Age, Sex, PMD)

Analyze and visualize the distribution of age, sex, and post-mortem delay (PMD) across conditions.

```{r eval=FALSE, include=TRUE}
# Create sample metadata
sample_meta <- samples_seurat@meta.data %>%
  dplyr::select(sample_id, condition, age, sex, pmd_h) %>%
  distinct()

### age ###
# Convert age to numeric (in case it was imported as factor/character)
sample_meta$age <- as.numeric(as.character(sample_meta$age))
# Optional: ensure condition is a factor with correct order
sample_meta$condition <- factor(sample_meta$condition, levels = c("Ctrl", "MS"))
# Step 2: Perform t-test
t_test_result <- t.test(age ~ condition, data = sample_meta)
# Step 3: Plot
# pdf("6.5_age_distribution.pdf", width = 5, height = 5)
ggplot(sample_meta, aes(x = condition, y = age, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(aes(color = condition), width = 0.15, size = 2, alpha = 0.9) +
  theme_minimal() +
  labs(
    x = NULL,
    y = "age [years]"
  ) +
  scale_fill_manual(values = c("Ctrl" = "black", "MS" = "#3d70b5")) +
  scale_color_manual(values = c("Ctrl" = "black", "MS" = "black")) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.position = "none"
  ) +
  annotate(
    "text",
    x = 1.5,
    y = max(sample_meta$age),
    label = paste("T-test p-value:", format(t_test_result$p.value, digits = 2)), #scientific = TRUE)
    size = 5,
    color = "black",
    hjust = 0.5
  )
# dev.off()

### sex ###
sex_counts <- sample_meta %>%
  group_by(condition, sex) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(condition) %>%
  mutate(proportion = count / sum(count))

# pdf("6.5_sex_distribution.pdf", width = 4, height = 5)
ggplot(sex_counts, aes(x = condition, y = proportion, fill = sex)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.position = "none"
  ) +
  labs(
    title = "Sex Distribution by Condition",
    x = "Condition",
    y = "Proportion",
    fill = "Sex"
  )
# dev.off()

### pmd_h ###
# Convert age to numeric (in case it was imported as factor/character)
sample_meta$pmd_h <- as.numeric(as.character(sample_meta$pmd_h))
# Optional: ensure condition is a factor with correct order
sample_meta$condition <- factor(sample_meta$condition, levels = c("Ctrl", "MS"))
# Step 2: Perform t-test
t_test_result <- t.test(pmd_h ~ condition, data = sample_meta)
# Step 3: Plot
# pdf("6.5_pmd_distribution.pdf", width = 5, height = 5)
ggplot(sample_meta, aes(x = condition, y = pmd_h, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(aes(color = condition), width = 0.15, size = 2, alpha = 0.9) +
  theme_minimal() +
  labs(
    x = NULL,
    y = "post mortem delay [hours]"
  ) +
  scale_fill_manual(values = c("Ctrl" = "black", "MS" = "#3d70b5")) +
  scale_color_manual(values = c("Ctrl" = "black", "MS" = "black")) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.position = "none"
  ) +
  annotate(
    "text",
    x = 1.5,
    y = max(sample_meta$pmd_h),
    label = paste("T-test p-value:", format(t_test_result$p.value, digits = 2)),
    size = 5,
    color = "black",
    hjust = 0.5
  )
# dev.off()

```

## 6.6 Summary Statistics

Calculate total cells, cells per condition, and average genes per cell.

```{r eval=FALSE, include=TRUE}
#total cells
ncol(samples_seurat)
#245730

#total cells by condition
table(samples_seurat$condition)
#Ctrl     MS
#125818 119912

#average genes per cell
mean(samples_seurat$nFeature_RNA)
# 796.5089 --> 797

#cells per sample
round(mean(table(samples_seurat$sample_id)))
#10,684

```

## 7. Cluster Abundance Analysis (Confounder Adjusted)

Analyze changes in cluster abundance while adjusting for confounding variables.

```{r eval=FALSE, include=TRUE}

```

## 7.1 Data Preparation

Prepare metadata and count matrices for abundance analysis, accounting for age, sex, cohort, and pool.

```{r eval=FALSE, include=TRUE}
# Extract metadata and ensure all required variables are present
meta_confounders <- samples_seurat@meta.data %>%
  dplyr::select(sample_id, condition, cohort, pool, annotated, age, sex) %>%
  # Remove rows with missing confounder data
  filter(!is.na(age) & !is.na(sex)) %>%
  # Ensure sex is a factor
  mutate(sex = as.factor(sex),
         condition     = as.factor(condition),
         cohort = as.factor(cohort),
         pool = as.factor(pool),
         age = as.numeric(age))

# Create count matrix: samples x cell types
library(tidyr)
count_matrix <- meta_confounders %>%
  group_by(sample_id, annotated) %>%
  summarise(count = n(), .groups = "drop") %>%
  pivot_wider(names_from = annotated, values_from = count, values_fill = 0) %>%
  column_to_rownames("sample_id") %>%
  as.matrix()

# Create sample metadata
sample_meta <- meta_confounders %>%
  dplyr::select(sample_id, condition, cohort, pool, age, sex) %>%
  distinct()
rownames(sample_meta) <- sample_meta$sample_id

# Ensure same sample order
sample_meta <- sample_meta[rownames(count_matrix), ]

```

## 7.2 Confounder-Adjusted Differential Abundance

Run `propeller` analysis to identify differentially abundant cell types between MS and Ctrl, adjusting for confounders.

```{r eval=FALSE, include=TRUE}
run_propeller_with_confounders <- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list <- list()

#   pdf(output_file, width = 8, height = 6)

  for (pair in comparisons) {
    group1 <- pair[1]
    group2 <- pair[2]

    cat(paste("  Analyzing:", group1, "vs", group2, "with confounders\n"))

    # Filter to comparison groups
    keep_samples              <- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              <- count_data[keep_samples, , drop = FALSE]
    meta_subset               <- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  <- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str <- paste("~", group_var, "+", paste(confounders, collapse = " + "))
    design_formula <- as.formula(formula_str)
    # design_matrix <- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props <- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit <- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results <- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str <- paste(confounders, collapse = " + ")

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model <- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula <- as.formula(paste("celltype ~", group_var, "+", confounder_str))

        # Fit linear model
        fit <- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name <- paste0(group_var, group1)
        coef_names <- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val <- coef(fit)[coef_name]
          p_val    <- summary(fit)$coefficients[coef_name, "Pr(>|t|)"]

          results[results$CellType == celltype, "logFC"] <- coef_val
          results[results$CellType == celltype, "P.Value"] <- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, "logFC"] <- NA
          results[results$CellType == celltype, "P.Value"] <- NA
        }
      }

      results$P.Value.Adj <- p.adjust(results$P.Value, method = "BH")
      results$comparison  <- paste(group1, "vs", group2, sep = "_")

      # Store results in list
      results_list[[paste(group1, "vs", group2)]] <- results

      # Prepare volcano plot dataframe
      volcano_df <- results %>%
        mutate(
          log2_ratio = logFC,
          p.adj = P.Value.Adj,
          neg_log10_p = -log10(p.adj),
          var = CellType
        ) %>%
        dplyr::select(var, log2_ratio, p.adj, neg_log10_p)

      # Volcano plot function
      VolPlot <- function(data) {
        data |>
          ggplot(aes(x = log2_ratio, y = neg_log10_p, color = var, label = var)) +
          geom_point(size = 3) +
          geom_hline(yintercept = -log10(0.05), color = "grey", linetype = "dashed") +
          geom_vline(xintercept = 0, color = "grey", linetype = "dashed") +
          ggtitle(paste("Confounder-adjusted: age + sex + cohort + pool", group1, "vs", group2)) +
          scale_color_manual(values = cluster_colors) +
          ggrepel::geom_text_repel() +
          theme_classic() +
          theme(legend.position = "none") +
          xlab(bquote(~ Log[2] ~ "fold change")) +
          ylab(bquote(~ -Log[10] ~ "adjusted p value"))
      }

      # Print volcano plot
      p <- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste("Error in analysis for", group1, "vs", group2, ":", e$message, "\n"))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons <- list(
  c("MS", "Ctrl")
)

results_confounders_pms <- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %>% dplyr::select(-sample_id),
  group_var   = "condition",
  confounders = c("age", "sex", "cohort", "pool"),
  comparisons = comparisons,
  output_file = file.path("7.2_confounder_adjusted_propeller.pdf")
)

```

## 7.3 Confounder-Adjusted Log2FC Analysis

Perform additional analysis on log2 fold changes, adjusted for confounders.

```{r eval=FALSE, include=TRUE}
run_propeller_with_confounders <- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list <- list()

#   pdf(output_file, width = 5, height = 5)

  for (pair in comparisons) {
    group1 <- pair[1]
    group2 <- pair[2]

    cat(paste("  Analyzing:", group1, "vs", group2, "with confounders\n"))

    # Filter to comparison groups
    keep_samples              <- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              <- count_data[keep_samples, , drop = FALSE]
    meta_subset               <- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  <- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str <- paste("~", group_var, "+", paste(confounders, collapse = " + "))
    design_formula <- as.formula(formula_str)
    # design_matrix <- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props <- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit <- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results <- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str <- paste(confounders, collapse = " + ")

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model <- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula <- as.formula(paste("celltype ~", group_var, "+", confounder_str))

        # Fit linear model
        fit <- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name <- paste0(group_var, group1)
        coef_names <- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val <- coef(fit)[coef_name]
          p_val    <- summary(fit)$coefficients[coef_name, "Pr(>|t|)"]

          results[results$CellType == celltype, "logFC"] <- coef_val
          results[results$CellType == celltype, "P.Value"] <- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, "logFC"] <- NA
          results[results$CellType == celltype, "P.Value"] <- NA
        }
      }

      results$P.Value.Adj <- p.adjust(results$P.Value, method = "BH")
      results$comparison  <- paste(group1, "vs", group2, sep = "_")

      # Store results in list
      results_list[[paste(group1, "vs", group2)]] <- results

      # Prepare volcano plot dataframe
      volcano_df <- results %>%
        mutate(
          log2_ratio = logFC,
          cluster = CellType
        ) %>%
        arrange(log2_ratio) %>%
        mutate(cluster = factor(cluster, levels = cluster))

      # Volcano plot function
      VolPlot <- function(data) {
        ggplot(data, aes(x = log2_ratio, y = cluster, color = cluster)) +
          geom_point(size = 3) +
          geom_vline(xintercept = 0, color = "grey", linetype = "dashed") +
          ggtitle(paste(group1, "vs", group2, "(confounder adjusted)")) +
          theme_classic() +
          theme(legend.position = "none") +
          xlab(bquote(~ Log[2] ~ "fold change")) +
          ylab("Cluster") +
          scale_color_manual(values = cluster_colors)
      }

      # Print volcano plot
      p <- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste("Error in analysis for", group1, "vs", group2, ":", e$message, "\n"))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons <- list(
  c("MS", "Ctrl")
)

results_confounders_pms <- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %>% dplyr::select(-sample_id),
  group_var   = "condition",
  confounders = c("sex", "age", "cohort", "pool"),
  comparisons = comparisons,
  output_file = file.path("7.3_confounder_adjusted_propeller_LogFC_all.pdf")
)

```

## 8. Cell Interaction Analysis (NicheNet)

Predict ligand-receptor interactions between cell types using NicheNet.

```{r eval=FALSE, include=TRUE}

```

## 8.1 NicheNet Analysis

Perform NicheNet analysis to identify potential intercellular communication.

```{r eval=FALSE, include=TRUE}
#convert Seurat to single cell experiment and define meta data
sce <- Seurat::as.SingleCellExperiment(samples_seurat, assay = "SCT")
sce <- alias_to_symbol_SCE(sce, "human") |> makenames_SCE()

sample_id <- "sample_id"
group_id <- "condition"
celltype_id <- "annotated"
covariates <- NA
batches <- NA

#define organism
organism = "human"

if(organism == "human"){
  lr_network = readRDS(url("https://zenodo.org/record/7074291/files/lr_network_human_21122021.rds"))
  lr_network = lr_network |> dplyr::rename(ligand = from, receptor = to) |> distinct(ligand, receptor) |> mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds"))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |> make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |> make.names()
} else if(organism == "mouse"){
  lr_network = readRDS(url("https://zenodo.org/record/7074291/files/lr_network_mouse_21122021.rds"))
  lr_network = lr_network |> dplyr::rename(ligand = from, receptor = to) |> distinct(ligand, receptor) |> mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds"))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |> make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |> make.names()
}

#change names because _ and dots are not allowed
colData(sce)[, celltype_id] <- factor(gsub("-", "_", colData(sce)[, celltype_id]))
levels(colData(sce)[, celltype_id])

#Sender and receiver cell types need to be defined. Here all cell types in the dataset are used
senders_oi <- SummarizedExperiment::colData(sce)[,celltype_id] |> unique()
receivers_oi <- SummarizedExperiment::colData(sce)[,celltype_id] |> unique()

sce <- sce[, SummarizedExperiment::colData(sce)[,celltype_id] %in% c(senders_oi, receivers_oi)]

min_cells <- 10

abundance_info = get_abundance_info(
  sce = sce,
  sample_id = sample_id,
  group_id = group_id,
  celltype_id = celltype_id,
  min_cells = min_cells,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  batches = batches)

## check for condition-specific cell types
abundance_df_summarized = abundance_info$abundance_data %>% mutate(keep = as.logical(keep)) %>% group_by(group_id, celltype_id) %>% summarise(samples_present = sum((keep)))
celltypes_absent_one_condition = abundance_df_summarized %>% filter(samples_present == 0) %>% pull(celltype_id) %>% unique() # find truly condition-specific cell types by searching for cell types truely absent in at least one condition
celltypes_present_one_condition = abundance_df_summarized %>% filter(samples_present >= 2) %>% pull(celltype_id) %>% unique() # require presence in at least 2 samples of one group so it is really present in at least one condition
condition_specific_celltypes = intersect(celltypes_absent_one_condition, celltypes_present_one_condition)

condition_specific_celltypes_senders = condition_specific_celltypes %>% intersect(senders_oi)
condition_specific_celltypes_receivers = condition_specific_celltypes %>% intersect(receivers_oi)

fraction_cutoff <- 0.05
min_sample_prop <- 0.5
frq_list = get_frac_exprs(sce = sce, sample_id = sample_id, celltype_id =  celltype_id, group_id = group_id, batches = batches, min_cells = min_cells, fraction_cutoff = fraction_cutoff, min_sample_prop = min_sample_prop)

abundance_expression_info <- process_abundance_expression_info(
  sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, min_cells = min_cells,
  senders_oi = union(senders_oi, condition_specific_celltypes_senders),
  receivers_oi = union(receivers_oi, condition_specific_celltypes_receivers),
  lr_network = lr_network, batches = batches, frq_list = frq_list, abundance_info = abundance_info)

#If you compare against two groups, you should divide by 2, if you compare against three groups, you should divide by 3 etcetera
contrasts_oi <- c("'M-(S+A)/2','S-(M+A)/2','A-(S+M)/2'")
#if compare against two groups
contrasts_oi <- c("'MS-Ctrl','Ctrl-MS'")
contrast_tbl <- tibble(contrast = c("MS-Ctrl","Ctrl-MS"), group = c("MS","Ctrl"))

assay_oi_pb <- "counts"
fun_oi_pb <- "sum"
de_method_oi <- "edgeR"
findMarkers <- FALSE

DE_info = get_DE_info(sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, batches = batches, covariates = covariates, contrasts_oi = contrasts_oi, min_cells = min_cells,
                      assay_oi_pb = assay_oi_pb,
                      fun_oi_pb = fun_oi_pb,
                      de_method_oi = de_method_oi,
                      findMarkers = findMarkers,
                      expressed_df = frq_list$expressed_df)

#check p-value distribution#should be quite straight horizontal line
DE_info$hist_pvals

#if it looks ok, run "empirical_pval == FALSE
empirical_pval = FALSE
#if it looks suboptimal run empirical_pval == TRUE and check quality
empirical_pval = TRUE

if(empirical_pval == TRUE){
  DE_info_emp = get_empirical_pvals(DE_info$celltype_de$de_output_tidy)
}
DE_info_emp$hist_pvals_emp

if(empirical_pval == FALSE){
  celltype_de = DE_info$celltype_de$de_output_tidy
} else {
  celltype_de = DE_info_emp$de_output_tidy_emp %>% dplyr::select(-p_val, -p_adj) %>% dplyr::rename(p_val = p_emp, p_adj = p_adj_emp)
}

sender_receiver_de = combine_sender_receiver_de(
  sender_de = celltype_de,
  receiver_de = celltype_de,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  lr_network = lr_network
)

logFC_threshold = 0.50
p_val_threshold = 0.05
fraction_cutoff = 0.05


# p_val_adj = TRUE #In case of more samples per group + sufficient high number of DE genes per group-celltype (> 20-50), use p_val_adj = TRUE
p_val_adj = T

top_n_target = 400

verbose = TRUE
cores_system = 8
n.cores = min(cores_system, sender_receiver_de$receiver %>% unique() %>% length()) # use one core per receiver cell type

ligand_activities_targets_DEgenes = suppressMessages(suppressWarnings(get_ligand_activities_targets_DEgenes(
  receiver_de = celltype_de,
  receivers_oi = receivers_oi,
  ligand_target_matrix = ligand_target_matrix,
  logFC_threshold = logFC_threshold,
  p_val_threshold = p_val_threshold,
  p_val_adj = T,
  top_n_target = top_n_target,
  verbose = T,
  n.cores = n.cores
)))

prioritizing_weights_DE = c("de_ligand" = 1,
                            "de_receptor" = 1)
prioritizing_weights_activity = c("activity_scaled" = 2)

prioritizing_weights_expression_specificity = c("exprs_ligand" = 2,
                                                "exprs_receptor" = 2)

prioritizing_weights_expression_sufficiency = c("frac_exprs_ligand_receptor" = 1)

prioritizing_weights_relative_abundance = c( "abund_sender" = 0,
                                             "abund_receiver" = 0)

prioritizing_weights = c(prioritizing_weights_DE,
                         prioritizing_weights_activity,
                         prioritizing_weights_expression_specificity,
                         prioritizing_weights_expression_sufficiency,
                         prioritizing_weights_relative_abundance)

sender_receiver_tbl = sender_receiver_de |> dplyr::distinct(sender, receiver)

metadata_combined = SummarizedExperiment::colData(sce) |> tibble::as_tibble()

if(!is.na(batches)){
  grouping_tbl = metadata_combined[,c(sample_id, group_id, batches)] |> tibble::as_tibble() |> dplyr::distinct()
  colnames(grouping_tbl) = c("sample","group",batches)
} else {
  grouping_tbl = metadata_combined[,c(sample_id, group_id)] |> tibble::as_tibble() |> dplyr::distinct()
  colnames(grouping_tbl) = c("sample","group")
}

scenario <- "regular" # all prioritization criteria will be weighted equally
ligand_activity_down <- FALSE # use only upregulatory ligand activities to prioritize

prioritization_tables = suppressMessages(generate_prioritization_tables(
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de = sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  contrast_tbl = contrast_tbl,
  sender_receiver_tbl = sender_receiver_tbl,
  grouping_tbl = grouping_tbl,
  scenario = scenario,
  fraction_cutoff = fraction_cutoff,
  abundance_data_receiver = abundance_expression_info$abundance_data_receiver,
  abundance_data_sender = abundance_expression_info$abundance_data_sender,
  ligand_activity_down = ligand_activity_down
))

lr_target_prior_cor = lr_target_prior_cor_inference(prioritization_tables$group_prioritization_tbl$receiver |> unique(), abundance_expression_info, celltype_de, grouping_tbl, prioritization_tables, ligand_target_matrix, logFC_threshold = logFC_threshold, p_val_threshold = p_val_threshold, p_val_adj = p_val_adj)

#save previous calculations as one large list
multinichenet_output = list(
  celltype_info = abundance_expression_info$celltype_info,
  celltype_de = celltype_de,
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de =  sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  prioritization_tables = prioritization_tables,
  grouping_tbl = grouping_tbl,
  lr_target_prior_cor = lr_target_prior_cor
)
multinichenet_output = make_lite_output(multinichenet_output)

saveRDS(multinichenet_output, file = "8.1_multinichenet.rds")

```

## 8.2 Circos Plot Visualization

Visualize ligand-receptor interactions using Circos plots.

```{r eval=FALSE, include=TRUE}
#create plot for the top100 predictions
prioritized_tbl_oi_all = get_top_n_lr_pairs(multinichenet_output$prioritization_tables, 100, rank_per_group = FALSE)

prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>%
  filter(id %in% prioritized_tbl_oi_all$id) %>%
  distinct(id, sender, receiver, ligand, receptor, group) %>% left_join(prioritized_tbl_oi_all)
prioritized_tbl_oi$prioritization_score[is.na(prioritized_tbl_oi$prioritization_score)] = 0

senders_receivers = union(prioritized_tbl_oi$sender %>% unique(), prioritized_tbl_oi$receiver %>% unique()) %>% sort()

colors_sender <- cluster_colors[senders_receivers]
colors_receiver <- cluster_colors[senders_receivers]

library(scales)

# pdf("8.2_top100_circos_plot_newcolor.pdf", width = 10, height = 10)
circos_list = make_circos_group_comparison(prioritized_tbl_oi, colors_sender, colors_receiver)
# dev.off()

#split bei receiver
# Open multi-page PDF
# pdf("8.2_circos_split_by_receiver.pdf", width = 10, height = 10)

unique_receivers <- sort(unique(prioritized_tbl_oi$receiver))

for(receiver in unique_receivers) {

  # Subset top interactions for this receiver
  subset_tbl <- prioritized_tbl_oi %>% filter(receiver == !!receiver)
  if(nrow(subset_tbl) == 0) next

  # Create circos object
  circos_list <- make_circos_group_comparison(subset_tbl, colors_sender, colors_receiver)

  circos.clear()
  circos.par(gap.degree = 5)

  # Initialize sectors
  cell_types <- circos_list$cell_types
  xlim_list <- lapply(cell_types, function(x) c(0,1))
  names(xlim_list) <- cell_types
  for(sector in cell_types){
    circos.initialize(factors = sector, xlim = xlim_list[[sector]])
  }

  # Draw arcs and labels
  cell_colors <- circos_list$colors
  for(sector in cell_types){
    circos.trackPlotRegion(factors = sector, y = c(0,1),
                           bg.col = cell_colors[sector], bg.border = NA,
                           panel.fun = function(x, y){
                             circos.text(CELL_META$xcenter, CELL_META$ycenter,
                                         CELL_META$sector.index,
                                         facing = "clockwise", niceFacing = TRUE, cex = 0.8)
                           })
  }

  # Draw links
  if(!is.null(circos_list$links) && nrow(circos_list$links) > 0){
    for(i in seq_len(nrow(circos_list$links))){
      link <- circos_list$links[i, ]
      circos.link(sector.index1 = link$sender, point1 = 0.5,
                  sector.index2 = link$receiver, point2 = 0.5,
                  col = rgb(0,0,0,0.3), border = NA)
    }
  }

  # Each iteration creates a **new page** in the PDF
}

# Close PDF device
# dev.off()

rm(abundance_df_summarized, abundance_expression_info, abundance_info, celltype_de, circos_list, contrast_tbl, de_genes_summary, DE_info, DE_info_emp, frq_list, grouping_tbl, ligand_activities_df, ligand_activities_targets_DEgenes, ligand_activity_summary, ligand_activity_down, ligand_target_matrix, ligand_target_matrix_test, lr_network, lr_target_prior_cor, metadata_combined, multinichenet_output, prioritization_tables, prioritized_tbl_oi, prioritized_tbl_oi_all, sce, sender_receiver_de, sender_receiver_tbl, subset_tbl, summary_ctrl, xlim_list, xlim_matrix, assay_oi_pb, batches, cell_colors, cell_types, celltype_id, celltypes_absent_one_condition, celltypes_present_one_condition, circos_text_y, colors_receiver, colors_sender, condition_specific_celltypes, condition_specific_celltypes_receivers, condition_specific_celltypes_senders, contrasts_oi, cores_system, covariates, de_method_oi, empirical_pval, findMarkers, fraction_cutoff, fun_oi_pb, group_id, ligand_activities_df, logFC_threshold, min_cells, min_sample_prop, n, n.cores, organism, p_val_adj, p_val_threshold, prioritizing_weights, prioritizing_weights_activity, prioritizing_weights_DE, prioritizing_weights_expression_specificity, prioritizing_weights_expression_specificity, prioritizing_weights_expression_sufficiency, receiver, receivers_oi, sample_id, scenario, sector, senario, senders_oi, senders_receivers, senders_receivers_missing, top_n_target, unique_receivers, verbose, circos_plot, prioritizing_weights_relative_abundance)

```

## 9. Reference Dataset Comparison

Compare the current dataset with published reference datasets.

```{r eval=FALSE, include=TRUE}
#prepare human dura data
#save UMAP reduction (same UMAP as for previous analysis)
umap_reduction <- Embeddings(samples_seurat, "umap")
samples_seurat <- RunUMAP(
  samples_seurat,
  reduction = "pca",
  dims = 1:30,
  return.model = TRUE,  # store model for MapQuery
  umap.method = "umap-learn"
)
samples_seurat[["umap"]]@cell.embeddings <- umap_reduction

#load reference datasets
#bran <- Garcia
#liver <- Tallulah/Andrews
#stromal <- Hickey
#lung <- Qian
# skin <- Deng

#rename
fibros <- brain # Garcia
fibros <- liver #Tallulah/Andrews
fibros <- stromal #Hickey
fibros <- lung #Qian
fibros <- skin #deng

#refPlots
Idents(samples_seurat) <- "main_groups"
anchors <- FindTransferAnchors(reference = samples_seurat, query = fibros, dims = 1:30, reference.reduction = "pca",normalization.method = "SCT", reference.assay = "integrated")
predictions <- TransferData(anchorset = anchors, refdata = samples_seurat$main_groups,dims = 1:30)
fibros <- AddMetaData(fibros, metadata = predictions)

Idents(fibros) <- "predicted.id"
Cell_num <- data.frame(predicted.id = fibros@meta.data$predicted.id)
Cell_num <- Cell_num |>
  group_by(predicted.id) |>
  summarise(Nb = n(), .groups = "drop") |>
  mutate(
    C = sum(Nb),
    percent = Nb / C * 100
  )

#plots references
p2 <- ggplot(Cell_num, aes(x = "Garcia - brain", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)

p3 <- ggplot(Cell_num, aes(x = "Andrews - liver", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)

p4 <- ggplot(Cell_num, aes(x = "Hickey - colon", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)

p5 <- ggplot(Cell_num, aes(x = "Qian - lung", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)

p6 <- ggplot(Cell_num, aes(x = "Deng - skin", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)


#Smyth --> mouse dataset --> convert to human genes
Lepto.Fibro <- Lepto.combined #load Smyth data

#convert into human genes
library(dplyr)
library(nichenetr)
data <- as(as.matrix(GetAssayData(Lepto.Fibro, assay = "SCT")), 'sparseMatrix')#normalized data
pd <- data.frame(Lepto.Fibro@meta.data)
pData <- pd %>% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, seurat_clusters) #choose metadata
convert <- convert_mouse_to_human_symbols(rownames(data)) #convert mouse to human
rownames(data) <- make.names(convert, unique = T)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data)) #integrate human genes
Lepto.Fibro_human <- CreateSeuratObject(data, project = "leptomeninges", meta.data = pData, assay = "SCT") #choose pd instead of pData if you need all metadata)
#plot to human dura
Idents(samples_seurat) <- "main_groups"
anchors <- FindTransferAnchors(reference = samples_seurat, query = Lepto.Fibro_human, dims = 1:30, reference.reduction = "pca",normalization.method = "SCT", reference.assay = "integrated")
predictions <- TransferData(anchorset = anchors, refdata = samples_seurat$main_groups,dims = 1:30)
Lepto.Fibro_human <- AddMetaData(Lepto.Fibro_human, metadata = predictions)

Idents(Lepto.Fibro_human) <- "predicted.id"
Cell_num <- data.frame(predicted.id = Lepto.Fibro_human@meta.data$predicted.id)
Cell_num <- Cell_num |>
  group_by(predicted.id) |>
  summarise(Nb = n(), .groups = "drop") |>
  mutate(
    C = sum(Nb),
    percent = Nb / C * 100
  )


p7 <- ggplot(Cell_num, aes(x = "Smyth - leptomeninges", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)

#my dura sample
Cell_num <- data.frame(predicted.id = samples_seurat@meta.data$main_groups)
Cell_num <- Cell_num |>
  group_by(predicted.id) |>
  summarise(Nb = n(), .groups = "drop") |>
  mutate(
    C = sum(Nb),
    percent = Nb / C * 100
  )
p1 <- ggplot(Cell_num, aes(x = "dura", y = percent, fill = predicted.id))+
  geom_bar(stat = "identity") + theme_classic(base_size = 14) +
  theme(
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.text = element_text(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(color = "black")
  ) + scale_fill_manual(values = cluster_colors)


#save plots
p <- p1 + p7 + p2 + p6 + p5 + p3 + p4 + plot_layout(nrow = 1)
print(last_plot()) # ggsave(file.path(result_dir, "9.0_stacked_barplots_references_allcells.pdf"), p , width = 23, height = 5)

#refUMAP
#prepare human dura data
#save UMAP reduction (same UMAP as for previous analysis)
umap_reduction <- Embeddings(samples_seurat, "umap")
samples_seurat <- RunUMAP(
  samples_seurat,
  reduction = "pca",
  dims = 1:30,
  return.model = TRUE,  # store model for MapQuery
  umap.method = "umap-learn"
)
samples_seurat[["umap"]]@cell.embeddings <- umap_reduction

#refUMAP prediction
fibros <- MapQuery(anchorset = anchors, reference = samples_seurat, query = fibros,refdata = list(celltype = "main_groups"), reference.reduction = "pca", reduction.model = "umap")
Idents(samples_seurat) <- "main_groups"
U1 <- DimPlot(samples_seurat, reduction = "umap", group.by = "main_groups", label.size = 3, repel = TRUE, cols = cluster_colors) +
  NoLegend() + ggtitle("human Dura") + ylim(-19,19) + xlim(-10, +15)
U2 <- FeaturePlot(fibros, features = "predicted.celltype.score", reduction = "ref.umap", repel = T) +
  ylim(-19,19) + xlim(-10, +15)

# pdf("9.0_DimPlot_ref_Plot_all_cells_pred.pdf", width = 8, height = 5)
U1 + U2
# dev.off()

```

## 10. Endothelial Trajectory Analysis

Analyze the developmental trajectory of endothelial cells.

```{r eval=FALSE, include=TRUE}
Endos_combined <- subset(samples_seurat, idents = c("artEndo", "capEndo", "venEndo", "mixEndo"))

#convert Seurat object into Monocle object
#integrated and SCT (slot = "scale.data") do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don't use scale.data
data <- as(as.matrix(GetAssayData(Endos_combined, assay = "RNA", slot = "counts")), 'sparseMatrix')
pd <- data.frame(Endos_combined@meta.data)
pData <- pd %>% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

Endo_monocle <- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(Endo_monocle)$gene_short_name <- rownames(fData(Endo_monocle))
recreate.partitions <- c(rep(1, length(Endo_monocle@colData@rownames)))
names(recreate.partitions) <- Endo_monocle@colData@rownames
recreate.partitions <- as.factor(recreate.partitions)
recreate.partitions
Endo_monocle@clusters@listData[["UMAP"]][["partitions"]] <- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster <- Endos_combined@active.ident
Endo_monocle@clusters@listData[["UMAP"]][["clusters"]] <- list.cluster
Endo_monocle@int_colData@listData[["reducedDims"]]@listData[["UMAP"]] <- Endos_combined@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object

cluster_colors <- c("#19B700", "#26aab5", "#957e26", "#E46DF6")
cluster.before.traj <- plot_cells(Endo_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = "right") +  scale_color_manual(values = cluster_colors)

#let it calculate trajectory
#Endo_monocle <- learn_graph(Endo_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
Endo_monocle <- learn_graph(Endo_monocle, use_partition = F, verbose = T, close_loop = F)

#plot trajectory into UMAP
# pdf("10.0_Endo_traj_plot.pdf", width = 6, height = 5)
plot_cells(Endo_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
Endo_monocle <- order_cells(Endo_monocle, reduction_method = "UMAP", root_cells = colnames(Endo_monocle[, clusters(Endo_monocle) == 5]))
#if this Error appears "Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds", leave root_cells = NULL to manually select starting point
Endo_monocle <- order_cells(Endo_monocle, reduction_method = "UMAP", root_cells = NULL)

# pdf("10.0_Endo_traj_plot_UMAP_pseudotime.pdf", width = 6, height = 5)
plot_cells(Endo_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
Endo_monocle$monocle3_pseudotime <- pseudotime(Endo_monocle)
qsave(Endo_monocle, "10.0_Endo_traj_pseudotime.qs")
data.pseudo <- as.data.frame(colData(Endo_monocle))

# pdf("10.0_Endo_traj_pseudotime.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab("")
# dev.off()
#or alternatively order by pseudotime
# pdf("10.0_Endo_traj_pseudotime_order.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab("pseudotime") + ylab("")
# dev.off()

#find genes that change in pseudotime
deg <- graph_test(Endo_monocle, neighbor_graph = "principal_graph")
deg |> arrange(q_value, desc(morans_I)) |> filter(status == "OK") |> head()


#deg gene list can be looked at and saved
#Moran's value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, "10.0_Endos_monocle_DEG.xlsx")

#one can also save pseudotime values into Seurat object and then plot for
Endos_combined$pseudotime <- pseudotime(Endo_monocle)
# pdf("10.0_Endo_FP_pseudotime.pdf", width = 8, height = 5)
FeaturePlot(Endos_combined, features = "pseudotime")
# dev.off()

#one can do multiple expression plots with certain identified genes
RidgePlot(Endos_combined, features = c("VIM", "ARL15", "FBLN2"), sort = F, cols = cluster_colors)

#or also
my_genes <- row.names(subset(fData(Endo_monocle), gene_short_name %in% c("VIM", "ARL15", "NR4A1", "GJA5", "FTL1", "IL1R1")))
#arterial
my_genes <- row.names(subset(fData(Endo_monocle), gene_short_name %in% c("ARL15", "PLCB4", "TMTC1", "VEGFC")))
#capillary
my_genes <- row.names(subset(fData(Endo_monocle), gene_short_name %in% c("APOLD1", "FLT1", "STC1", "INSR")))
#venous
my_genes <- row.names(subset(fData(Endo_monocle), gene_short_name %in% c("FABP4", "IL1R1", "LRRC1", "VWF")))

#or load in list
Genes <- unlist(read_csv("Genes to Plot.txt", col_names = FALSE))

my_genes <- row.names(subset(fData(Endo_monocle), gene_short_name %in% c(Genes)))
Endo_monocle_subset <- Endo_monocle[my_genes,]
plot_genes_in_pseudotime(Endo_monocle_subset, color_cells_by = "monocle3_pseudotime" )
#or
# pdf("10.0_Endo_traj_genes_venous.pdf", width = 5, height = 4)
plot_genes_in_pseudotime(Endo_monocle_subset, color_cells_by = "annotated" ) + scale_color_manual(values = cluster_colors)
# dev.off()


#plot top5 genes that change over pseudotime in each cluster
deg_sig <- deg %>% filter(q_value < 0.05, status == "OK")

deg_sig$cluster <- Endo_monocle$annotated[ match(deg_sig$gene_short_name,
                                                 rownames(Endo_monocle)) ]

top5_per_cluster <- deg_sig %>%
  group_by(cluster) %>%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot <- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf("10.0_Endo_top5_per_cluster_genes_pseudotime.pdf", width = 5, height = 15)

plot_genes_in_pseudotime(
  Endo_monocle[genes_to_plot, ],
  color_cells_by = "annotated",
  min_expr = 0.1
) + scale_color_manual(values = cluster_colors)

# dev.off()

```

## 11. B-cell (Bc) Analysis

Perform detailed analysis of B-cells, including reclustering, marker identification, differential expression, and trajectory analysis.

### 11.0 B-cell Subset and Reclustering

Isolate B-cells, re-integrate data (handling small samples separately), and perform clustering.

```{r eval=FALSE, include=TRUE}
#Bc subset and new integration ####
#### subset Bc cluster ####
Bc_subset <- subset(samples_seurat, idents = c("Bc"))
Bc_subset@assays$integrated <- NULL
Bc_subset@assays$SCT <- NULL

qs::qsave(Bc_subset, file.path(result_dir, "11.0_Bc_subset.qs"))

#### cut off min 50 cells per sample ####
# split by sample
DefaultAssay(Bc_subset) <- "RNA"
Bc_list <- SplitObject(Bc_subset, split.by = "sample_id")
qs::qsave(Bc_list, file.path(result_dir, "11.0_Bc_list.qs"))

Bc_list_cutoff <- Bc_list[sapply(Bc_list, ncol) > 50] #cut_off 50

qs::qsave(Bc_list_cutoff, file.path(result_dir, "11.0_Bc_list_cutoff50.qs"))

#### new integration wih 12 samples (> 50 cells) ####
# SCTransform per sample
Bc_list_cutoff <- lapply(Bc_list_cutoff, function(x) {
  SCTransform(x, vst.flavor = "v2", verbose = TRUE)
})

# Select integration features
features <- SelectIntegrationFeatures(Bc_list_cutoff, nfeatures = 3000)

# Prepare SCT integration (computes residuals etc.)
Bc_list_SCT <- PrepSCTIntegration(Bc_list_cutoff, anchor.features = features)

# Find anchors
anchors <- FindIntegrationAnchors(object.list = Bc_list_SCT,
                                  normalization.method = "SCT",
                                  anchor.features = features,
                                  dims = 1:30)

# Integrate
Bc_combined <- IntegrateData(anchorset = anchors,
                             normalization.method = "SCT", k.weight = 53)

Bc_combined <- RunPCA(Bc_combined, verbose = TRUE)
Bc_combined <- RunUMAP(Bc_combined, dims = 1:30)
Bc_combined <- FindNeighbors(Bc_combined, dims = 1:30)

qs::qsave(Bc_combined, file.path(result_dir, "11.0_Bc_combined.qs"))

resolution_check <- FindClusters(Bc_combined, resolution = c(0.2, 0.4, 0.6, 0.7, 0.8, 1.0, 1.2))
tree <- clustree(resolution_check)

Bc_seurat <- FindClusters(Bc_combined, resolution = 0.6) #change

qs::qsave(Bc_all_seurat, file.path(result_dir, "11.0_Bc_all_seurat_cutoff50_res0.6.qs"))

# pdf("11.0_DimPlot.pdf", width = 5, height = 5)
DimPlot(Bc_seurat, label = T)
# dev.off()

# pdf("11.0_DimPlot_condition.pdf", width = 8, height = 5)
DimPlot(Bc_seurat, label = T, split.by = "condition")
# dev.off()

# pdf("11.0_DimPlot_samples.pdf", width = 22, height = 20)
DimPlot(Bc_seurat, label = T, split.by = "sample_id", ncol = 5)
# dev.off()

# pdf("11.0_DimPlot_condition_group.pdf", width = 5, height = 5)
DimPlot(Bc_seurat, group.by = "condition")
# dev.off()

# pdf("11.0_DimPlot_samples_group.pdf", width = 5, height = 5)
DimPlot(Bc_seurat, group.by = "sample_id")
# dev.off()

#### Prepare backbone (already integrated and clustered of samples with > 50 cells) ####
Bc_seurat <- qread("11.0_Bc_seurat_cutoff50_res0.6.qs")
# Ensure UMAP model exists for mapping
if (!"umap" %in% names(Bc_seurat@reductions)) {
  Bc_seurat <- RunUMAP(
    Bc_seurat, dims = 1:30, reduction = "pca",
    return.model = TRUE
  )
}
if (is.null(Bc_seurat@reductions$umap@misc$model)) {
  Bc_seurat <- RunUMAP(
    Bc_seurat, dims = 1:30, reduction = "pca",
    return.model = TRUE
  )
}

#### prepare samples with <50 cells ####
# Load all B cells
Bc_list <- qread("11.0_Bc_list.qs")
# Split small samples (<50 cells)
Bc_list_smaller50 <- Bc_list[sapply(Bc_list, ncol) < 50]
# Merge small samples (I had to merge them, otherwise the integration would not have worked for samples with 15 cells)
Bc_smaller50_merged <- merge(Bc_list_smaller50[[1]], y = Bc_list_smaller50[-1])
# SCT normalize small samples
DefaultAssay(Bc_smaller50_merged) <- "RNA"
Bc_smaller50_merged <- SCTransform(Bc_smaller50_merged, vst.flavor = "v2", verbose = TRUE)

qs::qsave(Bc_smaller50_merged, file.path(result_dir, "11.0_Bc_smaller50_merged.qs"))

# map remaining samples (with <50 cells) into the "backbone" ####
# Find anchors and transfer clusters
anchors <- FindTransferAnchors(
  reference = Bc_seurat,
  query = Bc_smaller50_merged,
  dims = 1:30,
  reference.reduction = "pca",
  normalization.method = "SCT",
  reference.assay = "integrated"
)

predictions <- TransferData(
  anchorset = anchors,
  refdata = Bc_seurat$seurat_clusters,
  dims = 1:30
)

# Add predicted clusters to small samples
Bc_smaller50_merged$predicted_clusters <- predictions$predicted.id

# Map small cells to UMAP
mapped <- MapQuery(
  anchorset = anchors,
  query = Bc_smaller50_merged,
  reference = Bc_seurat,
  refdata = Bc_seurat$seurat_clusters,
  reduction.model = "umap"
)

# pdf("11.01_Bc_onlymapped.pdf", width = 5, height = 5)
DimPlot(mapped, label = T)
# dev.off()

#Prepare SCT assays for merging
Bc_seurat_sct <- subset(Bc_seurat, features = rownames(Bc_seurat[["SCT"]]))
Bc_smaller50_merged_sct <- subset(Bc_smaller50_merged, features = rownames(Bc_smaller50_merged[["SCT"]]))

Bc_seurat_sct@assays <- list(SCT = Bc_seurat[["SCT"]])
Bc_smaller50_merged_sct@assays <- list(SCT = Bc_smaller50_merged[["SCT"]])

DefaultAssay(Bc_seurat_sct) <- "SCT"
DefaultAssay(Bc_smaller50_merged_sct) <- "SCT"

# add reduction information
Bc_smaller50_merged_sct@reductions$umap <- mapped@reductions$ref.umap
Bc_smaller50_merged_sct$seurat_clusters <- Bc_smaller50_merged_sct$predicted_clusters

#merge samples
Bc_all <- merge(
  x = Bc_seurat_sct,
  y = Bc_smaller50_merged_sct
)

DefaultAssay(Bc_all) <- "SCT"

umap_combined <- rbind(
  Embeddings(Bc_seurat_sct, "umap"),
  Embeddings(Bc_smaller50_merged_sct, "umap")
)

rownames(umap_combined) <- colnames(Bc_all)

Bc_all[["umap"]] <- CreateDimReducObject(
  embeddings = umap_combined,
  key = "UMAP_",
  assay = "SCT"
)

qs::qsave(Bc_all, file.path(result_dir, "11.0_Bc_all_mapped.qs"))

Bc_all_seurat <- Bc_all
Bc_all_seurat <- qread("11.0_Bc_all_mapped.qs")


# pdf("11.01_DimPlot_Bc_all.pdf", width = 5, height = 5)
DimPlot(Bc_all_seurat, label = T)
# dev.off()

# pdf("11.01_DimPlot_condition_Bc_all.pdf", width = 8, height = 5)
DimPlot(Bc_all_seurat, label = T, split.by = "condition")
# dev.off()

# pdf("11.01_DimPlot_samples_Bc_all.pdf", width = 22, height = 20)
DimPlot(Bc_all_seurat, label = T, split.by = "sample_id", ncol = 5)
# dev.off()

# pdf("11.01_DimPlot_condition_group_Bc_all.pdf", width = 5, height = 5)
DimPlot(Bc_all_seurat, group.by = "condition")
# dev.off()

# pdf("11.01_DimPlot_samples_group_Bc_all.pdf", width = 5, height = 5)
DimPlot(Bc_all_seurat, group.by = "sample_id")
# dev.off()

```

### 11.1 Marker Gene Identification

Identify marker genes for B-cell clusters.

```{r eval=FALSE, include=TRUE}
Idents(Bc_all_seurat) <- "seurat_clusters"
DefaultAssay(Bc_all_seurat) <- "SCT"

# Fix umi.assay across all SCT models (works in v4 and v5)
#https://github.com/satijalab/seurat/issues/8515
#https://github.com/satijalab/seurat/issues/9725
if ("SCT" %in% names(Bc_all_seurat@assays)) {
  sct_models <- Bc_all_seurat@assays$SCT@SCTModel.list
  for (i in seq_along(sct_models)) {
    message("Fixing umi.assay for SCT model ", i)
    slot(Bc_all_seurat@assays$SCT@SCTModel.list[[i]], name = "umi.assay") <- "SCT"
  }
}

# Double-check the results
SCTResults(Bc_all_seurat, slot = "umi.assay")
Bc_all_seurat <- PrepSCTFindMarkers(Bc_all_seurat, assay = "SCT")
qsave(Bc_all_seurat, file.path(result_dir, "11.1_Bc_all_seurat_downstream_analysis.qs"))
markers <- FindAllMarkers(Bc_all_seurat, assay = "SCT", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted <- markers %>%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list <- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = "11.1_Bc_Cluster_Markers.xlsx")

rm(marker_list, markers, markers_sorted)

```

### 11.1.1 Plot Top Marker Genes

Visualize the top 5 marker genes using a dot plot.

```{r eval=FALSE, include=TRUE}
Idents(Bc_all_seurat) <- "seurat_clusters"
DefaultAssay(Bc_all_seurat) <- "SCT"
genes<- read_csv("marker_genes_Bc_top5.txt", col_names = FALSE)
# pdf("11.1.1_DotPlot_marker_genes_Bc_top5.pdf", width = 12, heigh = 6)
DotPlot(Bc_all_seurat, assay ="SCT", features = genes)+
  scale_color_viridis_c()+RotatedAxis()
# dev.off()

```

### 11.3 Differential Expression (DE) Analysis

Perform DE analysis between MS and Control conditions for each B-cell cluster.

```{r eval=FALSE, include=TRUE}
Bc_all_seurat <- qread("11.1_Bc_all_seurat_downstream_analysis.qs")
DefaultAssay(Bc_all_seurat) <- "SCT"
Idents(Bc_all_seurat) <- "seurat_clusters"
Bc_all_seurat$annotated <- factor(Bc_all_seurat$seurat_clusters)
Idents(Bc_all_seurat) <- "annotated"

de_nested_list <- list()
comparisons <- list(
  c("MS", "Ctrl")
)

for (comp in comparisons) {
  ident_1 <- comp[1]
  ident_2 <- comp[2]
  comp_name <- paste0(ident_1, "_vs_", ident_2)

  message("Running comparison: ", comp_name)
  de_nested_list[[comp_name]] <- list()

  for (i in levels(Bc_all_seurat$annotated)) {
    message("  Processing cluster: ", i)

    cells_in_cluster <- WhichCells(Bc_all_seurat, idents = i)
    cluster_meta <- Bc_all_seurat@meta.data[cells_in_cluster, ]

    group_counts <- table(cluster_meta$condition)

    cluster_name <- paste0("Cluster_", i)

    if (all(c(ident_1, ident_2) %in% names(group_counts)) &&
        all(group_counts[c(ident_1, ident_2)] >= 3)) {

      de <- tryCatch({
        FindMarkers(
          Bc_all_seurat,
          ident.1 = ident_1,
          ident.2 = ident_2,
          subset.ident = i,
          group.by = "condition",
          recorrect_umi = FALSE
        )
      }, error = function(e) {
        message("    ERROR in cluster ", i, ": ", conditionMessage(e))
        return(NULL)
      })

      if (!is.null(de) && nrow(de) > 0) {
        de$gene <- rownames(de)
        de <- de[order(de$p_val_adj, -de$avg_log2FC), ]
        de_nested_list[[comp_name]][[cluster_name]] <- de
      } else {
        message("    No DE genes found for cluster ", i)
        de_nested_list[[comp_name]][[cluster_name]] <- data.frame(
          Note = "No DE genes found despite sufficient cells"
        )
      }

    } else {
      message("    Skipping cluster ", i, "  too few cells in one or both groups")
      de_nested_list[[comp_name]][[cluster_name]] <- data.frame(
        Note = paste("Too few cells in", ident_1, "or", ident_2)
      )
    }
  }
}

saveRDS(de_nested_list, "11.3_de_nested_list_Bc_SCT_condition.rds")

# Save each comparison as its own Excel file
for (comp_name in names(de_nested_list)) {
  file_name <- paste0("11.3_DE_SCT_Bc_", comp_name, ".xlsx")
  write.xlsx(de_nested_list[[comp_name]], file = file_name)
  message("Saved: ", file_name)
}

```

### 11.3.1 Volcano Plots for DE Genes

Visualize DE results using volcano plots.

```{r eval=FALSE, include=TRUE}
de_file <- "11.3_DE_SCT_Bc_MS_vs_Ctrl.xlsx"

all_clusters <- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message("Processing cluster: ", cluster)

  # Read cluster sheet
  de_data <- read.xlsx(de_file, sheet = cluster)

  # Check if de_data is empty
  if (nrow(de_data) == 0 || !"gene" %in% colnames(de_data)) {
    message(paste("Skipping cluster", cluster, "- no DE genes found"))
  } else {
    volcano_genes <- de_data

    #remove MT, RPL, RPS genes and Lnc
    volcano_genes <- volcano_genes %>% filter(!grepl("^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.", gene))
    #Define sig. up/down-reg genes
    volcano_genes$DE <- "NO"
    volcano_genes$DE[volcano_genes$avg_log2FC > 0.5 & volcano_genes$p_val_adj < 0.001] <- "Up"
    volcano_genes$DE[volcano_genes$avg_log2FC < -0.5 & volcano_genes$p_val_adj < 0.001] <- "Down"
    #sign. up & down
    volcano_genes$sig <- ifelse(volcano_genes$DE == "NO", "", volcano_genes$gene)
    sig <- volcano_genes$sig
    volcano_genes$sig <- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
    volcano_genes$DE <- factor(volcano_genes$DE, levels = c("Down", "NO", "Up"))
    volcano_genes$logP <- -log10(volcano_genes$p_val_adj)
    volcano_genes$logP <- pmin(volcano_genes$logP, 50)

    # Count up- and down-regulated genes
    n_up <- sum(volcano_genes$DE == "Up", na.rm = TRUE)
    n_down <- sum(volcano_genes$DE == "Down", na.rm = TRUE)

    # Filter only significant DE genes
    sig_genes <- volcano_genes %>%
      filter(DE != "NO")
    # Rank first by adjusted p-value, then by absolute log2FC
    top_genes <- sig_genes %>%
      arrange(p_val_adj, desc(abs(avg_log2FC))) %>%  # first p-value, then log2FC
      slice_head(n = 200) %>%                         # top 200 genes
      pull(gene)

    # Update sig column to label only top 200 genes
    volcano_genes$sig <- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

    p <- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
      geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
      geom_hline(yintercept = -log10(0.001), color = "gray40", linetype = "dashed") +
      geom_point(size = 3, alpha = 0.8) +
      scale_color_manual(values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
                         labels = c("Down", "ns", "Up")) +
      geom_text_repel(max.overlaps = 50, size = 3) +
      theme_classic(base_size = 14) +
      labs(
        x = "log Fold Change",
        y = expression(-log[10]("adjusted p-value")),
        color = "Regulation"
      ) +
      annotate("text", x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0("Up: ", n_up), hjust = 1, vjust = -0.5, color = "#3d70b5", size = 5) +
      annotate("text", x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0("Down: ", n_down), hjust = 0, vjust = -0.5, color = "black", size = 5)

    # Save per cluster
    out_file <- paste0("11.3.1_VolcanoPlot_DE_", cluster, "_DE.pdf")
    print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
  }
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)

```

### 11.4 Monocle Trajectory Analysis

Analyze B-cell developmental trajectories using Monocle3.

#### 11.4.0 Pseudotime Calculation

Convert Seurat object to Monocle3, learn trajectory graph, and order cells in pseudotime.

```{r eval=FALSE, include=TRUE}
#convert Seurat object into Monocle object
#integrated and SCT (slot = "scale.data") do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don't use scale.data
#best is to use "RNA", "counts"

#needed to remove one cells because the cell had no information
Bc_all_seurat <- subset(
  Bc_all_seurat,
  cells = colnames(Bc_all_seurat)[colnames(Bc_all_seurat) != "C115_H_P10_CAAGGTTAGTCATAAGAGTAGGCT-1"]
)


Idents(Bc_all_seurat) <- "seurat_clusters"
data <- as(as.matrix(GetAssayData(Bc_all_seurat, assay = "SCT", slot = "counts")), 'sparseMatrix') #normally on RNA
pd <- data.frame(Bc_all_seurat@meta.data)
pData <- pd %>% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

Bc_monocle <- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(Bc_monocle)$gene_short_name <- rownames(fData(Bc_monocle))
recreate.partitions <- c(rep(1, length(Bc_monocle@colData@rownames)))
names(recreate.partitions) <- Bc_monocle@colData@rownames
recreate.partitions <- as.factor(recreate.partitions)
recreate.partitions
Bc_monocle@clusters@listData[["UMAP"]][["partitions"]] <- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster <- Bc_all_seurat@active.ident
Bc_monocle@clusters@listData[["UMAP"]][["clusters"]] <- list.cluster
Bc_monocle@int_colData@listData[["reducedDims"]]@listData[["UMAP"]] <- Bc_all_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors <- c("#a3a500", "#f8766d", "#00b0f6", "#e76bf3", "#00bf7d")
cluster.before.traj <- plot_cells(Bc_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = "right") +  scale_color_manual(values = cluster_colors)

# pdf("11.4.0_Bc_before_traj_plot.pdf", width = 4, height = 3)
cluster.before.traj
# dev.off()

#let it calculate trajectory
Bc_monocle <- learn_graph(Bc_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
Bc_monocle <- learn_graph(Bc_monocle, use_partition = F, verbose = T, close_loop = F)

#plot trajectory into UMAP
# pdf("11.4.0_Bc_traj_plot.pdf", width = 4, height = 3)
plot_cells(Bc_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
Bc_monocle <- order_cells(Bc_monocle, reduction_method = "UMAP", root_cells = colnames(Bc_monocle[, clusters(Bc_monocle) == 5]))
#if this Error appears "Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds", leave root_cells = NULL to manually select starting point
#Bc_monocle <- order_cells(Bc_monocle, reduction_method = "UMAP", root_cells = NULL)

# pdf("11.4.0_Bc_traj_plot_UMAP_pseudotime.pdf", width = 5, height = 4)
plot_cells(Bc_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
Bc_monocle$monocle3_pseudotime <- pseudotime(Bc_monocle)
data.pseudo <- as.data.frame(colData(Bc_monocle))

# pdf("11.4.0_Bc_traj_pseudotime.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab("")
# dev.off()
#or alternatively order by pseudotime
# pdf("11.4.0_Bc_traj_pseudotime_order.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab("pseudotime") + ylab("")
# dev.off()

qsave(Bc_monocle, "11.4.0_Bc_monocle.qs")

```

#### 11.4.1 Genes Changing Along Pseudotime

Identify and visualize genes that change expression along the pseudotime trajectory.

```{r eval=FALSE, include=TRUE}
#find genes that change in pseudotime
deg <- graph_test(Bc_monocle, neighbor_graph = "principal_graph", verbose = TRUE)
deg |> arrange(q_value, desc(morans_I)) |> filter(status == "OK") |> head()

#deg gene list can be looked at and saved
#Moran's value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, "11.4.1_Bcs_monocle_DEG.xlsx")

#one can also save pseudotime values into Seurat object and then plot for
Bc_all_seurat$pseudotime <- pseudotime(Bc_monocle)
# pdf("11.4.1_Bc_FP_pseudotime.pdf", width = 4, height = 3)
FeaturePlot(Bc_all_seurat, features = "pseudotime")
# dev.off()


```

#### 11.4.2 Gene Expression Along Pseudotime

Plot expression trends for specific genes of interest along the pseudotime.

```{r eval=FALSE, include=TRUE}
#one can do multiple expression plots with certain identified genes
# pdf("11.4.2_Bc_pseudotime_RP_genes_of_ineterest.pdf", width = 8, height = 9)
RidgePlot(Bc_all_seurat, features = c("CD19", "CD79A", "CD79B", "IGHG1", "IGHG2", "IGHA1", "IGHA2", "IGHM", "IGHD", "CD179A", "SDC1", "CD38", "MZB1", "VPREB3", "MS4A1"), sort = F, cols = cluster_colors)
# dev.off()


my_genes <- c("CD19", "CD79A", "CD79B", "IGHG1", "IGHA1", "IGHA2", "IGHM", "IGHD", "SDC1", "CD38", "MZB1", "MS4A1")
Bc_monocle_subset <- Bc_monocle[my_genes,]
plot_genes_in_pseudotime(Bc_monocle_subset, color_cells_by = "monocle3_pseudotime" )
#or
# pdf("11.4.2_Bc_genes_of_ineterest_traj_pseudocolor.pdf", width = 5, height = 10)
plot_genes_in_pseudotime(Bc_monocle_subset, color_cells_by = "monocle3_pseudotime" )
# dev.off()

# pdf("11.4.2_Bc_genes_of_ineterest_traj_annotated.pdf", width = 5, height = 10)
plot_genes_in_pseudotime(Bc_monocle_subset, color_cells_by = "annotated" )
# dev.off()

```

#### 11.4.3 Top Changing Genes in Pseudotime

Visualize the top 5 genes with the most significant changes along pseudotime for each cluster.

```{r eval=FALSE, include=TRUE}
#plot top5 genes that change over pseudotime in each cluster
deg_sig <- deg %>% filter(q_value < 0.05, status == "OK")

deg_sig$cluster <- Bc_monocle$annotated[ match(deg_sig$gene_short_name,
                                               rownames(Bc_monocle)) ]

top5_per_cluster <- deg_sig %>%
  group_by(cluster) %>%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot <- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf("11.4.3_Bc_top_genes_pseudotime.pdf", width = 5, height = 25)

plot_genes_in_pseudotime(
  Bc_monocle[genes_to_plot, ],
  color_cells_by = "annotated",
  min_expr = 0.1
)

# dev.off()


```

#### 11.4.4 Condition-Dependent Gene Expression

Identify genes whose expression changes along pseudotime differ between conditions.

```{r eval=FALSE, include=TRUE}
#find genes that vary across condition
gene_fits <- fit_models(Bc_monocle, model_formula_str = "~condition")
gene_fits_tbl <- coefficient_table(gene_fits)
write.xlsx(gene_fits_tbl, "11.4.4_Bcs_pseudotime_condition.xlsx")

# Keep only the condition coefficients
deg_cond <- gene_fits_tbl %>%
  filter(term != "(Intercept)")

# Significant genes
sig_genes <- deg_cond %>%
  filter(q_value < 0.05)

# Rank for labeling: first q-value, then |estimate|
top_genes <- sig_genes %>%
  arrange(q_value, desc(abs(estimate))) %>%
  slice_head(n = 50) %>%
  pull(gene_short_name)

deg_volcano <- deg_cond %>%
  mutate(
    logFC = estimate,
    negLogQ = -log10(q_value),
    DE = case_when(
      estimate > 0.5  & q_value < 0.05 ~ "Up",
      estimate < -0.5 & q_value < 0.05 ~ "Down",
      TRUE                              ~ "NO"
    ),
    logP = pmin(negLogQ, 50),      # cap values for nicer plot
    label_it = ifelse(gene_short_name %in% top_genes, gene_short_name, NA)
  )


deg_volcano$label_italic <- ifelse(
  is.na(deg_volcano$label_it),
  NA,
  paste0("italic('", deg_volcano$label_it, "')")
)

p <- ggplot(deg_volcano, aes(x = logFC, y = logP, color = DE)) +
  geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "gray40", linetype = "dashed") +
  geom_point(size = 3, alpha = 0.8) +

  scale_color_manual(
    values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
    labels = c("Down", "ns", "Up")
  ) +

  ggrepel::geom_text_repel(
    aes(label = label_italic),
    parse = TRUE,
    max.overlaps = 50,
    size = 3
  ) +

  theme_classic(base_size = 14) +
  labs(
    title = "Condition-dependent DEGs along trajectory",
    x = "log Fold Change",
    y = expression(-log[10]("adjusted p-value")),
    color = "Regulation"
  )

print(last_plot()) # ggsave(file.path(result_dir, "11.4.4_Bc_pseudotime_VolcanoPlot_DE_MS_vs_ctrl.pdf"), p , width = 10, height = 7)

#plot genes over pseudotime
top_genes <- top_sig$gene_short_name

p <- plot_genes_in_pseudotime(
  Bc_monocle[top_genes, ],
  color_cells_by = "condition"
)

print(last_plot()) # ggsave(file.path(result_dir, "11.4.4_Bc_pseudotime_along_traj_Plot_DE_MS_vs_ctrl.pdf"), p , width = 5, height = 25)

```

## 12. Score Analysis

Calculate and analyze Fibrosis and IFN scores across conditions.

```{r eval=FALSE, include=TRUE}

```

## 12.1 Fibrosis Score

Compute fibrosis scores based on a gene set and compare between MS and Control.

```{r eval=FALSE, include=TRUE}
DefaultAssay(samples_seurat) <- "SCT"
fibrosis <- read_csv("fibrosis.txt", col_names = FALSE) #genes from GO:0030198 = ECM related and upregulated in strucFibro reclustered
fibrosis_score <- AddModuleScore(samples_seurat, features = fibrosis, name = "fibrosisScore")
FeaturePlot(fibrosis_score, features ="fibrosisScore1", split.by = "condition")
VlnPlot(fibrosis_score, features ="fibrosisScore1", split.by = "condition",  cols = c("grey", "darkblue"))
Idents(fibrosis_score) <- "condition"
DotPlot(fibrosis_score, features ="fibrosisScore1")

df <- FetchData(fibrosis_score, vars = c("fibrosisScore1", "condition", "annotated", "sample_id"))
df_avg <- df %>%
  group_by(annotated, condition, sample_id) %>%
  summarise(fibrosisScore1 = mean(fibrosisScore1, na.rm = TRUE), .groups = "drop")
df_collapsed <- df_avg %>%
  group_by(sample_id, condition) %>%
  summarise(fibrosisScore1 = mean(fibrosisScore1), .groups = "drop")

# pdf("12.1_MzH_human_dura_fibrosis_score_MS_vs_Ctrl_all_cluster.pdf", width = 4, height = 6)
ggplot(df_collapsed, aes(x = condition, y = fibrosisScore1, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6, size = 2, width = 0.2) +
  stat_compare_means(label = "p.signif", method = "wilcox.test") +
  scale_fill_manual(values = c("Ctrl" = "darkgrey", "MS" = "#3d70b5")) +
  theme_classic() +
  labs(title = "fibrosis score all cluster MzH_human_dura", x = "Condition", y = "average fibrosis score per sample")
# dev.off()

```

## 12.2 IFN Score

Compute Interferon (IFN) scores and compare between MS and Control.

```{r eval=FALSE, include=TRUE}
#extract IF genes
all_genes <- rownames(samples_seurat)
IFN_genes <- grep("^(IFI)", all_genes, value = TRUE, ignore.case = TRUE) #interferone induced

IFN_score <- AddModuleScore(samples_seurat, features = IFN_genes, name = "IFNScore")

df <- FetchData(IFN_score, vars = c("IFNScore1", "condition", "annotated", "sample_id"))
df_avg <- df %>%
  group_by(annotated, condition, sample_id) %>%
  summarise(IFNScore1 = mean(IFNScore1, na.rm = TRUE), .groups = "drop")
df_collapsed <- df_avg %>%
  group_by(sample_id, condition) %>%
  summarise(IFNScore1 = mean(IFNScore1), .groups = "drop")

p <- ggplot(df_collapsed, aes(x = condition, y = IFNScore1, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6, size = 2, width = 0.2) +
  stat_compare_means(label = "p.signif", method = "wilcox.test") +
  scale_fill_manual(values = c("Ctrl" = "darkgrey", "MS" = "#3d70b5")) +
  scale_color_manual(values = c("Ctrl" = "darkgrey", "MS" = "#3d70b5")) +
  theme_classic() +
  labs(title = "IFN-induced score all cluster MzH_human_dura", x = "Condition", y = "average IFN score per sample")
print(last_plot()) # ggsave(file.path(result_dir, "12.2_MzH_human_dura_IFN-induced_score_MS_vs_Ctrl_all_cluster.pdf"), p, width = 4, height = 6)

```

## 12.3 Score Correlation

Analyze the correlation between Fibrosis and IFN scores.

```{r eval=FALSE, include=TRUE}
fibrosis <- read_csv("fibrosis.txt", col_names = FALSE) #genes from DE strucFibro fibrosis related
fibrosis_score <- AddModuleScore(samples_seurat, features = fibrosis, name = "fibrosisScore")
df_fibrosis <- FetchData(fibrosis_score, vars = c("fibrosisScore1", "condition", "annotated", "sample_id"))
df_avg_fibrosis <- df_fibrosis %>%
  group_by(annotated, condition, sample_id) %>%
  summarise(fibrosisScore1 = mean(fibrosisScore1, na.rm = TRUE), .groups = "drop")
IFN_genes <- grep("^(IFI)", all_genes, value = TRUE, ignore.case = TRUE)
IFN_score <- AddModuleScore(samples_seurat, features = IFN_genes, name = "IFNScore")
df_IFN <- FetchData(IFN_score, vars = c("IFNScore1", "condition", "annotated", "sample_id"))
df_avg_IFN <- df_IFN %>%
  group_by(annotated, condition, sample_id) %>%
  summarise(IFNScore1 = mean(IFNScore1, na.rm = TRUE), .groups = "drop")

df_merged <- inner_join(df_fibrosis, df_IFN, by = c("sample_id", "condition", "annotated"))

df <- df_merged %>%
  dplyr::select(fibrosisScore1, IFNScore1) %>%
  filter(!is.na(fibrosisScore1) & !is.na(IFNScore1))

df_patient <- df_merged %>%
  group_by(sample_id, condition) %>%
  summarise(
    fibrosis_avg = mean(fibrosisScore1, na.rm = TRUE),
    IFN_avg = mean(IFNScore1, na.rm = TRUE)
  )

cor_test <- cor.test(df_patient$fibrosis_avg, df_patient$IFN_avg, method = "spearman")
r_val <- round(cor_test$estimate, 2)
p_val <- cor_test$p.value
p_label <- ifelse(p_val < 0.001, "< 0.001", paste0("= ", signif(p_val, 2)))
n_obs <- nrow(df_patient)

p <- ggplot(df_patient, aes(x = IFN_avg, y = fibrosis_avg, color = condition)) +
  geom_point(size = 3, alpha = 0.8) +       # points colored by condition
  geom_smooth(method = "lm", se = TRUE, color = "black", size = 0.7) +  # single overall trend line
  theme_classic(base_size = 12) +
  labs(
    title = paste0("Fibrosis vs IFN-induced score per patient (rho = ", r_val, ", p ", p_label, ", n = ", n_obs, ")"),
    x = "IFN score (per patient)",
    y = "Fibrosis score (per patient)",
    color = "Condition"
  ) +
  scale_color_manual(values = c("Ctrl" = "darkgrey", "MS" = "#3d70b5")) +
  theme(plot.title = element_text(face = "bold", size = 13))

print(last_plot()) # ggsave("12.3_Fibrosis_vs_IFN_per_patient_corelation_all_cluster.pdf", p, width = 8, height = 6)

```

## 12.4 Score Density PCA

Visualize the distribution of Fibrosis and IFN scores using PCA density plots.

```{r eval=FALSE, include=TRUE}
#use df_patient from step 12.3
df_pca <- df_patient %>%
  ungroup() %>%
  dplyr::select(fibrosis_avg, IFN_avg)

pca_res <- prcomp(df_pca, center = TRUE, scale. = TRUE)

pca_scores <- as.data.frame(pca_res$x)
pca_scores$sample_id <- df_patient$sample_id
pca_scores$condition <- df_patient$condition

p <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = condition)) +
  geom_point(size = 3, alpha = 0.8) +
  theme_classic(base_size = 12) +
  stat_ellipse(geom = "polygon", aes(fill = after_scale(alpha(colour, 0.2))),
               size = 1) +
  labs(
    title = "PCA of Fibrosis and IFN scores per patient",
    x = paste0("PC1 (", round(summary(pca_res)$importance[2,1]*100, 1), "%)"),
    y = paste0("PC2 (", round(summary(pca_res)$importance[2,2]*100, 1), "%)"),
    color = "Condition"
  ) +
  scale_color_manual(values = c("Ctrl" = "darkgrey", "MS" = "#3d70b5")) +
  theme(plot.title = element_text(face = "bold", size = 13))

library(ggExtra)

p_marginal <- ggMarginal(p, type = "density", groupColour = TRUE, groupFill = TRUE)
print(last_plot()) # ggsave("12.4_Fibrosis_vs_IFN_per_patient_density_PCA.pdf", p_marginal, width = 6, height = 6)


```

## 12.5 fibrosis score in fibrotic tissue

```{r eval=FALSE, include=TRUE}
skin <- skin_fibros_Deng #load fibrotic skin dataset Deng
rm(anchors, p1, p2, predictions, samples_combined, skin_fibros_Deng)

fibrosis <- read_csv("fibrosis.txt", col_names = FALSE) #genes from GO:0030198 = ECM related and upregulated in strucFibro reclustered
fibrosis_score <- AddModuleScore(skin, features = fibrosis, name = "fibrosisScore")

df <- FetchData(fibrosis_score, vars = c("fibrosisScore1", "condition", "sample"))
df_avg <- df %>%
  group_by(condition, sample) %>%
  summarise(fibrosisScore1 = mean(fibrosisScore1, na.rm = TRUE), .groups = "drop")
df_collapsed <- df_avg %>%
  group_by(sample, condition) %>%
  summarise(fibrosisScore1 = mean(fibrosisScore1), .groups = "drop")
df_collapsed$condition <- factor(df_collapsed$condition, levels = c("NF", "KF"))

# pdf("12.5_fibrosis_score_in_Deng_fibrotic_skin.pdf", width = 4, height = 6)
ggplot(df_collapsed, aes(x = condition, y = fibrosisScore1, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6, size = 2, width = 0.2) +
  stat_compare_means(label = "p.signif", method = "wilcox.test") +
  scale_fill_manual(values = c("NF" = "darkgrey", "KF" = "#3d70b5")) +
  theme_classic() +
  labs(title = "fibrosis score in fibrotic skin", x = "Condition", y = "average fibrosis score per sample")
# dev.off()

```

## 13. Milo Differential Abundance Analysis

Perform differential abundance analysis using Milo to identify neighborhoods with significant changes in cell counts between conditions.

```{r eval=FALSE, include=TRUE}
#https://marionilab.github.io/miloR/articles/milo_demo.html
# Key concepts:
# 1. Neighborhoods: Groups of similar cells defined by k-nearest neighbors in reduced dimension space
# 2. Differential Abundance (DA): Statistical testing to find neighborhoods with significantly
#    different cell counts between conditions (e.g., treatment vs control)
# 3. Spatial FDR: Multiple testing correction that considers the overlap structure of neighborhoods

```

### 13.1 Pre-processing

Prepare the Seurat object for Milo analysis by converting it to a SingleCellExperiment object and adding dimensionality reduction data.

```{r eval=FALSE, include=TRUE}
# need lognormalized data
samples_seurat_log <- NormalizeData(samples_seurat, assay = "RNA", normalization.method = "LogNormalize")
# Convert Seurat object to SingleCellExperiment (SCE) object required by Milo
sce <- as.SingleCellExperiment(samples_seurat_log)
# add PCA and UMAP data
reducedDim(sce, "PCA") <- samples_seurat@reductions$pca@cell.embeddings
reducedDim(sce, "UMAP") <- samples_seurat@reductions$umap@cell.embeddings

```

### 13.2 Create Milo Object

Initialize the Milo object and add relevant metadata (sample, condition, etc.).

```{r eval=FALSE, include=TRUE}
milo <- Milo(sce)
# Add sample information (donor_id) to Milo object
milo@colData$sample <- samples_seurat@meta.data$sample
milo@colData$condition <- samples_seurat@meta.data$condition
milo@colData$age <- samples_seurat@meta.data$age
milo@colData$sex <- samples_seurat@meta.data$sex
milo@colData$cohort <- samples_seurat@meta.data$cohort
milo@colData$pool <- samples_seurat@meta.data$pool
milo@colData$biobank <- samples_seurat@meta.data$biobank
milo@colData$annotated <- samples_seurat@meta.data$annotated

```

### 13.3 Estimate Neighborhood Size (K)

Estimate the optimal k parameter for neighborhood definition.

```{r eval=FALSE, include=TRUE}
ks_to_test <- c(20, 30, 40, 50, 80, 100)

nhood_size_estimates <- estimate_neighbourhood_sizes(milo, k_grid = ks_to_test, order = 2, prop = 0.1, filtering = TRUE, reducedDim_name = "UMAP", plot_stat = T)

best_k <- 80

```

### 13.4 Assign Neighborhoods

Assign cells to neighborhoods based on the optimal k.

```{r eval=FALSE, include=TRUE}
set.seed(42)
milo_k <- assign_neighbourhoods(milo, k = best_k, order = 2, filtering = TRUE, reducedDim_name = "UMAP", verbose = F)

nhoods_milo <- nhoods(milo_k)
# assign cell types for nhoods
nhood_stat_ct <- data.frame(Nhood = 1:ncol(nhoods_milo) , Nhood_center = colnames(nhoods_milo))
nhood_stat_ct <- miloR::annotateNhoods(milo_k , nhood_stat_ct , coldata_col = "annotated")
p <- plot_milo_by_single_metric(milo_k, nhood_stat_ct, colour_by = "annotated" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_manual(values = cluster_colors , name = "cluster")

print(last_plot()) # ggsave(file.path(result_dir, "13.4_neighborhoods_k80_cluster.pdf"), p, width = 8, heigh = 5)
qsave(milo_k, file.path(result_dir, "13.4_neighborhoods_k80.qs"))

```

### 13.5 Milo Differential Expression (miloDE)

Calculate differential expression per neighborhood.

```{r eval=FALSE, include=TRUE}
#time-expensive --> use parallization
library(BiocParallel)
ncores = 16
mcparam <- SnowParam(workers = ncores, type = "SOCK")
register(mcparam)

stat_auc <- suppressWarnings(calc_AUC_per_neighbourhood(milo_k , sample_id = "sample" , condition_id = "condition", min_n_cells_per_sample = 1, BPPARAM = mcparam))
p <- plot_milo_by_single_metric(milo_k, stat_auc, colour_by = "auc" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "AUC")
p
print(last_plot()) # ggsave(file.path(result_dir, "13.5_miloDE_AUC.pdf"), p, width = 5, heigh = 5)
qsave(stat_auc, file.path(result_dir, "13.5_milo_k80_DE_stat_auc.qs"))

# miloDE is time and memory expensive --> run on hpc

#main part =
de_stat = de_test_neighbourhoods(milo_k,
                                 sample_id = "sample",
                                 design = ~condition,
                                 covariates = c("condition"),
                                 subset_nhoods = stat_auc$Nhood[!is.na(stat_auc$auc)],
                                 output_type = "SCE",
                                 plot_summary_stat = TRUE,
                                 layout = "UMAP",
                                 verbose = T)
qsave(de_stat, file.path(result_dir, "13.5_milo_de.qs"))
milo_DE <- qread("13.5_milo_de.qs")

```

### 13.6 Milo DE Genes Analysis

Analyze DE genes within neighborhoods, including specific DE genes.

```{r eval=FALSE, include=TRUE}
### Get neighbourhood ranking by the extent of DE ###
# transcriptional regions of noteworthy signs of DE
stat_de_magnitude <- rank_neighbourhoods_by_DE_magnitude(milo_DE)
write.xlsx(stat_de_magnitude, file = file.path(result_dir, "13.6_milo_DE_counts.xlsx"), rowNames = FALSE)

#n`n_DE_genes` - for each neighbourhood, we calculate how many genes are assigned as DE. Since we are doing it within each neighbourhood, we use `pval_corrected_across_genes`
p <- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = "n_DE_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# DE genes")
print(last_plot()) # ggsave(file.path(result_dir, "13.6_miloDE_all_corrected_across_genes.pdf"), p, width = 5, heigh = 5)
p <- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = "n_DE_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# DE genes", limits = c(0, 55))
print(last_plot()) # ggsave(file.path(result_dir, "13.6_miloDE_all_corrected_across_genes_max55.pdf"), p, width = 5, heigh = 5)
#n_specific_DE_genes` which neighbourhoods differ from others more so than we would expect. To assess this, we are interested in which neighbourhoods contain genes, that are DE 'specifically' in those neighbourhoods.
#To calculate this, for each gene we now use z-transformation of `pval_corrected_across_nhoods`
#This would tell us that the gene is signifciantly DE in the neighbourhood *compared to most other neighbourhoods*.
p <- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = "n_specific_DE_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# specific\nDE genes" , option = "inferno")
print(last_plot()) # ggsave(file.path(result_dir, "13.6_miloDE_specific_all_corrected_across_nhoods.pdf"), p, width = 5, heigh = 5)

p <- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = "n_specific_DE_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# specific\nDE genes" , option = "inferno", limits = c(0, 600))
print(last_plot()) # ggsave(file.path(result_dir, "13.6_miloDE_specific_all_corrected_across_nhoods_max600.pdf"), p, width = 5, heigh = 5)

### data frame of DE
#define parameter
logFC_matrix <- assay(milo_DE, "logFC")
pval_matrix <- assay(milo_DE, "pval")
pval_corrected_across_genes_matrix <- assay(milo_DE, "pval_corrected_across_genes")
pval_corrected_across_nhoods_matrix <- assay(milo_DE, "pval_corrected_across_nhoods")

#define data frame for each parameter
library(tidyr)
logFC_df <- as.data.frame(logFC_matrix) %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(
    cols = -gene,
    names_to = "neighborhood",
    values_to = "logFC"
  )

pval_df <- as.data.frame(pval_matrix) %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(
    cols = -gene,
    names_to = "neighborhood",
    values_to = "pval"
  )

pval_genes_df <- as.data.frame(pval_corrected_across_genes_matrix) %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(
    cols = -gene,
    names_to = "neighborhood",
    values_to = "pval_corrected_across_genes"
  )

pval_nhoods_df <- as.data.frame(pval_corrected_across_nhoods_matrix) %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(
    cols = -gene,
    names_to = "neighborhood",
    values_to = "pval_corrected_across_nhoods"
  )

#combine data frame
combined_df <- logFC_df %>%
  left_join(pval_df, by = c("gene", "neighborhood")) %>%
  left_join(pval_genes_df, by = c("gene", "neighborhood")) %>%
  left_join(pval_nhoods_df, by = c("gene", "neighborhood"))

#arrange and sort data frame
combined_df <- combined_df %>%
  arrange(neighborhood, gene)

#replace NAs with 1
combined_df <- combined_df %>%
  mutate(
    pval_corrected_across_genes = ifelse(is.na(pval_corrected_across_genes), 1, pval_corrected_across_genes),
    pval_corrected_across_nhoods = ifelse(is.na(pval_corrected_across_nhoods), 1, pval_corrected_across_nhoods)
  )

#calculate z values, similar as in the rank_neighbourhoods_by_DE_magnitude() function and add to dataframe
z_matrix <- combined_df %>%
  dplyr::select(gene, neighborhood, pval_corrected_across_nhoods) %>%
  pivot_wider(names_from = neighborhood, values_from = pval_corrected_across_nhoods) %>%
  column_to_rownames("gene") %>%
  as.matrix()

z_matrix <- t(apply(z_matrix, 1, function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)))

z_df <- as.data.frame(z_matrix) %>%
  rownames_to_column("gene") %>%
  pivot_longer(cols = -gene, names_to = "neighborhood", values_to = "z_score")

combined_df_z <- combined_df %>%
  left_join(z_df, by = c("gene", "neighborhood"))

#filtere data.frame for pval.thresh = 0.1, z.thresh = -3
pval_thresh <- 0.1
z_thresh <- -3

de_genes_df <- combined_df_z %>%
  filter(pval_corrected_across_genes < pval_thresh) %>%
  dplyr::select(gene, neighborhood, logFC, pval, pval_corrected_across_genes)
qsave(de_genes_df, file.path(result_dir, "13.6_milo_de_filtered_corrected_across_genes.qs"))

specific_de_genes_df <- combined_df_z %>%
  filter(z_score < z_thresh) %>%
  dplyr::select(gene, neighborhood, logFC, pval_corrected_across_nhoods, z_score)
qsave(specific_de_genes_df, file.path(result_dir, "13.6_milo_de_filtered_corrected_across_nhoods.qs"))

rm(combined_df, logFC_df, logFC_matrix, pval_corrected_across_genes_matrix, pval_corrected_across_nhoods_matrix, pval_df, pval_genes_df, pval_matrix, pval_nhoods_df, z_df, z_matrix, p, pval_thresh, z_thresh)
#save lists, each sheet = nhood, milo_de_corrected_across_genes
wb <- createWorkbook()
neighborhoods <- unique(de_genes_df$neighborhood)
for(nhood in neighborhoods){
  df_subset <- de_genes_df %>% filter(neighborhood == nhood)
  addWorksheet(wb, sheetName = nhood)
  writeData(wb, sheet = nhood, df_subset)
}
saveWorkbook(wb, file = "13.6_milo_DE_filtered_corrected_across_genes.xlsx", overwrite = TRUE)

#save lists, each sheet = nhood, milo_de_corrected_across_nhoods
wb2 <- createWorkbook()
neighborhoods2 <- unique(specific_de_genes_df$neighborhood)
for(nhood in neighborhoods2){
  df_subset <- specific_de_genes_df %>% filter(neighborhood == nhood)
  addWorksheet(wb2, sheetName = nhood)
  writeData(wb2, sheet = nhood, df_subset)
}
saveWorkbook(wb2, file = "13.6_milo_DE_specific_filtered_corrected_across_nhoods.xlsx", overwrite = TRUE)

rm(wb, wb2, df_subset, neighborhoods, neighborhoods2, nhood)

```

### 13.7 Upregulated Genes in MS

Identify and visualize genes upregulated in MS across neighborhoods.

```{r eval=FALSE, include=TRUE}
## DE_corrected_across_genes
de_genes_df_upregulated <- de_genes_df %>%
  filter(logFC > 0) %>%
  dplyr::select(gene, neighborhood, logFC, pval, pval_corrected_across_genes)
qsave(de_genes_df_upregulated, file.path(result_dir, "13.7_milo_de_upregulated_MS_corrected_across_genes.qs"))

n_upregulated_per_nhood <- de_genes_df_upregulated %>%
  group_by(neighborhood) %>%
  summarise(n_upregulated_genes = n()) %>%
  arrange(desc(n_upregulated_genes))

n_upregulated_per_nhood <- n_upregulated_per_nhood %>%
  rename(Nhood = neighborhood)

n_upregulated_per_nhood <- n_upregulated_per_nhood %>%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_upregulated_per_nhood, file = file.path(result_dir, "13.7_milo_DE_upregulated_MS_counts_corrected_across_genes.xlsx"), rowNames = FALSE)

p <- plot_milo_by_single_metric(milo_k, n_upregulated_per_nhood, colour_by = "n_upregulated_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# DE genes")
print(last_plot()) # ggsave(file.path(result_dir, "13.7_miloDE_upregulated_MS_corrected_across_genes.pdf"), p, width = 5, heigh = 5)

## DE_corrected_across_neighbourhoods
specific_de_genes_df_upregulated <- specific_de_genes_df %>%
  filter(logFC > 0) %>%
  dplyr::select(gene, neighborhood, logFC, pval_corrected_across_nhoods)
qsave(specific_de_genes_df_upregulated, file.path(result_dir, "13.7_milo_de_upregulated_MS_corrected_across_nhoods.qs"))

n_specific_upregulated_per_nhood <- specific_de_genes_df_upregulated %>%
  group_by(neighborhood) %>%
  summarise(n_upregulated_genes = n()) %>%
  arrange(desc(n_upregulated_genes))

n_specific_upregulated_per_nhood <- n_specific_upregulated_per_nhood %>%
  rename(Nhood = neighborhood)

n_specific_upregulated_per_nhood <- n_specific_upregulated_per_nhood %>%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_specific_upregulated_per_nhood , file = file.path(result_dir, "13.7_milo_DE_upregulated_MS_counts_corrected_across_nhoods.xlsx"), rowNames = FALSE)

p <- plot_milo_by_single_metric(milo_k, n_specific_upregulated_per_nhood, colour_by = "n_upregulated_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# specific DE genes")
print(last_plot()) # ggsave(file.path(result_dir, "13.7_miloDE_upregulated_MS_corrected_across_nhoods.pdf"), p, width = 5, heigh = 5)

p <- plot_milo_by_single_metric(milo_k, n_specific_upregulated_per_nhood, colour_by = "n_upregulated_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# specific DE genes", limits = c(0, 400))
print(last_plot()) # ggsave(file.path(result_dir, "13.7_miloDE_upregulated_MS_corrected_across_nhoods_max400.pdf"), p, width = 5, heigh = 5)

```

### 13.8 Downregulated Genes in MS

Identify and visualize genes downregulated in MS across neighborhoods.

```{r eval=FALSE, include=TRUE}
## DE_corrected_across_genes
de_genes_df_downregulated <- de_genes_df %>%
  filter(logFC < 0) %>%
  dplyr::select(gene, neighborhood, logFC, pval, pval_corrected_across_genes)
qsave(de_genes_df_downregulated, file.path(result_dir, "13.8_milo_de_downregulated_MS_corrected_across_genes.qs"))

n_downregulated_per_nhood <- de_genes_df_downregulated %>%
  group_by(neighborhood) %>%
  summarise(n_downregulated_genes = n()) %>%
  arrange(desc(n_downregulated_genes))

n_downregulated_per_nhood <- n_downregulated_per_nhood %>%
  rename(Nhood = neighborhood)

n_downregulated_per_nhood <- n_downregulated_per_nhood %>%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_downregulated_per_nhood, file = file.path(result_dir, "13.8_milo_DE_downregulated_MS_counts_corrected_across_genes.xlsx"), rowNames = FALSE)

p <- plot_milo_by_single_metric(milo_k, n_downregulated_per_nhood, colour_by = "n_downregulated_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# DE genes")
print(last_plot()) # ggsave(file.path(result_dir, "13.8_miloDE_downregulated_MS_corrected_across_genes.pdf"), p, width = 5, heigh = 5)

## DE_corrected_across_neighbourhoods
specific_de_genes_df_downregulated <- specific_de_genes_df %>%
  filter(logFC < 0) %>%
  dplyr::select(gene, neighborhood, logFC, pval_corrected_across_nhoods)
qsave(specific_de_genes_df_downregulated, file.path(result_dir, "13.8_milo_de_downregulated_corrected_across_nhoods.qs"))

n_specific_downregulated_per_nhood <- specific_de_genes_df_downregulated %>%
  group_by(neighborhood) %>%
  summarise(n_downregulated_genes = n()) %>%
  arrange(desc(n_downregulated_genes))

n_specific_downregulated_per_nhood <- n_specific_downregulated_per_nhood %>%
  rename(Nhood = neighborhood)

n_specific_downregulated_per_nhood <- n_specific_downregulated_per_nhood %>%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_specific_downregulated_per_nhood, file = file.path(result_dir, "13.8_milo_DE_downregulated_MS_counts_corrected_across_nhoods.xlsx"), rowNames = FALSE)

p <- plot_milo_by_single_metric(milo_k, n_specific_downregulated_per_nhood, colour_by = "n_downregulated_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# specific DE genes")
print(last_plot()) # ggsave(file.path(result_dir, "13.8_miloDE_downregulated_MS_corrected_across_nhoods.pdf"), p, width = 5, heigh = 5)

p <- plot_milo_by_single_metric(milo_k, n_specific_downregulated_per_nhood, colour_by = "n_downregulated_genes" ,
                                layout = "UMAP" , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = "# specific DE genes", limits = c(0, 300))
print(last_plot()) # ggsave(file.path(result_dir, "13.8_miloDE_downregulated_MS_corrected_across_nhoods_max300.pdf"), p, width = 5, heigh = 5)

```

### 13.9 Differential Abundance Testing

Perform the final differential abundance testing on the neighborhoods using the Negative Binomial GLM.

```{r eval=FALSE, include=TRUE}
milo_k <- qread("13.4_neighborhoods_k80.qs")
#calculate neighbourhood counts
milo_k <- buildNhoodGraph(milo_k)
colData(milo_k)$sample_condi <- paste(colData(milo_k)$sample, colData(milo_k)$condition, sep="_")
milo_k <- countCells(milo_k, meta.data = data.frame(colData(milo_k)), samples="sample_condi")
plotNhoodSizeHist(milo_k)

#create milo_design
milo_design <- data.frame(colData(milo_k))[,c("sample_condi", "sample", "condition")]
milo_design <- distinct(milo_design)
rownames(milo_design) <- milo_design$sample_condi
#Reorder rownames to match columns of nhoodCounts(milo)
milo_design <- milo_design[colnames(nhoodCounts(milo_k)), , drop=FALSE]

#DA analysis
test_condi <- c("conditionMS - conditionCtrl")
milo_DA <- testNhoods(milo_k, design = ~ 0 + condition, design.df = milo_design, model.contrasts = test_condi,
                      fdr.weighting="graph-overlap", norm.method="TMM")
write.xlsx(milo_DA, file = file.path(result_dir, "13.9_milo_DA.xlsx"), rowNames = FALSE)

p <- plotNhoodGraphDA(milo_k, milo_DA, alpha = 0.05)
print(last_plot()) # ggsave(file.path(result_dir, "13.9_milo_DA_FDR_0.05_sig.pdf"), p, width = 5, heigh = 5)

p <- plotNhoodGraphDA(milo_k, milo_DA, alpha = 1)
print(last_plot()) # ggsave(file.path(result_dir, "13.9_milo_DA_FDR_1_all.pdf"), p, width = 5, heigh = 5)

```

## 14. Myeloid Subset Analysis

Recluster and analyze myeloid cells to identify subpopulations and their differential expression.

### 14.0 Myeloid Subset and Reclustering

Subset myeloid clusters, remove fibroblast contamination, and re-integrate data.

```{r eval=FALSE, include=TRUE}
##### subset myeloid Cluster & SCT transform #####
myeloid_subset <- subset(samples_seurat, idents = c("CAM", "IFN-CAM", "Myeloid1", "Myeloid2", "Myeloid3", "Myeloid4", "Myeloid5", "Mast"))
myeloid_subset@assays$integrated <- NULL
myeloid_subset@assays$SCT <- NULL

# split by sample
DefaultAssay(myeloid_subset) <- "RNA"
myeloid_list <- SplitObject(myeloid_subset, split.by = "sample_id")

# SCTransform per sample
myeloid_list <- lapply(myeloid_list, function(x) {
  SCTransform(x, vst.flavor = "v2", verbose = TRUE)
})

###### re-integration and re-clustering ######
features <- SelectIntegrationFeatures(object.list = myeloid_list, nfeatures = 3000)
myeloid_list <- PrepSCTIntegration(myeloid_list, anchor.features = features)
#rpca because otherwise too big
anchors <- FindIntegrationAnchors(myeloid_list, normalization.method = "SCT",anchor.features = features, reduction = "rpca")
qsave(anchors, file.path(result_dir, "14.0_integration_anchors_myeloid_rpca.qs"))
#I ran it on the cluster
myeloid_combinedhttp://127.0.0.1:23813/graphics/plot_zoom_png?width=1751&height=884 <- IntegrateData(anchors, normalization.method = "SCT") |>
  RunPCA(verbose = T)
qsave(myeloid_combined, file.path(result_dir, "14.0_myeloid_combined_rpca.qs"))
myeloid_combined <- RunPCA(myeloid_combined, verbose = TRUE)
myeloid_combined <- RunUMAP(myeloid_combined, dims = 1:30)
myeloid_combined <- FindNeighbors(myeloid_combined, dims = 1:30)
qsave(myeloid_combined, file.path(result_dir, "14.0_myeloid_subset_integrated_before_clustering.qs"))

res_check <- FindClusters(myeloid_combined, resolution = c(0.05, 0.06, 0.07, 0.08, 0.09))
tree <- clustree(res_check)
print(last_plot()) # ggsave(file.path(result_dir, "14.0_myeloid_subset_reclustering_restree.pdf"), tree, width = 10, height = 5)

myeloid_seurat <- FindClusters(myeloid_combined, resolution = 0.07) #change resolution
myeloid_seurat <- RunUMAP(myeloid_seurat, dims = 1:30)
DimPlot(myeloid_seurat, label = T)
qsave(myeloid_seurat, file.path(result_dir, "14.0_myeloid_reclustered_res0.07.qs"))

p <- DimPlot(myeloid_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, "14.0_DimPlot_myeloid_reclustered_res0.07.pdf"), p, width = 6, height = 6)


p <- DimPlot(myeloid_seurat, label = T, split.by = "sample_id")
print(last_plot()) # ggsave(file.path(result_dir, "14.0_DimPlot_myeloid_reclustered_res0.07_by_patient.pdf"), p, width = 30, height = 6)


###### subset cluster with more than 1000 cells ######
#cluster 0     1     2     3     4     5     6     7     8
#cells 21789 14800  9758  1969  1011   845   549   127    80

Idents(myeloid_seurat) <- "seurat_clusters"
tab <- table(Idents(myeloid_seurat), myeloid_seurat$sample_id)
clusters_complete <- rownames(tab)[apply(tab > 0, 1, all)]

myeloid_main_seurat <- subset(myeloid_seurat, idents = clusters_complete)

Idents(myeloid_main_seurat) <- "seurat_clusters"
myeloid_main_seurat <- subset(myeloid_main_seurat, idents = c("0", "1", "3", "4", "5")) #remove Fibro contamination

```

### 14.1 Myeloid Marker Genes

Identify marker genes for myeloid subpopulations.

```{r eval=FALSE, include=TRUE}
Idents(myeloid_main_seurat) <- "seurat_clusters"
DefaultAssay(myeloid_main_seurat) <- "SCT"

myeloid_main_seurat <- PrepSCTFindMarkers(myeloid_main_seurat, assay = "SCT")
qsave(myeloid_main_seurat, file.path(result_dir, "14.1_myeloid_main_seurat_downstream_analysis.qs"))
markers <- FindAllMarkers(myeloid_main_seurat, assay = "SCT", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted <- markers %>%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list <- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = "14.1_myeloid_Cluster_Markers.xlsx")

rm(marker_list, markers, markers_sorted)

```

### 14.1.1 Plot Myeloid Marker Genes

Visualize top marker genes for myeloid subsets.

```{r eval=FALSE, include=TRUE}
Idents(myeloid_main_seurat) <- "seurat_clusters"
DefaultAssay(myeloid_main_seurat) <- "SCT"
genes<- read_csv("marker_genes_myeloid_top5.txt", col_names = FALSE)
# pdf("14.1.1_DotPlot_marker_genes_myeloid_top5.pdf", width = 12, heigh = 6)
DotPlot(myeloid_main_seurat, features = genes$X1)+
  scale_color_viridis_c()+RotatedAxis()
# dev.off()

#annotation
myeloid_main_seurat$annotated <- myeloid_main_seurat$seurat_clusters
myeloid_main_seurat$annotated <- recode(myeloid_main_seurat$annotated, "0" = "CAM", "1" = "inflamMono", "3" = "IFN-CAM", "4" = "granulo", "5" = "mast")

Idents(myeloid_main_seurat) <- "annotated"
p <- DimPlot(myeloid_main_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, "14.1.1_DimPlot_myeloid_main_annotated.pdf"), p, width = 6, height = 6)

p <- DimPlot(myeloid_main_seurat, label = T, split.by = "condition")
print(last_plot()) # ggsave(file.path(result_dir, "14.1.1_DimPlot_myeloid_main_annotated_Ms_vs_Ctrl.pdf"), p, width = 10, height = 6)

p <- DimPlot(myeloid_main_seurat, label = T, split.by = "sample_id")
print(last_plot()) # ggsave(file.path(result_dir, "14.1.1_DimPlot_myeloid_main_annotated_by_patient.pdf"), p, width = 30, height = 6)

#plotting marker genes
Idents(myeloid_main_seurat) <- "annotated"
cluster_order <- c("inflamMono", "CAM", "IFN-CAM", "granulo", "mast")
cluster_order <- rev(cluster_order)
myeloid_main_seurat@meta.data$annotated <- factor(myeloid_main_seurat@meta.data$annotated, levels = cluster_order)
Idents(myeloid_main_seurat) <- "annotated"
DefaultAssay(myeloid_main_seurat) <- "SCT"
genes<- read_csv("marker_genes_myeloid_top5.txt", col_names = FALSE)
dp <- DotPlot(myeloid_main_seurat, assay = "SCT", features = genes$X1)
dp$data <- subset(dp$data, pct.exp >10)
# pdf("14.1.1_DotPlot_marker_genes_myeloid_top5_perc10.pdf", width = 8, heigh = 3)
dp + scale_color_viridis_c() + RotatedAxis()
# dev.off()


```

### 14.3 Myeloid DE Analysis

Perform differential expression analysis for myeloid clusters.

```{r eval=FALSE, include=TRUE}
DefaultAssay(myeloid_main_seurat) <- "SCT"
Idents(myeloid_main_seurat) <- "seurat_clusters"
myeloid_main_seurat$annotated <- factor(myeloid_main_seurat$seurat_clusters)
Idents(myeloid_main_seurat) <- "annotated"

de_nested_list <- list()
comparisons <- list(
  c("MS", "Ctrl")
)

for (comp in comparisons) {
  ident_1 <- comp[1]
  ident_2 <- comp[2]
  comp_name <- paste0(ident_1, "_vs_", ident_2)

  message("Running comparison: ", comp_name)
  de_nested_list[[comp_name]] <- list()

  for (i in levels(myeloid_main_seurat$annotated)) {
    message("  Processing cluster: ", i)

    cells_in_cluster <- WhichCells(myeloid_main_seurat, idents = i)
    cluster_meta <- myeloid_main_seurat@meta.data[cells_in_cluster, ]

    group_counts <- table(cluster_meta$condition)

    cluster_name <- paste0("Cluster_", i)

    if (all(c(ident_1, ident_2) %in% names(group_counts)) &&
        all(group_counts[c(ident_1, ident_2)] >= 3)) {

      de <- tryCatch({
        FindMarkers(
          myeloid_main_seurat,
          ident.1 = ident_1,
          ident.2 = ident_2,
          subset.ident = i,
          group.by = "condition",
          recorrect_umi = FALSE
        )
      }, error = function(e) {
        message("    ERROR in cluster ", i, ": ", conditionMessage(e))
        return(NULL)
      })

      if (!is.null(de) && nrow(de) > 0) {
        de$gene <- rownames(de)
        de <- de[order(de$p_val_adj, -de$avg_log2FC), ]
        de_nested_list[[comp_name]][[cluster_name]] <- de
      } else {
        message("    No DE genes found for cluster ", i)
        de_nested_list[[comp_name]][[cluster_name]] <- data.frame(
          Note = "No DE genes found despite sufficient cells"
        )
      }

    } else {
      message("    Skipping cluster ", i, "  too few cells in one or both groups")
      de_nested_list[[comp_name]][[cluster_name]] <- data.frame(
        Note = paste("Too few cells in", ident_1, "or", ident_2)
      )
    }
  }
}

saveRDS(de_nested_list, "14.3_de_nested_list_myeloid_SCT_condition.rds")

# Save each comparison as its own Excel file
for (comp_name in names(de_nested_list)) {
  file_name <- paste0("14.3_DE_SCT_myeloid_", comp_name, ".xlsx")
  write.xlsx(de_nested_list[[comp_name]], file = file_name)
  message("Saved: ", file_name)
}

```

### 14.3.1 Volcano Plots for Myeloid DE

Visualize DE genes using volcano plots.

```{r eval=FALSE, include=TRUE}
de_file <- "14.3_DE_SCT_myeloid_MS_vs_Ctrl.xlsx"

all_clusters <- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message("Processing cluster: ", cluster)

  # Read cluster sheet
  de_data <- read.xlsx(de_file, sheet = cluster)

  # Check if de_data is empty
  if (nrow(de_data) == 0 || !"gene" %in% colnames(de_data)) {
    message(paste("Skipping cluster", cluster, "- no DE genes found"))
  } else {
    volcano_genes <- de_data

    #remove MT, RPL, RPS genes and Lnc
    volcano_genes <- volcano_genes %>% filter(!grepl("^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.", gene))
    #Define sig. up/down-reg genes
    volcano_genes$DE <- "NO"
    volcano_genes$DE[volcano_genes$avg_log2FC > 0.5 & volcano_genes$p_val_adj < 0.001] <- "Up"
    volcano_genes$DE[volcano_genes$avg_log2FC < -0.5 & volcano_genes$p_val_adj < 0.001] <- "Down"
    #sign. up & down
    volcano_genes$sig <- ifelse(volcano_genes$DE == "NO", "", volcano_genes$gene)
    sig <- volcano_genes$sig
    volcano_genes$sig <- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
    volcano_genes$DE <- factor(volcano_genes$DE, levels = c("Down", "NO", "Up"))
    volcano_genes$logP <- -log10(volcano_genes$p_val_adj)
    volcano_genes$logP <- pmin(volcano_genes$logP, 50)

    # Count up- and down-regulated genes
    n_up <- sum(volcano_genes$DE == "Up", na.rm = TRUE)
    n_down <- sum(volcano_genes$DE == "Down", na.rm = TRUE)

    # Filter only significant DE genes
    sig_genes <- volcano_genes %>%
      filter(DE != "NO")
    # Rank first by adjusted p-value, then by absolute log2FC
    top_genes <- sig_genes %>%
      arrange(p_val_adj, desc(abs(avg_log2FC))) %>%  # first p-value, then log2FC
      slice_head(n = 200) %>%                         # top 200 genes
      pull(gene)

    # Update sig column to label only top 200 genes
    volcano_genes$sig <- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

    p <- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
      geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
      geom_hline(yintercept = -log10(0.001), color = "gray40", linetype = "dashed") +
      geom_point(size = 3, alpha = 0.8) +
      scale_color_manual(values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
                         labels = c("Down", "ns", "Up")) +
      geom_text_repel(max.overlaps = 50, size = 3) +
      theme_classic(base_size = 14) +
      labs(
        x = "log Fold Change",
        y = expression(-log[10]("adjusted p-value")),
        color = "Regulation"
      ) +
      annotate("text", x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0("Up: ", n_up), hjust = 1, vjust = -0.5, color = "#3d70b5", size = 5) +
      annotate("text", x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0("Down: ", n_down), hjust = 0, vjust = -0.5, color = "black", size = 5)

    # Save per cluster
    out_file <- paste0("14.3.1_VolcanoPlot_DE_", cluster, "_DE.pdf")
    print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
  }
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)

```

### 14.3.2 GO Enrichment Analysis

Perform Gene Ontology enrichment analysis on DE genes.

```{r eval=FALSE, include=TRUE}
set.seed(42)
read_all_sheets <- function(path) {
  sheet_names <- excel_sheets(path)
  sheets <- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) <- sheet_names
  return(sheets)
}

DE_MS_vs_Ctrl <- read_all_sheets(file.path(result_dir, "14.3_DE_SCT_myeloid_MS_vs_Ctrl.xlsx"))

all_de_lists <- list(
  MS_vs_Ctrl = DE_MS_vs_Ctrl
)

# Clusters of interest
target_clusters <- as.character(myeloid_main_seurat@meta.data$seurat_clusters)
target_clusters <- unique(target_clusters)
# Function for enrichment and plotting
run_enrichment_and_plotting <- function(de_df, gene_list, direction, cluster, comparison) {
  if (length(gene_list) < 5) {
    message("Not enough genes for ", direction, "regulated ", cluster, " in ", comparison)
    return(NULL)
  }
  ego <- enrichGO(
    gene          = gene_list,
    OrgDb         = org.Hs.eg.db,
    keyType       = "SYMBOL",
    ont           = "ALL",
    pAdjustMethod = "BH",
    qvalueCutoff  = 0.05,
    readable      = TRUE
  )
  if (is.null(ego) || nrow(ego) == 0) {
    message("No enrichment results for ", direction, "regulated ", cluster, " in ", comparison)
    return(NULL)
  }
  # Save GO table
  file_base <- paste0("14.3.2_GO_DE_SCT_myeloid_", direction, "", cluster, "", comparison)
  write.xlsx(as.data.frame(ego), file = paste0(file_base, ".xlsx"))
  # Plots
#   pdf(paste0(file_base, ".pdf"), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste("Dotplot -", direction, "-", cluster, "-", comparison)))
    print("dotplot")
    print(barplot(ego) + ggtitle(paste("Dotplot -", direction, "-", cluster, "-", comparison)))
    print("barplot")
    sim <- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste("Enrichment Map -", direction, "-", cluster, "-", comparison)))
    print("emapplot")
    print(emapplot(sim, group = T) + ggtitle(paste("Cluster Map -", direction, "-", cluster, "-", comparison)))
    print("emapplot_cluster")
    de_df <- as.data.frame(de_df)
    rownames(de_df) <- de_df$gene
    fc_vector <- de_df[gene_list, "avg_log2FC"]
    names(fc_vector) <- gene_list
    print(cnetplot(ego, categorySize = "pvalue", foldChange = fc_vector) +
            ggtitle(paste("Cnetplot -", direction, "-", cluster, "-", comparison)))
    print("cnetplot")
  }, error = function(e) {
    message("Plotting failed for ", direction, "regulated ", cluster, " in ", comparison, ": ", e$message)
  })
#   dev.off()
}

#Main loop
for (comparison in names(all_de_lists)) {
  print(comparison)
  de_list <- all_de_lists[[comparison]]
  for (cluster in target_clusters) {
    print(cluster)
    cluster_name <- paste0("Cluster_", cluster)
    if (!cluster_name %in% names(de_list)) {
      message("Skipping ", cluster, " in ", comparison, "  not found.")
      next
    }
    de_df <- de_list[[cluster_name]]
    # Skip placeholder messages
    if (!"avg_log2FC" %in% colnames(de_df)) {
      message("Skipping ", cluster, " in ", comparison, "  not a valid DE result.")
      next
    }
    # UP-regulated
    gene_list_up <- de_df %>% filter(avg_log2FC > 0.5 & p_val_adj < 0.001) %>% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_up, "Up", cluster, comparison)
    # DOWN-regulated
    gene_list_down <- de_df %>% filter(avg_log2FC < -0.5 & p_val_adj < 0.001) %>% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_down, "Down", cluster, comparison)
  }
}

```

### 14.4 Myeloid Trajectory Analysis (All Clusters)

Analyze the developmental trajectory of all myeloid clusters.

#### 14.4.0 Pseudotime Calculation

Convert Seurat object to Monocle3 and calculate pseudotime.

```{r eval=FALSE, include=TRUE}
#convert Seurat object into Monocle object
#integrated and SCT (slot = "scale.data") do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don't use scale.data
#best is to use "RNA", "counts"

Idents(myeloid_main_seurat) <- "annotated"
data <- as(as.matrix(GetAssayData(myeloid_main_seurat, assay = "RNA", slot = "counts")), 'sparseMatrix') #normally on RNA
pd <- data.frame(myeloid_main_seurat@meta.data)
pData <- pd %>% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

myeloid_monocle <- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(myeloid_monocle)$gene_short_name <- rownames(fData(myeloid_monocle))
recreate.partitions <- c(rep(1, length(myeloid_monocle@colData@rownames)))
names(recreate.partitions) <- myeloid_monocle@colData@rownames
recreate.partitions <- as.factor(recreate.partitions)
recreate.partitions
myeloid_monocle@clusters@listData[["UMAP"]][["partitions"]] <- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster <- myeloid_main_seurat@active.ident
myeloid_monocle@clusters@listData[["UMAP"]][["clusters"]] <- list.cluster
myeloid_monocle@int_colData@listData[["reducedDims"]]@listData[["UMAP"]] <- myeloid_main_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors <- c("#f8766d", "#b79f00", "#00ba38", "#619cff", "#f564e3")
cluster.before.traj <- plot_cells(myeloid_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = "right") +  scale_color_manual(values = cluster_colors)

# pdf("14.4.0_myeloid_before_traj_plot.pdf", width = 4, height = 3)
cluster.before.traj
# dev.off()

#let it calculate trajectory
myeloid_monocle <- learn_graph(myeloid_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
myeloid_monocle <- learn_graph(myeloid_monocle, use_partition = F, verbose = T, close_loop = F, learn_graph_control=list(ncenter=100)) #changed ncenter to reduce branches

#plot trajectory into UMAP
# pdf("14.4.0_myeloid_traj_plot.pdf", width = 5, height = 4)
plot_cells(myeloid_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
myeloid_monocle <- order_cells(myeloid_monocle, reduction_method = "UMAP", root_cells = colnames(myeloid_monocle[, clusters(myeloid_monocle) == 5]))
#if this Error appears "Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds", leave root_cells = NULL to manually select starting point
myeloid_monocle <- order_cells(myeloid_monocle, reduction_method = "UMAP", root_cells = NULL)

# pdf("14.4.0_myeloid_traj_plot_UMAP_pseudotime.pdf", width = 5, height = 4)
plot_cells(myeloid_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
myeloid_monocle$monocle3_pseudotime <- pseudotime(myeloid_monocle)
data.pseudo <- as.data.frame(colData(myeloid_monocle))

# pdf("14.4.0_myeloid_traj_pseudotime.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab("")
# dev.off()
#or alternatively order by pseudotime
# pdf("14.4.0_myeloid_traj_pseudotime_order.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab("pseudotime") + ylab("")
# dev.off()

qsave(myeloid_monocle, "14.4.0_myeloid_monocle.qs")

```

#### 14.4.1 Genes Along Pseudotime

Identify genes changing along the myeloid trajectory.

```{r eval=FALSE, include=TRUE}
#find genes that change in pseudotime
deg <- graph_test(myeloid_monocle, neighbor_graph = "principal_graph", verbose = TRUE)
deg |> arrange(q_value, desc(morans_I)) |> filter(status == "OK") |> head()

#deg gene list can be looked at and saved
#Moran's value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, "14.4.1_myeloids_monocle_DEG.xlsx")

#one can also save pseudotime values into Seurat object and then plot for
myeloid_main_seurat$pseudotime <- pseudotime(myeloid_monocle)
# pdf("14.4.1_myeloid_FP_pseudotime.pdf", width = 4, height = 3)
FeaturePlot(myeloid_main_seurat, features = "pseudotime")
# dev.off()


```

#### 14.4.2 Plot Genes of Interest

Visualize expression of specific genes along pseudotime.

```{r eval=FALSE, include=TRUE}
#one can do multiple expression plots with certain identified genes
# pdf("14.4.2_myeloid_pseudotime_RP_genes_of_ineterest.pdf", width = 8, height = 9)
RidgePlot(myeloid_main_seurat, features = c("CD209", "LYVE1", "MRC1", "CD163", "F13A1", "VSIG4", "SELENOP", "C1QA", "C1QB", "IFIT2", "IFI44L" , "IFI44", "IFIH1"), sort = F, cols = cluster_colors)
# dev.off()


my_genes <- c("CD209", "LYVE1", "MRC1", "CD163", "F13A1", "VSIG4", "SELENOP", "C1QA", "C1QB", "IFIT2", "IFI44L" , "IFI44", "IFIH1") #CAM + IFI
myeloid_monocle_subset <- myeloid_monocle[my_genes,]
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = "monocle3_pseudotime" )
#or
# pdf("14.4.2_myeloid_genes_of_interest_traj_pseudocolor.pdf", width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = "monocle3_pseudotime" )
# dev.off()

# pdf("14.4.2_myeloid_genes_of_ineterest_traj_annotated.pdf", width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = "annotated" )
# dev.off()

```

#### 14.4.3 Top Changing Genes in Pseudotime

Visualize the top 5 most significant genes per cluster along pseudotime.

```{r eval=FALSE, include=TRUE}
#plot top5 genes that change over pseudotime in each cluster
deg_sig <- deg %>% filter(q_value < 0.05, status == "OK")

deg_sig$cluster <- myeloid_monocle$annotated[ match(deg_sig$gene_short_name,
                                                    rownames(myeloid_monocle)) ]

top5_per_cluster <- deg_sig %>%
  group_by(cluster) %>%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot <- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf("14.4.3_myeloid_top_genes_pseudotime.pdf", width = 5, height = 25)

plot_genes_in_pseudotime(
  myeloid_monocle[genes_to_plot, ],
  color_cells_by = "annotated",
  min_expr = 0.1
)

# dev.off()


```

### 14.5 Myeloid Trajectory Analysis (Focused Subset)

Analyze trajectory for specific myeloid clusters (1, 0, 3) excluding granulocytes and mast cells.

#### 14.5.0 Pseudotime Calculation (Subset)

Convert subset Seurat object to Monocle3 and calculate pseudotime.

```{r eval=FALSE, include=TRUE}
#convert Seurat object into Monocle object
#integrated and SCT (slot = "scale.data") do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don't use scale.data
#best is to use "RNA", "counts"

#exclude granulo and mast cells because they are not in traj
myeloid_main_seurat <- subset(myeloid_main_seurat, idents = c("1", "0", "3"))

Idents(myeloid_main_seurat) <- "annotated"
data <- as(as.matrix(GetAssayData(myeloid_main_seurat, assay = "RNA", slot = "counts")), 'sparseMatrix') #normally on RNA
pd <- data.frame(myeloid_main_seurat@meta.data)
pData <- pd %>% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

myeloid_monocle <- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(myeloid_monocle)$gene_short_name <- rownames(fData(myeloid_monocle))
recreate.partitions <- c(rep(1, length(myeloid_monocle@colData@rownames)))
names(recreate.partitions) <- myeloid_monocle@colData@rownames
recreate.partitions <- as.factor(recreate.partitions)
recreate.partitions
myeloid_monocle@clusters@listData[["UMAP"]][["partitions"]] <- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster <- myeloid_main_seurat@active.ident
myeloid_monocle@clusters@listData[["UMAP"]][["clusters"]] <- list.cluster
myeloid_monocle@int_colData@listData[["reducedDims"]]@listData[["UMAP"]] <- myeloid_main_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors <- c("#f8766d", "#b79f00", "#34b6b8")
cluster.before.traj <- plot_cells(myeloid_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = "right") +  scale_color_manual(values = cluster_colors)

# pdf("14.5.0_myeloid_before_traj_plot.pdf", width = 4, height = 3)
cluster.before.traj
# dev.off()

#let it calculate trajectory
myeloid_monocle <- learn_graph(myeloid_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
myeloid_monocle <- learn_graph(myeloid_monocle, use_partition = F, verbose = T, close_loop = F, learn_graph_control=list(ncenter=100)) #changed ncenter to reduce branches

#plot trajectory into UMAP
# pdf("14.5.0_myeloid_traj_plot.pdf", width = 5, height = 4)
plot_cells(myeloid_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
myeloid_monocle <- order_cells(myeloid_monocle, reduction_method = "UMAP", root_cells = colnames(myeloid_monocle[, clusters(myeloid_monocle) == 5]))
#if this Error appears "Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds", leave root_cells = NULL to manually select starting point
myeloid_monocle <- order_cells(myeloid_monocle, reduction_method = "UMAP", root_cells = NULL)

# pdf("14.5.0_myeloid_traj_plot_UMAP_pseudotime.pdf", width = 5, height = 4)
plot_cells(myeloid_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
myeloid_monocle$monocle3_pseudotime <- pseudotime(myeloid_monocle)
data.pseudo <- as.data.frame(colData(myeloid_monocle))

# pdf("14.5.0_myeloid_traj_pseudotime.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab("")
# dev.off()
#or alternatively order by pseudotime
# pdf("14.5.0_myeloid_traj_pseudotime_order.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab("pseudotime") + ylab("")
# dev.off()

qsave(myeloid_monocle, "14.5.0_myeloid_monocle_focusMono.qs")

```

#### 14.5.1 Genes Along Pseudotime (Subset)

Identify genes changing along the focused myeloid trajectory.

```{r eval=FALSE, include=TRUE}
#find genes that change in pseudotime
deg <- graph_test(myeloid_monocle, neighbor_graph = "principal_graph", verbose = TRUE)
deg |> arrange(q_value, desc(morans_I)) |> filter(status == "OK") |> head()

#deg gene list can be looked at and saved
#Moran's value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, "14.5.1_myeloids_monocle_DEG.xlsx")

#one can also save pseudotime values into Seurat object and then plot for
myeloid_main_seurat$pseudotime <- pseudotime(myeloid_monocle)
# pdf("14.5.1_myeloid_FP_pseudotime.pdf", width = 4, height = 3)
FeaturePlot(myeloid_main_seurat, features = "pseudotime")
# dev.off()


```

#### 14.5.2 Plot Genes of Interest (Subset)

Visualize expression of specific genes along the focused pseudotime.

```{r eval=FALSE, include=TRUE}
#one can do multiple expression plots with certain identified genes
# pdf("14.5.2_myeloid_pseudotime_RP_genes_of_ineterest.pdf", width = 8, height = 9)
RidgePlot(myeloid_main_seurat, features = c("CD209", "LYVE1", "MRC1", "CD163", "F13A1", "VSIG4", "SELENOP", "C1QA", "C1QB", "IFIT2", "IFI44L" , "IFI44", "IFIH1"), sort = F, cols = cluster_colors)
# dev.off()


my_genes <- c("CD209", "LYVE1", "MRC1", "CD163", "F13A1", "VSIG4", "SELENOP", "C1QA", "C1QB", "IFIT2", "IFI44L" , "IFI44", "IFIH1") #CAM + IFI
myeloid_monocle_subset <- myeloid_monocle[my_genes,]
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = "monocle3_pseudotime" )
#or
# pdf("14.5.2_myeloid_genes_of_interest_traj_pseudocolor.pdf", width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = "monocle3_pseudotime" )
# dev.off()

# pdf("14.5.2_myeloid_genes_of_ineterest_traj_annotated.pdf", width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = "annotated" ) + scale_color_manual(values = cluster_colors)
# dev.off()

```

#### 14.5.3 Top Changing Genes (Subset)

Visualize the top 5 most significant genes per cluster along the focused pseudotime.

```{r eval=FALSE, include=TRUE}
#plot top5 genes that change over pseudotime in each cluster
deg_sig <- deg %>% filter(q_value < 0.05, status == "OK")

deg_sig$cluster <- myeloid_monocle$annotated[ match(deg_sig$gene_short_name,
                                                    rownames(myeloid_monocle)) ]

top5_per_cluster <- deg_sig %>%
  group_by(cluster) %>%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot <- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf("14.5.3_myeloid_top_genes_pseudotime.pdf", width = 5, height = 15)

plot_genes_in_pseudotime(
  myeloid_monocle[genes_to_plot, ],
  color_cells_by = "annotated",
  min_expr = 0.1
) + scale_color_manual(values = cluster_colors)

# dev.off()


```

#### 14.4.4 Condition-Dependent Expression

Identify genes whose expression changes along pseudotime differ between conditions.

```{r eval=FALSE, include=TRUE}
#find genes that vary across condition
gene_fits <- fit_models(myeloid_monocle, model_formula_str = "~condition")
gene_fits_tbl <- coefficient_table(gene_fits)
write.xlsx(gene_fits_tbl, "14.5.4_myeloids_pseudotime_condition.xlsx")

# Keep only the condition coefficients
deg_cond <- gene_fits_tbl %>%
  filter(term != "(Intercept)")

# Significant genes
sig_genes <- deg_cond %>%
  filter(q_value < 0.05)

# Rank for labeling: first q-value, then |estimate|
top_genes <- sig_genes %>%
  arrange(q_value, desc(abs(estimate))) %>%
  slice_head(n = 50) %>%
  pull(gene_short_name)

deg_volcano <- deg_cond %>%
  mutate(
    logFC = estimate,
    negLogQ = -log10(q_value),
    DE = case_when(
      estimate > 0.5  & q_value < 0.05 ~ "Up",
      estimate < -0.5 & q_value < 0.05 ~ "Down",
      TRUE                              ~ "NO"
    ),
    logP = pmin(negLogQ, 50),      # cap values for nicer plot
    label_it = ifelse(gene_short_name %in% top_genes, gene_short_name, NA)
  )


deg_volcano$label_italic <- ifelse(
  is.na(deg_volcano$label_it),
  NA,
  paste0("italic('", deg_volcano$label_it, "')")
)

p <- ggplot(deg_volcano, aes(x = logFC, y = logP, color = DE)) +
  geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "gray40", linetype = "dashed") +
  geom_point(size = 3, alpha = 0.8) +

  scale_color_manual(
    values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
    labels = c("Down", "ns", "Up")
  ) +

  ggrepel::geom_text_repel(
    aes(label = label_italic),
    parse = TRUE,
    max.overlaps = 50,
    size = 3
  ) +

  theme_classic(base_size = 14) +
  labs(
    title = "Condition-dependent DEGs along trajectory",
    x = "log Fold Change",
    y = expression(-log[10]("adjusted p-value")),
    color = "Regulation"
  )

print(last_plot()) # ggsave(file.path(result_dir, "14.5.4_myeloid_pseudotime_VolcanoPlot_DE_MS_vs_ctrl.pdf"), p , width = 10, height = 7)

#plot genes over pseudotime
top_genes <- top_sig$gene_short_name

p <- plot_genes_in_pseudotime(
  myeloid_monocle[top_genes, ],
  color_cells_by = "condition"
)

print(last_plot()) # ggsave(file.path(result_dir, "14.5.4_myeloid_pseudotime_along_traj_Plot_DE_MS_vs_ctrl.pdf"), p , width = 5, height = 25)

```

### 14.6 Cluster Abundance Analysis (Confounder Adjusted)

Analyze changes in myeloid cluster abundance while adjusting for confounding variables.

#### 14.6.1 Data Preparation (Confounders)

Prepare metadata and count matrices for abundance analysis.

```{r eval=FALSE, include=TRUE}
# Extract metadata and ensure all required variables are present
meta_confounders <- myeloid_main_seurat@meta.data %>%
  dplyr::select(sample_id, condition, cohort, pool, annotated, age, sex) %>%
  # Remove rows with missing confounder data
  filter(!is.na(age) & !is.na(sex)) %>%
  # Ensure sex is a factor
  mutate(sex = as.factor(sex),
         condition     = as.factor(condition),
         cohort = as.factor(cohort),
         pool = as.factor(pool),
         age = as.numeric(age))

# Create count matrix: samples x cell types
library(tidyr)
count_matrix <- meta_confounders %>%
  group_by(sample_id, annotated) %>%
  summarise(count = n(), .groups = "drop") %>%
  pivot_wider(names_from = annotated, values_from = count, values_fill = 0) %>%
  column_to_rownames("sample_id") %>%
  as.matrix()

# Create sample metadata
sample_meta <- meta_confounders %>%
  dplyr::select(sample_id, condition, cohort, pool, sex) %>% #age
  distinct()
rownames(sample_meta) <- sample_meta$sample_id

# Ensure same sample order
sample_meta <- sample_meta[rownames(count_matrix), ]

```

#### 14.6.2 Confounder-Adjusted Differential Abundance

Run `propeller` analysis to identify differentially abundant myeloid cell types between MS and Ctrl.

```{r eval=FALSE, include=TRUE}
run_propeller_with_confounders <- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list <- list()

#   pdf(output_file, width = 8, height = 6)

  for (pair in comparisons) {
    group1 <- pair[1]
    group2 <- pair[2]

    cat(paste("  Analyzing:", group1, "vs", group2, "with confounders\n"))

    # Filter to comparison groups
    keep_samples              <- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              <- count_data[keep_samples, , drop = FALSE]
    meta_subset               <- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  <- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str <- paste("~", group_var, "+", paste(confounders, collapse = " + "))
    design_formula <- as.formula(formula_str)
    # design_matrix <- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props <- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit <- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results <- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str <- paste(confounders, collapse = " + ")

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model <- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula <- as.formula(paste("celltype ~", group_var, "+", confounder_str))

        # Fit linear model
        fit <- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name <- paste0(group_var, group1)
        coef_names <- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val <- coef(fit)[coef_name]
          p_val    <- summary(fit)$coefficients[coef_name, "Pr(>|t|)"]

          results[results$CellType == celltype, "logFC"] <- coef_val
          results[results$CellType == celltype, "P.Value"] <- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, "logFC"] <- NA
          results[results$CellType == celltype, "P.Value"] <- NA
        }
      }

      results$P.Value.Adj <- p.adjust(results$P.Value, method = "BH")
      results$comparison  <- paste(group1, "vs", group2, sep = "_")

      # Store results in list
      results_list[[paste(group1, "vs", group2)]] <- results

      # Prepare volcano plot dataframe
      volcano_df <- results %>%
        mutate(
          log2_ratio = logFC,
          p.adj = P.Value.Adj,
          neg_log10_p = -log10(p.adj),
          var = CellType
        ) %>%
        dplyr::select(var, log2_ratio, p.adj, neg_log10_p)

      # Volcano plot function
      VolPlot <- function(data) {
        data |>
          ggplot(aes(x = log2_ratio, y = neg_log10_p, color = var, label = var)) +
          geom_point(size = 3) +
          geom_hline(yintercept = -log10(0.05), color = "grey", linetype = "dashed") +
          geom_vline(xintercept = 0, color = "grey", linetype = "dashed") +
          ggtitle(paste("Confounder-adjusted: sex + cohort + pool", group1, "vs", group2)) +
          scale_color_manual(values = cluster_colors) +
          ggrepel::geom_text_repel() +
          theme_classic() +
          theme(legend.position = "none") +
          xlab(bquote(~ Log[2] ~ "fold change")) +
          ylab(bquote(~ -Log[10] ~ "adjusted p value"))
      }

      # Print volcano plot
      p <- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste("Error in analysis for", group1, "vs", group2, ":", e$message, "\n"))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons <- list(
  c("MS", "Ctrl")
)

results_confounders_pms <- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %>% dplyr::select(-sample_id),
  group_var   = "condition",
  confounders = c("sex", "cohort", "pool"), #age
  comparisons = comparisons,
  output_file = file.path("14.6.2_confounder_adjusted_propeller.pdf")
)

```

#### 14.6.3 Confounder-Adjusted Log2 Fold Changes

Calculate and visualize log2 fold changes for myeloid clusters, adjusting for confounders.

```{r eval=FALSE, include=TRUE}
run_propeller_with_confounders <- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list <- list()

#   pdf(output_file, width = 3, height = 3)

  for (pair in comparisons) {
    group1 <- pair[1]
    group2 <- pair[2]

    cat(paste("  Analyzing:", group1, "vs", group2, "with confounders\n"))

    # Filter to comparison groups
    keep_samples              <- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              <- count_data[keep_samples, , drop = FALSE]
    meta_subset               <- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  <- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str <- paste("~", group_var, "+", paste(confounders, collapse = " + "))
    design_formula <- as.formula(formula_str)
    # design_matrix <- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props <- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit <- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results <- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str <- paste(confounders, collapse = " + ")

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model <- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula <- as.formula(paste("celltype ~", group_var, "+", confounder_str))

        # Fit linear model
        fit <- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name <- paste0(group_var, group1)
        coef_names <- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val <- coef(fit)[coef_name]
          p_val    <- summary(fit)$coefficients[coef_name, "Pr(>|t|)"]

          results[results$CellType == celltype, "logFC"] <- coef_val
          results[results$CellType == celltype, "P.Value"] <- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, "logFC"] <- NA
          results[results$CellType == celltype, "P.Value"] <- NA
        }
      }

      results$P.Value.Adj <- p.adjust(results$P.Value, method = "BH")
      results$comparison  <- paste(group1, "vs", group2, sep = "_")

      # Store results in list
      results_list[[paste(group1, "vs", group2)]] <- results

      # Prepare volcano plot dataframe
      volcano_df <- results %>%
        mutate(
          log2_ratio = logFC,
          cluster = CellType
        ) %>%
        arrange(log2_ratio) %>%
        mutate(cluster = factor(cluster, levels = cluster))

      # Volcano plot function
      VolPlot <- function(data) {
        ggplot(data, aes(x = log2_ratio, y = cluster, color = cluster)) +
          geom_point(size = 3) +
          geom_vline(xintercept = 0, color = "grey", linetype = "dashed") +
          ggtitle(paste(group1, "vs", group2, "(confounder adjusted)")) +
          theme_classic() +
          theme(legend.position = "none") +
          xlab(bquote(~ Log[2] ~ "fold change")) +
          ylab("Cluster") +
          scale_color_manual(values = cluster_colors)
      }

      # Print volcano plot
      p <- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste("Error in analysis for", group1, "vs", group2, ":", e$message, "\n"))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons <- list(
  c("MS", "Ctrl")
)

results_confounders_pms <- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %>% dplyr::select(-sample_id),
  group_var   = "condition",
  confounders = c("sex", "cohort", "pool"), #age
  comparisons = comparisons,
  output_file = file.path("14.6.3_confounder_adjusted_propeller_LogFC_all.pdf")
)

```

## 15. Fibroblast Subset Analysis

Recluster and analyze fibroblast cells to identify subpopulations and their differential expression.

### 15.0 Fibroblast Subset and Reclustering

Subset fibroblast clusters, re-integrate data, and perform clustering.

```{r eval=FALSE, include=TRUE}
##### subset Fibro Cluster & SCT transform #####
Idents(samples_seurat) <- "annotated"
Fibro_subset <- subset(samples_seurat, idents = c("duraFibro1", "duraFibro2", "duraFibro3", "duraFibro4", "duraFibro5", "duraFibro6", "duraFibro7", "duraFibro8", "ABC", "arach_bordFibro"))
Fibro_subset@assays$integrated <- NULL
Fibro_subset@assays$SCT <- NULL

# split by sample
DefaultAssay(Fibro_subset) <- "RNA"
Fibro_list <- SplitObject(Fibro_subset, split.by = "sample_id")

# SCTransform per sample
Fibro_list <- lapply(Fibro_list, function(x) {
  SCTransform(x, vst.flavor = "v2", verbose = TRUE)
})

###### re-integration and re-clustering ######
features <- SelectIntegrationFeatures(object.list = Fibro_list, nfeatures = 3000)
Fibro_list <- PrepSCTIntegration(Fibro_list, anchor.features = features)
#rpca because otherwise too big
anchors <- FindIntegrationAnchors(Fibro_list, normalization.method = "SCT",anchor.features = features, reduction = "rpca")
qsave(anchors, file.path(result_dir, "15.0_integration_anchors_Fibro_rpca.qs"))
#ran it on the hpc
Fibro_combined <- IntegrateData(anchors, normalization.method = "SCT") |>
  RunPCA(verbose = T)
qsave(Fibro_combined, file.path(result_dir, "15.0_Fibro_combined_rpca.qs"))
Fibro_combined <- RunPCA(Fibro_combined, verbose = TRUE)
Fibro_combined <- RunUMAP(Fibro_combined, dims = 1:30)
Fibro_combined <- FindNeighbors(Fibro_combined, dims = 1:30)
qsave(Fibro_combined, file.path(result_dir, "15.0_Fibro_subset_integrated_before_clustering.qs"))

Fibro_combined@meta.data$integrated_snn_res.0.7 <- NULL
res_check <- FindClusters(Fibro_combined, resolution = c(0.01, 0.02, 0.03, 0.035, 0.04))
tree <- clustree(res_check)
print(last_plot()) # ggsave(file.path(result_dir, "15.0_Fibro_subset_reclustering_restree.pdf"), tree, width = 10, height = 5)

Fibro_seurat <- FindClusters(Fibro_combined, resolution = 0.15) #change resolution
Fibro_seurat <- RunUMAP(Fibro_seurat, dims = 1:30)
DimPlot(Fibro_seurat, label = T)
qsave(Fibro_seurat, file.path(result_dir, "15.0_Fibro_reclustered_res0.15.qs"))

p <- DimPlot(Fibro_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, "15.0_DimPlot_Fibro_reclustered_res0.15.pdf"), p, width = 6, height = 6)

p <- DimPlot(Fibro_seurat, label = T, split.by = "sample_id")
print(last_plot()) # ggsave(file.path(result_dir, "15.0_DimPlot_Fibro_reclustered_res0.15_by_patient.pdf"), p, width = 34, height = 6)

###### subset cluster with more than 1000 cells ######
table(Fibro_seurat$seurat_clusters)
#cluster 0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15
#cells 28116 12604 11860 11053 10001  9594  5375  4969  2217  1245   442   342   195   179   178   119

Idents(Fibro_seurat) <- "seurat_clusters"
tab <- table(Idents(Fibro_seurat), Fibro_seurat$sample_id)
clusters_complete <- rownames(tab)[apply(tab > 0, 1, all)]

Fibro_main_seurat <- subset(Fibro_seurat, idents = clusters_complete)

p <- DimPlot(Fibro_main_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, "15.0_DimPlot_Fibro_main_res0.15_removedClusters.pdf"), p, width = 6, height = 6)

p <- DimPlot(Fibro_main_seurat, label = T, split.by = "sample_id")
print(last_plot()) # ggsave(file.path(result_dir, "15.0_DimPlot_Fibro_main_res0.15_removedClusters_by_patient.pdf"), p, width = 30, height = 6)

```

### 15.1 Fibroblast Marker Genes

Identify marker genes for fibroblast subpopulations.

```{r eval=FALSE, include=TRUE}
Idents(Fibro_main_seurat) <- "seurat_clusters"
Fibro_main_seurat <- PrepSCTFindMarkers(Fibro_main_seurat)
qsave(Fibro_main_seurat, file.path(result_dir, "15.1_Fibro_main_seurat_res0.15_downstream_analysis.qs"))
markers <- FindAllMarkers(Fibro_main_seurat, assay = "SCT", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted <- markers %>%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list <- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = "15.1_Cluster_Markers_Fibro.xlsx")

```

### 15.2 GO Enrichment on Fibroblast Markers

Perform Gene Ontology enrichment analysis on the identified marker genes.

```{r eval=FALSE, include=TRUE}
set.seed(42)
# Function to read all sheets from an Excel file
read_all_sheets <- function(path) {
  sheet_names <- excel_sheets(path)
  sheets <- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) <- sheet_names
  return(sheets)
}

# Load marker genes
marker_genes <- read_all_sheets(file.path(result_dir, "15.1_Cluster_Markers_Fibro.xlsx"))

# Function to run GO enrichment and plotting for a single cluster
run_enrichment_markers <- function(marker_genes_list, cluster_name) {

  # Extract gene column
  if (!"gene" %in% colnames(marker_genes_list[[cluster_name]])) {
    message("Cluster ", cluster_name, " does not have a 'gene' column. Skipping.")
    return(NULL)
  }

  gene_list <- as.character(marker_genes_list[[cluster_name]]$gene)

  # Skip small lists
  if (length(gene_list) < 5) {
    message("Not enough genes for cluster ", cluster_name, " (", length(gene_list), " genes). Skipping.")
    return(NULL)
  }

  # Run GO enrichment (Biological Process)
  ego <- enrichGO(
    gene = gene_list,
    OrgDb = org.Hs.eg.db,
    keyType = "SYMBOL",
    ont = "BP",
    pAdjustMethod = "BH",
    qvalueCutoff = 0.05,
    readable = TRUE
  )

  if (is.null(ego) || nrow(ego) == 0) {
    message("No enrichment results for cluster ", cluster_name)
    return(NULL)
  }

  # Save GO table
  write.xlsx(as.data.frame(ego), file = paste0("15.2_GO_Fibro_Subset_", cluster_name, "_markers.xlsx"))

  # Plotting
#   pdf(paste0("15.2_GO_Fibro_Subset_", cluster_name, "_markers.pdf"), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste("Dotplot -", cluster_name)))
    print(barplot(ego) + ggtitle(paste("Barplot -", cluster_name)))
    sim <- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste("Enrichment Map -", cluster_name)))
    print(emapplot(sim, group = T) + ggtitle(paste("Cluster Map -", cluster_name)))
  }, error = function(e) {
    message("Plotting failed for cluster ", cluster_name, ": ", e$message)
  })
#   dev.off()

  return(ego)
}

# Loop over all clusters
results_enrichment <- list()
for (cluster in names(marker_genes)) {
  message("Running enrichment for cluster: ", cluster)
  ego <- run_enrichment_markers(marker_genes, cluster)
  if (!is.null(ego)) {
    results_enrichment[[cluster]] <- ego
  }
}

```

### 15.3 Fibroblast DE Analysis

Perform differential expression analysis for fibroblast clusters between conditions.

```{r eval=FALSE, include=TRUE}
DefaultAssay(Fibro_main_seurat) <- "SCT"
Idents(Fibro_main_seurat) <- "seurat_clusters"
Fibro_main_seurat$annotated <- factor(Fibro_main_seurat$seurat_clusters)
Idents(Fibro_main_seurat) <- "annotated"

de_nested_list <- list()
comparisons <- list(
  c("MS", "Ctrl")
)

for (comp in comparisons) {
  ident_1 <- comp[1]
  ident_2 <- comp[2]
  comp_name <- paste0(ident_1, "_vs_", ident_2)

  message("Running comparison: ", comp_name)
  de_nested_list[[comp_name]] <- list()

  for (i in levels(Fibro_main_seurat$annotated)) {
    message("  Processing cluster: ", i)

    cells_in_cluster <- WhichCells(Fibro_main_seurat, idents = i)
    cluster_meta <- Fibro_main_seurat@meta.data[cells_in_cluster, ]

    group_counts <- table(cluster_meta$condition)

    cluster_name <- paste0("Cluster_", i)

    if (all(c(ident_1, ident_2) %in% names(group_counts)) &&
        all(group_counts[c(ident_1, ident_2)] >= 3)) {

      de <- tryCatch({
        FindMarkers(
          Fibro_main_seurat,
          ident.1 = ident_1,
          ident.2 = ident_2,
          subset.ident = i,
          group.by = "condition",
          recorrect_umi = FALSE
        )
      }, error = function(e) {
        message("    ERROR in cluster ", i, ": ", conditionMessage(e))
        return(NULL)
      })

      if (!is.null(de) && nrow(de) > 0) {
        de$gene <- rownames(de)
        de <- de[order(de$p_val_adj, -de$avg_log2FC), ]
        de_nested_list[[comp_name]][[cluster_name]] <- de
      } else {
        message("    No DE genes found for cluster ", i)
        de_nested_list[[comp_name]][[cluster_name]] <- data.frame(
          Note = "No DE genes found despite sufficient cells"
        )
      }

    } else {
      message("    Skipping cluster ", i, "  too few cells in one or both groups")
      de_nested_list[[comp_name]][[cluster_name]] <- data.frame(
        Note = paste("Too few cells in", ident_1, "or", ident_2)
      )
    }
  }
}

saveRDS(de_nested_list, "15.3_de_nested_list_Fibro_SCT_condition.rds")

# Save each comparison as its own Excel file
for (comp_name in names(de_nested_list)) {
  file_name <- paste0("15.3_DE_SCT_Fibro_", comp_name, ".xlsx")
  write.xlsx(de_nested_list[[comp_name]], file = file_name)
  message("Saved: ", file_name)
}

```

### 15.4 Volcano Plots for Fibroblast DE

Visualize fibroblast DE genes using volcano plots.

```{r eval=FALSE, include=TRUE}
de_file <- "15.3_DE_SCT_Fibro_MS_vs_Ctrl.xlsx"

all_clusters <- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message("Processing cluster: ", cluster)

  # Read cluster sheet
  de_data <- read.xlsx(de_file, sheet = cluster)

  # Check if de_data is empty
  if (nrow(de_data) == 0 || !"gene" %in% colnames(de_data)) {
    message(paste("Skipping cluster", cluster, "- no DE genes found"))
  } else {
    volcano_genes <- de_data

    #remove MT, RPL, RPS genes and Lnc
    volcano_genes <- volcano_genes %>% filter(!grepl("^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.", gene))
    #Define sig. up/down-reg genes
    volcano_genes$DE <- "NO"
    volcano_genes$DE[volcano_genes$avg_log2FC > 0.5 & volcano_genes$p_val_adj < 0.001] <- "Up"
    volcano_genes$DE[volcano_genes$avg_log2FC < -0.5 & volcano_genes$p_val_adj < 0.001] <- "Down"
    #sign. up & down
    volcano_genes$sig <- ifelse(volcano_genes$DE == "NO", "", volcano_genes$gene)
    sig <- volcano_genes$sig
    volcano_genes$sig <- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
    volcano_genes$DE <- factor(volcano_genes$DE, levels = c("Down", "NO", "Up"))
    volcano_genes$logP <- -log10(volcano_genes$p_val_adj)
    volcano_genes$logP <- pmin(volcano_genes$logP, 50)

    # Count up- and down-regulated genes
    n_up <- sum(volcano_genes$DE == "Up", na.rm = TRUE)
    n_down <- sum(volcano_genes$DE == "Down", na.rm = TRUE)

    # Filter only significant DE genes
    sig_genes <- volcano_genes %>%
      filter(DE != "NO")
    # Rank first by adjusted p-value, then by absolute log2FC
    top_genes <- sig_genes %>%
      arrange(p_val_adj, desc(abs(avg_log2FC))) %>%  # first p-value, then log2FC
      slice_head(n = 200) %>%                         # top 200 genes
      pull(gene)

    # Update sig column to label only top 200 genes
    volcano_genes$sig <- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

    p <- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
      geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
      geom_hline(yintercept = -log10(0.001), color = "gray40", linetype = "dashed") +
      geom_point(size = 3, alpha = 0.8) +
      scale_color_manual(values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
                         labels = c("Down", "ns", "Up")) +
      geom_text_repel(max.overlaps = 50, size = 3) +
      theme_classic(base_size = 14) +
      labs(
        x = "log Fold Change",
        y = expression(-log[10]("adjusted p-value")),
        color = "Regulation"
      ) +
      annotate("text", x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0("Up: ", n_up), hjust = 1, vjust = -0.5, color = "#3d70b5", size = 5) +
      annotate("text", x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0("Down: ", n_down), hjust = 0, vjust = -0.5, color = "black", size = 5)

    # Save per cluster
    out_file <- paste0("15.4_VolcanoPlot_DE_", cluster, "_DE.pdf")
    print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
  }
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)

```

### 15.5 GO Enrichment Analysis (Fibroblast DE)

Perform GO enrichment analysis on differentially expressed genes in fibroblasts.

```{r eval=FALSE, include=TRUE}
set.seed(42)
read_all_sheets <- function(path) {
  sheet_names <- excel_sheets(path)
  sheets <- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) <- sheet_names
  return(sheets)
}

DE_MS_vs_Ctrl <- read_all_sheets(file.path(result_dir, "15.6_DE_SCT_Fibro_MS_vs_Ctrl.xlsx"))

all_de_lists <- list(
  MS_vs_Ctrl = DE_MS_vs_Ctrl
)

# Clusters of interest
target_clusters <- as.character(Fibro_main_seurat@meta.data$seurat_clusters)
target_clusters <- unique(target_clusters)
# Function for enrichment and plotting
run_enrichment_and_plotting <- function(de_df, gene_list, direction, cluster, comparison) {
  if (length(gene_list) < 5) {
    message("Not enough genes for ", direction, "regulated ", cluster, " in ", comparison)
    return(NULL)
  }
  ego <- enrichGO(
    gene          = gene_list,
    OrgDb         = org.Hs.eg.db,
    keyType       = "SYMBOL",
    ont           = "ALL",
    pAdjustMethod = "BH",
    qvalueCutoff  = 0.05,
    readable      = TRUE
  )
  if (is.null(ego) || nrow(ego) == 0) {
    message("No enrichment results for ", direction, "regulated ", cluster, " in ", comparison)
    return(NULL)
  }
  # Save GO table
  file_base <- paste0("15.5_GO_DE_SCT_Fibro_", direction, "", cluster, "", comparison)
  write.xlsx(as.data.frame(ego), file = paste0(file_base, ".xlsx"))
  # Plots
#   pdf(paste0(file_base, ".pdf"), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste("Dotplot -", direction, "-", cluster, "-", comparison)))
    print("dotplot")
    print(barplot(ego) + ggtitle(paste("Dotplot -", direction, "-", cluster, "-", comparison)))
    print("barplot")
    sim <- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste("Enrichment Map -", direction, "-", cluster, "-", comparison)))
    print("emapplot")
    print(emapplot(sim, group = T) + ggtitle(paste("Cluster Map -", direction, "-", cluster, "-", comparison)))
    print("emapplot_cluster")
    de_df <- as.data.frame(de_df)
    rownames(de_df) <- de_df$gene
    fc_vector <- de_df[gene_list, "avg_log2FC"]
    names(fc_vector) <- gene_list
    print(cnetplot(ego, categorySize = "pvalue", foldChange = fc_vector) +
            ggtitle(paste("Cnetplot -", direction, "-", cluster, "-", comparison)))
    print("cnetplot")
  }, error = function(e) {
    message("Plotting failed for ", direction, "regulated ", cluster, " in ", comparison, ": ", e$message)
  })
#   dev.off()
}

#Main loop
for (comparison in names(all_de_lists)) {
  print(comparison)
  de_list <- all_de_lists[[comparison]]
  for (cluster in target_clusters) {
    print(cluster)
    cluster_name <- paste0("Cluster_", cluster)
    if (!cluster_name %in% names(de_list)) {
      message("Skipping ", cluster, " in ", comparison, "  not found.")
      next
    }
    de_df <- de_list[[cluster_name]]
    # Skip placeholder messages
    if (!"avg_log2FC" %in% colnames(de_df)) {
      message("Skipping ", cluster, " in ", comparison, "  not a valid DE result.")
      next
    }
    # UP-regulated
    gene_list_up <- de_df %>% filter(avg_log2FC > 0.5 & p_val_adj < 0.001) %>% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_up, "Up", cluster, comparison)
    # DOWN-regulated
    gene_list_down <- de_df %>% filter(avg_log2FC < -0.5 & p_val_adj < 0.001) %>% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_down, "Down", cluster, comparison)
  }
}

```

### 15.6 Transfer Label

Transfer annotations to the main fibroblast Seurat object and visualize.

```{r eval=FALSE, include=TRUE}
Fibro_main_seurat$annotated_1 <- Fibro_subset$annotated

Idents(Fibro_main_seurat) <- "annotated_1"
p <- DimPlot(Fibro_main_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, "15.6_DimPlot_Fibro_main_with_annotated1.pdf"), p, width = 6, height = 6)

p <- DimPlot(Fibro_main_seurat, label = T, split.by = "annotated_1")
print(last_plot()) # ggsave(file.path(result_dir, "15.6_DimPlot_Fibro_main_split.by_annotated1.pdf"), p, width = 20, height = 6)

cluster_colors = c("0" = "#66c69b", #main duraFibro2
                   "1" = "#ee756d", #main duraFibro3
                   "2" = "#d49005", #main duraFibro1
                   "3" = "#7caee5", #main duraFibro5
                   "4" = "#87be4d", #main arach_bordFibro
                   "5" = "#3cac57", #main duraFibro4
                   "6" = "#828dc6", #main mixFibro
                   "7" = "#ef7e48", #main duraFibro6
                   "8" = "#9584bd", #main ABC
                   "9" = "#ec67a2" #main duraFibro7
)

Idents(Fibro_main_seurat) <- "seurat_clusters"
p <- DimPlot(Fibro_main_seurat, label = T, cols = cluster_colors)
print(last_plot()) # ggsave(file.path(result_dir, "15.6_DimPlot_Fibro_reclustered_res0.15_newcolor.pdf"), p, width = 6, height = 6)


```

### 15.7 Fibroblast Trajectory Analysis

Analyze the developmental trajectory of fibroblast cells using Monocle3.

#### 15.7.0 Pseudotime Calculation

Convert fibroblast Seurat object to Monocle3 and calculate pseudotime.

```{r eval=FALSE, include=TRUE}
Idents(Fibro_seurat) <- "seurat_clusters"
Fibro_seurat$annotated_prev <- Fibro_seurat$annotated
Fibro_seurat$annotated <- Fibro_seurat$seurat_clusters
data <- as(as.matrix(GetAssayData(Fibro_seurat, assay = "SCT", slot = "counts")), 'sparseMatrix') #normally on RNA
pd <- data.frame(Fibro_seurat@meta.data)
pData <- pd %>% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, annotated_prev, sample, condition)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

Fibro_monocle <- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(Fibro_monocle)$gene_short_name <- rownames(fData(Fibro_monocle))
recreate.partitions <- c(rep(1, length(Fibro_monocle@colData@rownames)))
names(recreate.partitions) <- Fibro_monocle@colData@rownames
recreate.partitions <- as.factor(recreate.partitions)
recreate.partitions
Fibro_monocle@clusters@listData[["UMAP"]][["partitions"]] <- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster <- Fibro_seurat@active.ident
Fibro_monocle@clusters@listData[["UMAP"]][["clusters"]] <- list.cluster
Fibro_monocle@int_colData@listData[["reducedDims"]]@listData[["UMAP"]] <- Fibro_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors = c("0" = "#66c69b", #main duraFibro2
                   "1" = "#ee756d", #main duraFibro3
                   "2" = "#d49005", #main duraFibro1
                   "3" = "#7caee5", #main duraFibro5
                   "4" = "#87be4d", #main arach_bordFibro
                   "5" = "#3cac57", #main duraFibro4
                   "6" = "#828dc6", #main mixFibro
                   "7" = "#ef7e48", #main duraFibro6
                   "8" = "#9584bd", #main ABC
                   "9" = "#ec67a2" #main duraFibro7
)

cluster.before.traj <- plot_cells(Fibro_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = "right") +  scale_color_manual(values = cluster_colors)

# pdf("15.7.0_Fibro_before_traj_plot.pdf", width = 6, height = 6)
cluster.before.traj
# dev.off()

#let it calculate trajectory
#Fibro_monocle <- learn_graph(Fibro_monocle, use_partition = F, verbose = T, learn_graph_control=list(ncenter=275))
#if no loop trajectory makes sense do
set.seed(123)
Fibro_monocle <- learn_graph(Fibro_monocle, use_partition = F, verbose = T, close_loop = F, learn_graph_control=list(ncenter=250)) #changed ncenter to reduce branches

#plot trajectory into UMAP
p <- plot_cells(Fibro_monocle, label_groups_by_cluster = F,
                label_branch_points = T, label_roots = T, label_leaves = F,
                group_label_size = 4) + scale_color_manual(values = cluster_colors)
p$layers[[4]]$aes_params$size <- 6   # branchpoints
p$layers[[6]]$aes_params$size <- 10    # roots
p$layers[[3]]$aes_params$size <- 1.2  #traj edges
p$layers[[7]]$aes_params$size <- 6  # root numbers
# pdf("15.7.0_Fibro_traj_plot_thicker.pdf", width = 6, height = 6)
p
# dev.off()


#order the cells in pseudotime
#Fibro_monocle <- order_cells(Fibro_monocle, reduction_method = "UMAP", root_cells = colnames(Fibro_monocle[, clusters(Fibro_monocle) == 5]))
#if this Error appears "Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds", leave root_cells = NULL to manually select starting point
Fibro_monocle <- order_cells(Fibro_monocle, reduction_method = "UMAP", root_cells = NULL)

# pdf("15.7.0_Fibro_traj_plot_UMAP_pseudotime.pdf", width = 5, height = 4)
plot_cells(Fibro_monocle, color_cells_by = "pseudotime", label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
Fibro_monocle$monocle3_pseudotime <- pseudotime(Fibro_monocle)
data.pseudo <- as.data.frame(colData(Fibro_monocle))

# pdf("15.7.0_Fibro_traj_pseudotime.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab("")
# dev.off()
#or alternatively order by pseudotime
# pdf("15.7.0_Fibro_traj_pseudotime_order.pdf", width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab("pseudotime") + ylab("")
# dev.off()

qsave(Fibro_monocle, "15.7.0_Fibro_monocle.qs")

```

#### 15.7.1 Genes Along Pseudotime

Identify genes changing along the fibroblast trajectory.

```{r eval=FALSE, include=TRUE}
#find genes that change in pseudotime
deg <- graph_test(Fibro_monocle, neighbor_graph = "principal_graph", verbose = TRUE)
deg |> arrange(q_value, desc(morans_I)) |> filter(status == "OK") |> head()

#deg gene list can be looked at and saved
#Moran's value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, "15.7.1_Fibros_monocle_DEG.xlsx")

#one can also save pseudotime values into Seurat object and then plot for
Fibro_seurat$pseudotime <- pseudotime(Fibro_monocle)
# pdf("15.7.1_Fibro_FP_pseudotime.pdf", width = 4, height = 3)
FeaturePlot(Fibro_seurat, features = "pseudotime")
# dev.off()


```

#### 15.7.2 Plot Genes of Interest

Visualize expression of specific genes along the fibroblast pseudotime.

```{r eval=FALSE, include=TRUE}
#one can do multiple expression plots with certain identified genes
# pdf("15.7.2_Fibro_pseudotime_RP_genes_of_ineterest.pdf", width = 8, height = 9)
RidgePlot(Fibro_seurat, features = c("SVEP1", "FGF7", "LEPR", "FBLN1", "CLU", "TAGLN", "CFH", "ANGPT1", "NCAM1", "AKAP12", "SLC4A4", "KCNMA1", "F13A1", "CTSB", "PI16", "MFAP5", "KLF9", "DHRS3", "PHLDB2"), sort = F, cols = cluster_colors)
# dev.off()


my_genes <- c("SVEP1", "FGF7", "LEPR", "FBLN1", "CLU", "TAGLN", "CFH", "ANGPT1", "NCAM1", "AKAP12", "SLC4A4", "KCNMA1", "F13A1", "CTSB", "PI16", "MFAP5", "KLF9", "DHRS3", "PHLDB2")
Fibro_monocle <- Fibro_monocle[my_genes,]
plot_genes_in_pseudotime(Fibro_monocle_subset, color_cells_by = "monocle3_pseudotime" )
#or
# pdf("15.7.2_Fibro_genes_of_interest_traj_pseudocolor.pdf", width = 5, height = 20)
plot_genes_in_pseudotime(Fibro_monocle, color_cells_by = "monocle3_pseudotime" )
# dev.off()

# pdf("15.7.2_Fibro_genes_of_ineterest_traj_annotated.pdf", width = 5, height = 20)
plot_genes_in_pseudotime(Fibro_monocle, color_cells_by = "annotated" )
# dev.off()

```

#### 15.7.3 Top Changing Genes in Pseudotime

Visualize the top 5 most significant genes per cluster along the fibroblast pseudotime.

```{r eval=FALSE, include=TRUE}
#plot top5 genes that change over pseudotime in each cluster
deg_sig <- deg %>% filter(q_value < 0.05, status == "OK")

deg_sig$cluster <- Fibro_monocle$annotated[ match(deg_sig$gene_short_name,
                                                  rownames(Fibro_monocle)) ]

top5_per_cluster <- deg_sig %>%
  group_by(cluster) %>%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot <- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf("15.7.3_Fibro_top_genes_pseudotime.pdf", width = 5, height = 25)

plot_genes_in_pseudotime(
  Fibro_monocle[genes_to_plot, ],
  color_cells_by = "annotated",
  min_expr = 0.1
)

# dev.off()


```

#### 15.7.4 Condition-Dependent Gene Expression

Identify genes that vary across conditions along the pseudotime trajectory.

```{r eval=FALSE, include=TRUE}
#find genes that vary across condition
gene_fits <- fit_models(Fibro_monocle, model_formula_str = "~condition")
gene_fits_tbl <- coefficient_table(gene_fits)
write.xlsx(gene_fits_tbl, "15.7.4_Fibros_pseudotime_condition.xlsx")

# Keep only the condition coefficients
deg_cond <- gene_fits_tbl %>%
  filter(term != "(Intercept)")

# Significant genes
sig_genes <- deg_cond %>%
  filter(q_value < 0.05)

# Rank for labeling: first q-value, then |estimate|
top_genes <- sig_genes %>%
  arrange(q_value, desc(abs(estimate))) %>%
  slice_head(n = 50) %>%
  pull(gene_short_name)

deg_volcano <- deg_cond %>%
  mutate(
    logFC = estimate,
    negLogQ = -log10(q_value),
    DE = case_when(
      estimate > 0.5  & q_value < 0.05 ~ "Up",
      estimate < -0.5 & q_value < 0.05 ~ "Down",
      TRUE                              ~ "NO"
    ),
    logP = pmin(negLogQ, 50),      # cap values for nicer plot
    label_it = ifelse(gene_short_name %in% top_genes, gene_short_name, NA)
  )


deg_volcano$label_italic <- ifelse(
  is.na(deg_volcano$label_it),
  NA,
  paste0("italic('", deg_volcano$label_it, "')")
)

p <- ggplot(deg_volcano, aes(x = logFC, y = logP, color = DE)) +
  geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), color = "gray40", linetype = "dashed") +
  geom_point(size = 3, alpha = 0.8) +

  scale_color_manual(
    values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
    labels = c("Down", "ns", "Up")
  ) +

  ggrepel::geom_text_repel(
    aes(label = label_italic),
    parse = TRUE,
    max.overlaps = 50,
    size = 3
  ) +

  theme_classic(base_size = 14) +
  labs(
    title = "Condition-dependent DEGs along trajectory",
    x = "log Fold Change",
    y = expression(-log[10]("adjusted p-value")),
    color = "Regulation"
  )

print(last_plot()) # ggsave(file.path(result_dir, "15.7.4_Fibro_pseudotime_VolcanoPlot_DE_MS_vs_ctrl.pdf"), p , width = 10, height = 7)

#plot genes over pseudotime
top_genes <- top_sig$gene_short_name

p <- plot_genes_in_pseudotime(
  Fibro_monocle[top_genes, ],
  color_cells_by = "condition"
)

print(last_plot()) # ggsave(file.path(result_dir, "15.7.4_Fibro_pseudotime_along_traj_Plot_DE_MS_vs_ctrl.pdf"), p , width = 5, height = 25)


```

### 15.8 Overall Fibroblast Differential Expression

Perform differential expression analysis on the overall fibroblast population (duraFibro clusters) between MS and Ctrl conditions.

```{r eval=FALSE, include=TRUE}
Idents(Fibro_main_seurat) <- "seurat_clusters"
duraFibro_seurat <- subset(Fibro_main_seurat, idents = c("0", "1", "2", "3", "5", "6", "7", "9"))

Idents(duraFibro_seurat) <- "condition"

DefaultAssay(duraFibro_seurat) <- "SCT"
DE_duraFibro_overall <- FindMarkers(
  duraFibro_seurat,
  ident.1 = "MS",
  ident.2 = "Ctrl",
  group.by = "condition",
  recorrect_umi = FALSE
)

DE_duraFibro_overall <- DE_duraFibro_overall %>%
  rownames_to_column(var = "gene") %>%
  arrange(p_val_adj, desc(avg_log2FC))

write_xlsx(DE_duraFibro_overall, "15.8_DE_duraFibro_overall.xlsx")


```

### 15.8.1 GO Enrichment for Overall Fibroblast DE

Perform Gene Ontology enrichment analysis on the differentially expressed genes found in the overall fibroblast analysis.

```{r eval=FALSE, include=TRUE}
set.seed(42)

read_all_sheets <- function(path) {
  sheet_names <- excel_sheets(path)
  sheets <- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) <- sheet_names
  return(sheets)
}
DE_MS_vs_Ctrl <- read_all_sheets(file.path(result_dir, "15.8_DE_duraFibro_overall.xlsx"))

# Function for enrichment and plotting
run_enrichment_and_plotting <- function(de_df, gene_list, direction, cluster, comparison) {
  if (length(gene_list) < 5) {
    message("Not enough genes for ", direction, "regulated ", cluster, " in ", comparison)
    return(NULL)
  }
  ego <- enrichGO(
    gene          = gene_list,
    OrgDb         = org.Hs.eg.db,
    keyType       = "SYMBOL",
    ont           = "ALL",
    pAdjustMethod = "BH",
    qvalueCutoff  = 0.05,
    readable      = TRUE
  )
  if (is.null(ego) || nrow(ego) == 0) {
    message("No enrichment results for ", direction, "regulated ", cluster, " in ", comparison)
    return(NULL)
  }
  # Save GO table
  file_base <- paste0("15.8.1_GO_DE_duraFibro_", direction, "", cluster, "", comparison)
  write.xlsx(as.data.frame(ego), file = paste0(file_base, ".xlsx"))
  # Plots
#   pdf(paste0(file_base, ".pdf"), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste("Dotplot -", direction, "-", cluster, "-", comparison)))
    print("dotplot")
    print(barplot(ego) + ggtitle(paste("Dotplot -", direction, "-", cluster, "-", comparison)))
    print("barplot")
    sim <- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste("Enrichment Map -", direction, "-", cluster, "-", comparison)))
    print("emapplot")
    print(emapplot(sim, group = T) + ggtitle(paste("Cluster Map -", direction, "-", cluster, "-", comparison)))
    print("emapplot_cluster")
    de_df <- as.data.frame(de_df)
    rownames(de_df) <- de_df$gene
    fc_vector <- de_df[gene_list, "avg_log2FC"]
    names(fc_vector) <- gene_list
    print(cnetplot(ego, categorySize = "pvalue", foldChange = fc_vector) +
            ggtitle(paste("Cnetplot -", direction, "-", cluster, "-", comparison)))
    print("cnetplot")
  }, error = function(e) {
    message("Plotting failed for ", direction, "regulated ", cluster, " in ", comparison, ": ", e$message)
  })
#   dev.off()
}

#Main loop
de_df <- DE_MS_vs_Ctrl[["Sheet1"]]

# Upregulated genes
gene_list_up <- de_df %>%
  filter(avg_log2FC > 0.5 & p_val_adj < 0.001) %>%
  pull(gene)

run_enrichment_and_plotting(de_df, gene_list_up, "Up", "All_duraFibros", "MS_vs_Ctrl")

# Downregulated genes
gene_list_down <- de_df %>%
  filter(avg_log2FC < -0.5 & p_val_adj < 0.001) %>%
  pull(gene)

run_enrichment_and_plotting(de_df, gene_list_down, "Down", "All_duraFibros", "MS_vs_Ctrl")


```

### 15.8.2 Volcano Plot (Top Genes)

Visualize the overall fibroblast DE results using a volcano plot, labeling the top significant genes.

```{r eval=FALSE, include=TRUE}
de_file <- "15.8_DE_duraFibro_overall.xlsx"

all_clusters <- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message("Processing cluster: ", cluster)

  # Read cluster sheet
  de_data <- read.xlsx(de_file, sheet = cluster)
  volcano_genes <- de_data

  #remove MT, RPL, RPS genes and Lnc
  volcano_genes <- volcano_genes %>% filter(!grepl("^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.", gene))
  #Define sig. up/down-reg genes
  volcano_genes$DE <- "NO"
  volcano_genes$DE[volcano_genes$avg_log2FC > 0.5 & volcano_genes$p_val_adj < 0.001] <- "Up"
  volcano_genes$DE[volcano_genes$avg_log2FC < -0.5 & volcano_genes$p_val_adj < 0.001] <- "Down"
  #sign. up & down
  volcano_genes$sig <- ifelse(volcano_genes$DE == "NO", "", volcano_genes$gene)
  sig <- volcano_genes$sig
  volcano_genes$sig <- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
  volcano_genes$DE <- factor(volcano_genes$DE, levels = c("Down", "NO", "Up"))
  volcano_genes$logP <- -log10(volcano_genes$p_val_adj)
  volcano_genes$logP <- pmin(volcano_genes$logP, 50)

  # Count up- and down-regulated genes
  n_up <- sum(volcano_genes$DE == "Up", na.rm = TRUE)
  n_down <- sum(volcano_genes$DE == "Down", na.rm = TRUE)

  # Filter only significant DE genes
  sig_genes <- volcano_genes %>%
    filter(DE != "NO")
  # Rank first by adjusted p-value, then by absolute log2FC
  top_genes <- sig_genes %>%
    arrange(p_val_adj, desc(abs(avg_log2FC))) %>%  # first p-value, then log2FC
    slice_head(n = 400) %>%                         # top 500 genes
    pull(gene)

  # Update sig column to label only top 400 genes
  volcano_genes$interest <- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

  p <- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
    geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
    geom_hline(yintercept = -log10(0.001), color = "gray40", linetype = "dashed") +
    geom_point(size = 3, alpha = 0.8) +
    scale_color_manual(values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5"),
                       labels = c("Down", "ns", "Up")) +
    geom_text_repel(max.overlaps = 50, size = 3) +
    theme_classic(base_size = 14) +
    labs(
      x = "log Fold Change",
      y = expression(-log[10]("adjusted p-value")),
      color = "Regulation"
    ) +
    annotate("text", x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
             label = paste0("Up: ", n_up), hjust = 1, vjust = -0.5, color = "#3d70b5", size = 5) +
    annotate("text", x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
             label = paste0("Down: ", n_down), hjust = 0, vjust = -0.5, color = "black", size = 5)

  # Save per cluster
  out_file <- paste0("15.8.2_VolcanoPlot_duraFibro_", cluster, "_DE.pdf")
  print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)

```

### 15.8.3 Volcano Plot (Genes of Interest)

Visualize the overall fibroblast DE results, highlighting specific genes of interest (ECM and proliferation markers).

```{r eval=FALSE, include=TRUE}
de_file <- "15.8_DE_duraFibro_overall.xlsx"

all_clusters <- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message("Processing cluster: ", cluster)

  # Read cluster sheet
  de_data <- read.xlsx(de_file, sheet = cluster)
  volcano_genes <- de_data

  #remove MT, RPL, RPS genes and Lnc
  volcano_genes <- volcano_genes %>% filter(!grepl("^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.", gene))
  #Define sig. up/down-reg genes
  volcano_genes$DE <- "NO"
  volcano_genes$DE[volcano_genes$avg_log2FC > 0.5 & volcano_genes$p_val_adj < 0.001] <- "Up"
  volcano_genes$DE[volcano_genes$avg_log2FC < -0.5 & volcano_genes$p_val_adj < 0.001] <- "Down"
  #sign. up & down
  volcano_genes$sig <- ifelse(volcano_genes$DE == "NO", "", volcano_genes$gene)
  sig <- volcano_genes$sig
  volcano_genes$sig <- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
  volcano_genes$DE <- factor(volcano_genes$DE, levels = c("Down", "NO", "Up"))
  volcano_genes$logP <- -log10(volcano_genes$p_val_adj)
  volcano_genes$logP <- pmin(volcano_genes$logP, 50)

  # Count up- and down-regulated genes
  n_up <- sum(volcano_genes$DE == "Up", na.rm = TRUE)
  n_down <- sum(volcano_genes$DE == "Down", na.rm = TRUE)

  # Filter only significant DE genes
  sig_genes <- volcano_genes %>%
    filter(DE != "NO")
  # Rank first by adjusted p-value, then by absolute log2FC
  top_genes <- sig_genes %>%
    arrange(p_val_adj, desc(abs(avg_log2FC))) %>%  # first p-value, then log2FC
    slice_head(n = 400) %>%                         # top 500 genes
    pull(gene)

  # label genes of interest
  genes_of_interest <- read_csv("genes_ECM_prolif.txt", col_names = FALSE) %>%
    pull(X1) %>%
    trimws() %>%           # remove spaces
    toupper()              # make uppercase, assuming your DE gene names are uppercase


  # assign color based on fold change
  volcano_genes$interest <- ifelse(volcano_genes$gene %in% genes_of_interest, volcano_genes$gene, NA)
  volcano_genes$interest_color <- NA
  volcano_genes$interest_color[volcano_genes$gene %in% genes_of_interest &
                                 volcano_genes$avg_log2FC > 0] <- "#3d70b5"   # upregulated  blue
  volcano_genes$interest_color[volcano_genes$gene %in% genes_of_interest &
                                 volcano_genes$avg_log2FC < 0] <- "black"      # downregulated  black

  p <- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP)) +
    geom_vline(xintercept = c(-0.5, 0.5), color = "gray40", linetype = "dashed") +
    geom_hline(yintercept = -log10(0.001), color = "gray40", linetype = "dashed") +

    # all genes by DE
    geom_point(aes(color = DE), size = 3, alpha = 0.8) +

    # genes of interest colored by fold change
    geom_point(data = subset(volcano_genes, !is.na(interest)),
               aes(x = avg_log2FC, y = logP, color = interest_color),
               size = 3) +

    # labels for genes of interest
    geom_text_repel(
      aes(label = interest, color = interest_color),
      max.overlaps = 50,
      size = 3,
      show.legend = FALSE      # optional: hide from legend
    ) +

    # set colors for DE categories (non-interest genes)
    scale_color_manual(values = c("Down" = "black", "NO" = "grey70", "Up" = "#3d70b5",
                                  "#3d70b5" = "#3d70b5", "black" = "black"),
                       labels = c("Down", "ns", "Up")) +

    theme_classic(base_size = 14) +
    labs(
      x = "log Fold Change",
      y = expression(-log[10]("adjusted p-value")),
      color = "Regulation"
    )

  # Save per cluster
  out_file <- paste0("15.8.3_VolcanoPlot_duraFibro_genes_of_interest_", cluster, "_DE.pdf")
  print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)

```

### 15.9 NicheNet Analysis (MS vs Ctrl)

Perform NicheNet analysis to infer ligand-receptor interactions driving the structural fibroblast response in MS.

```{r eval=FALSE, include=TRUE}
#convert Seurat to single cell experiment and define meta data
samples_seurat$Fibro <- dplyr::case_when(
  samples_seurat$annotated_manuscript %in% c("duraFibro1", "duraFibro2", "duraFibro3", "duraFibro4", "duraFibro5", "duraFibro6", "duraFibro7", "duraFibro8") ~ "duraFibro",
  TRUE ~ as.character(samples_seurat$annotated)
)

sce <- Seurat::as.SingleCellExperiment(samples_seurat, assay = "SCT")
sce <- alias_to_symbol_SCE(sce, "human") |> makenames_SCE()

sample_id <- "sample_id"
group_id <- "condition"
celltype_id <- "Fibro"
covariates <- NA
batches <- NA

#define organism
organism = "human"

if(organism == "human"){
  lr_network = readRDS(url("https://zenodo.org/record/7074291/files/lr_network_human_21122021.rds"))
  lr_network = lr_network |> dplyr::rename(ligand = from, receptor = to) |> distinct(ligand, receptor) |> mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds"))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |> make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |> make.names()
} else if(organism == "mouse"){
  lr_network = readRDS(url("https://zenodo.org/record/7074291/files/lr_network_mouse_21122021.rds"))
  lr_network = lr_network |> dplyr::rename(ligand = from, receptor = to) |> distinct(ligand, receptor) |> mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds"))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |> make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |> make.names()
}

#change names because _ and dots are not allowed
colData(sce)[, celltype_id] <- factor(gsub("-", "_", colData(sce)[, celltype_id]))
levels(colData(sce)[, celltype_id])

#Sender and receiver cell types need to be defined. Here all cell types in the dataset are used
senders_oi <- SummarizedExperiment::colData(sce)[,celltype_id] |> unique()
receivers_oi <- SummarizedExperiment::colData(sce)[,celltype_id] |> unique()

sce <- sce[, SummarizedExperiment::colData(sce)[,celltype_id] %in% c(senders_oi, receivers_oi)]

min_cells <- 10

abundance_info = get_abundance_info(
  sce = sce,
  sample_id = sample_id,
  group_id = group_id,
  celltype_id = celltype_id,
  min_cells = min_cells,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  batches = batches)

## check for condition-specific cell types
abundance_df_summarized = abundance_info$abundance_data %>% mutate(keep = as.logical(keep)) %>% group_by(group_id, celltype_id) %>% summarise(samples_present = sum((keep)))
celltypes_absent_one_condition = abundance_df_summarized %>% filter(samples_present == 0) %>% pull(celltype_id) %>% unique() # find truly condition-specific cell types by searching for cell types truely absent in at least one condition
celltypes_present_one_condition = abundance_df_summarized %>% filter(samples_present >= 2) %>% pull(celltype_id) %>% unique() # require presence in at least 2 samples of one group so it is really present in at least one condition
condition_specific_celltypes = intersect(celltypes_absent_one_condition, celltypes_present_one_condition)

condition_specific_celltypes_senders = condition_specific_celltypes %>% intersect(senders_oi)
condition_specific_celltypes_receivers = condition_specific_celltypes %>% intersect(receivers_oi)

fraction_cutoff <- 0.05
min_sample_prop <- 0.5
frq_list = get_frac_exprs(sce = sce, sample_id = sample_id, celltype_id =  celltype_id, group_id = group_id, batches = batches, min_cells = min_cells, fraction_cutoff = fraction_cutoff, min_sample_prop = min_sample_prop)

abundance_expression_info <- process_abundance_expression_info(
  sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, min_cells = min_cells,
  senders_oi = union(senders_oi, condition_specific_celltypes_senders),
  receivers_oi = union(receivers_oi, condition_specific_celltypes_receivers),
  lr_network = lr_network, batches = batches, frq_list = frq_list, abundance_info = abundance_info)

table(colData(sce)[,celltype_id], colData(sce)[,sample_id])

#If you compare against two groups, you should divide by 2, if you compare against three groups, you should divide by 3 etcetera
contrasts_oi <- c("'M-(S+A)/2','S-(M+A)/2','A-(S+M)/2'")
#if compare against two groups
contrasts_oi <- c("'MS-Ctrl','Ctrl-MS'")
contrast_tbl <- tibble(contrast = c("MS-Ctrl","Ctrl-MS"), group = c("MS","Ctrl"))

assay_oi_pb <- "counts"
fun_oi_pb <- "sum"
de_method_oi <- "edgeR"
findMarkers <- FALSE

DE_info = get_DE_info(sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, batches = batches, covariates = covariates, contrasts_oi = contrasts_oi, min_cells = min_cells,
                      assay_oi_pb = assay_oi_pb,
                      fun_oi_pb = fun_oi_pb,
                      de_method_oi = de_method_oi,
                      findMarkers = findMarkers,
                      expressed_df = frq_list$expressed_df)

#check p-value distribution#should be quite straight horizontal line
DE_info$hist_pvals

#if it looks ok, run "empirical_pval == FALSE
empirical_pval = FALSE
#if it looks suboptimal run empirical_pval == TRUE and check quality
empirical_pval = TRUE

if(empirical_pval == TRUE){
  DE_info_emp = get_empirical_pvals(DE_info$celltype_de$de_output_tidy)
}
DE_info_emp$hist_pvals_emp

if(empirical_pval == FALSE){
  celltype_de = DE_info$celltype_de$de_output_tidy
} else {
  celltype_de = DE_info_emp$de_output_tidy_emp %>% dplyr::select(-p_val, -p_adj) %>% dplyr::rename(p_val = p_emp, p_adj = p_adj_emp)
}

sender_receiver_de = combine_sender_receiver_de(
  sender_de = celltype_de,
  receiver_de = celltype_de,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  lr_network = lr_network
)

logFC_threshold = 0.50
p_val_threshold = 0.05
fraction_cutoff = 0.05


# p_val_adj = TRUE #In case of more samples per group + sufficient high number of DE genes per group-celltype (> 20-50), use p_val_adj = TRUE
p_val_adj = T

top_n_target = 400

verbose = TRUE
cores_system = 8
n.cores = min(cores_system, sender_receiver_de$receiver %>% unique() %>% length()) # use one core per receiver cell type

ligand_activities_targets_DEgenes = suppressMessages(suppressWarnings(get_ligand_activities_targets_DEgenes(
  receiver_de = celltype_de,
  receivers_oi = receivers_oi,
  ligand_target_matrix = ligand_target_matrix,
  logFC_threshold = logFC_threshold,
  p_val_threshold = p_val_threshold,
  p_val_adj = T,
  top_n_target = top_n_target,
  verbose = T,
  n.cores = n.cores
)))

prioritizing_weights_DE = c("de_ligand" = 1,
                            "de_receptor" = 1)
prioritizing_weights_activity = c("activity_scaled" = 2)

prioritizing_weights_expression_specificity = c("exprs_ligand" = 2,
                                                "exprs_receptor" = 2)

prioritizing_weights_expression_sufficiency = c("frac_exprs_ligand_receptor" = 1)

prioritizing_weights_relative_abundance = c( "abund_sender" = 0,
                                             "abund_receiver" = 0)

prioritizing_weights = c(prioritizing_weights_DE,
                         prioritizing_weights_activity,
                         prioritizing_weights_expression_specificity,
                         prioritizing_weights_expression_sufficiency,
                         prioritizing_weights_relative_abundance)

sender_receiver_tbl = sender_receiver_de |> dplyr::distinct(sender, receiver)

metadata_combined = SummarizedExperiment::colData(sce) |> tibble::as_tibble()

if(!is.na(batches)){
  grouping_tbl = metadata_combined[,c(sample_id, group_id, batches)] |> tibble::as_tibble() |> dplyr::distinct()
  colnames(grouping_tbl) = c("sample","group",batches)
} else {
  grouping_tbl = metadata_combined[,c(sample_id, group_id)] |> tibble::as_tibble() |> dplyr::distinct()
  colnames(grouping_tbl) = c("sample","group")
}

scenario <- "regular" # all prioritization criteria will be weighted equally
ligand_activity_down <- FALSE # use only upregulatory ligand activities to prioritize

prioritization_tables = suppressMessages(generate_prioritization_tables(
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de = sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  contrast_tbl = contrast_tbl,
  sender_receiver_tbl = sender_receiver_tbl,
  grouping_tbl = grouping_tbl,
  scenario = scenario,
  fraction_cutoff = fraction_cutoff,
  abundance_data_receiver = abundance_expression_info$abundance_data_receiver,
  abundance_data_sender = abundance_expression_info$abundance_data_sender,
  ligand_activity_down = ligand_activity_down
))

lr_target_prior_cor = lr_target_prior_cor_inference(prioritization_tables$group_prioritization_tbl$receiver |> unique(), abundance_expression_info, celltype_de, grouping_tbl, prioritization_tables, ligand_target_matrix, logFC_threshold = logFC_threshold, p_val_threshold = p_val_threshold, p_val_adj = p_val_adj)

#extract MS-specific strucFibro interactions
interactions_MS <- prioritization_tables$group_prioritization_tbl %>%
  filter(group == "MS")

duraFibro_MS_interactions <- interactions_MS %>%
  filter(sender == "duraFibro" | receiver == "duraFibro") %>%
  arrange(desc(prioritization_score))

# Inspect partners
unique_senders_MS <- setdiff(unique(duraFibro_MS_interactions$sender), "duraFibro")
unique_receivers_MS <- setdiff(unique(duraFibro_MS_interactions$receiver), "duraFibro")

cat("Senders to strucFibro in MS:\n")
print(unique_senders_MS)

cat("Receivers from strucFibro in MS:\n")
print(unique_receivers_MS)

# Save table
write.csv(duraFibro_MS_interactions, "15.9_MS_duraFibro_interactions.csv", row.names = FALSE)

#save previous calculations as one large list
multinichenet_output = list(
  celltype_info = abundance_expression_info$celltype_info,
  celltype_de = celltype_de,
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de =  sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  prioritization_tables = prioritization_tables,
  grouping_tbl = grouping_tbl,
  lr_target_prior_cor = lr_target_prior_cor
)
multinichenet_output = make_lite_output(multinichenet_output)

saveRDS(multinichenet_output, file = "15.9_multinichenet_MS_duraFibro.rds")

```

#### 15.9.1 Circos Plot Visualization

Visualize the prioritized ligand-receptor interactions using Circos plots.

```{r eval=FALSE, include=TRUE}
#top20
duraFibro_MS_top20 <- duraFibro_MS_interactions %>%
  arrange(desc(prioritization_score)) %>%
  slice(1:20)
senders_receivers <- union(duraFibro_MS_top20$sender %>% unique(),
                           duraFibro_MS_top20$receiver %>% unique()) %>% sort()
colors_sender <- cluster_colors[senders_receivers]
colors_receiver <- cluster_colors[senders_receivers]

# pdf("15.9.1_top20_circos_plot_MS_duraFibro.pdf", width = 10, height = 10)
circos_list <- make_circos_group_comparison(duraFibro_MS_top20, colors_sender, colors_receiver)
# dev.off()

#split bei receiver
library(circlize)
library(dplyr)

# Open multi-page PDF
# pdf("15.9.1_circos_split_by_receiver.pdf", width = 10, height = 10)

unique_receivers <- sort(unique(prioritized_tbl_oi$receiver))

for(receiver in unique_receivers) {

  # Subset top interactions for this receiver
  subset_tbl <- prioritized_tbl_oi %>% filter(receiver == !!receiver)
  if(nrow(subset_tbl) == 0) next

  # Create circos object
  circos_list <- make_circos_group_comparison(subset_tbl, colors_sender, colors_receiver)

  circos.clear()
  circos.par(gap.degree = 5)

  # Initialize sectors
  cell_types <- circos_list$cell_types
  xlim_list <- lapply(cell_types, function(x) c(0,1))
  names(xlim_list) <- cell_types
  for(sector in cell_types){
    circos.initialize(factors = sector, xlim = xlim_list[[sector]])
  }

  # Draw arcs and labels
  cell_colors <- circos_list$colors
  for(sector in cell_types){
    circos.trackPlotRegion(factors = sector, y = c(0,1),
                           bg.col = cell_colors[sector], bg.border = NA,
                           panel.fun = function(x, y){
                             circos.text(CELL_META$xcenter, CELL_META$ycenter,
                                         CELL_META$sector.index,
                                         facing = "clockwise", niceFacing = TRUE, cex = 0.8)
                           })
  }

  # Draw links
  if(!is.null(circos_list$links) && nrow(circos_list$links) > 0){
    for(i in seq_len(nrow(circos_list$links))){
      link <- circos_list$links[i, ]
      circos.link(sector.index1 = link$sender, point1 = 0.5,
                  sector.index2 = link$receiver, point2 = 0.5,
                  col = rgb(0,0,0,0.3), border = NA)
    }
  }

  # Each iteration creates a **new page** in the PDF
}

# Close PDF device
# dev.off()
```
