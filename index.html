<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2026-02-18" />

<title>Human Dura</title>

<script src="site_libs/header-attrs-2.30/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Human Dura Atlas</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Human Dura</h1>
<h4 class="date">2026-02-18</h4>

</div>


<pre class="r"><code>knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)</code></pre>
<div id="setup-and-environment" class="section level2">
<h2>1. Setup and Environment</h2>
<p>Load necessary packages and define global paths.</p>
<pre class="r"><code>#get started with seurat workflow
library(Seurat)
library(ggplot2)
library(readxl)
library(openxlsx)
library(SingleCellExperiment)
library(scDblFinder)
library(qs)
library(clustree) # for cluster tree
library(openxlsx) #writexlsx
library(dplyr) #left_join
library(readr) #read_csv()
library(writexl) #write_xlsx
library(patchwork)
library(clustree)

#scType
library(tibble)
library(dplyr)
library(HGNChelper)

#Propeller/ cell abundance plots
# BiocManager::install(&quot;phipsonlab/speckle&quot;)
library(speckle)

#Go enrichment analysis ClusterProfiler
library(clusterProfiler)
library(org.Hs.eg.db)
library(openxlsx)
library(enrichplot)
library(ggplot2)
library(dplyr)
library(readxl)

#ggarrange
library(ggpubr)

#NicheNet
library(Seurat)
library(SeuratWrappers)
library(SingleCellExperiment)
library(multinichenetr)
library(ggplot2)
library(dplyr)
library(readr)
library(circlize)
library(scales)


#Trajectory monocle
library(Seurat)
library(SeuratWrappers)
library(monocle3)
library(ggplot2)
library(dplyr)
library(readr)


#milo
library(miloR)
library(miloDE)</code></pre>
</div>
<div id="load-raw-data" class="section level2">
<h2>1.2 Load Raw Data</h2>
<p><em>Note: The code below outlines the process for loading raw data,
but assumes pre-processed objects are used in this report.</em></p>
<pre class="r"><code>#download h5 files from GEO
#load individual samples with Read10x_h5() function</code></pre>
</div>
<div id="define-sample-names" class="section level2">
<h2>1.3 Define Sample Names</h2>
<p>Define sample identifiers and create the initial list of objects.</p>
<pre class="r"><code>sample_names &lt;- c(&quot;M43_P9&quot;, &quot;C97_H_P9&quot;, &quot;M98_H_P9 &quot;, #Pool 9
                  &quot;C76_H_P9_10 &quot;, #Pool9+10
                  &quot;M47_P10&quot;, &quot;C115_H_P10&quot;, &quot;M3509_P10 &quot;, #Pool10
                  &quot;M31_P11&quot;, &quot;C54_P11&quot;, &quot;C3606_P11&quot;, &quot;M3867_P11&quot;, #Pool11
                  &quot;C36_P12&quot;, &quot;C42_P12&quot;, &quot;M2429_P12&quot;, &quot;M4074_P12&quot;, #Pool12
                  &quot;C40_P13&quot;, &quot;C57_H_P13&quot;, &quot;M69_P13&quot;, &quot;M82_H_P13&quot;, #Pool13
                  &quot;C61_P14&quot;, &quot;M94_H_P14&quot;, &quot;M99_H_P14&quot;, &quot;C3590_P14&quot; #Pool14
)

# Create a list of Seurat objects for each sample, with respective sample names
samples &lt;- list(M43_P9, C97_H_P9, M98_H_P9, #Pool 9
                C76_H_P9_10, #Pool9+10
                M47_P10, C115_H_P10, M3509_P10, #Pool10
                M31_P11, C54_P11, C3606_P11, M3867_P11, #Pool11
                C36_P12, C42_P12, M2429_P12, M4074_P12, #Pool12
                C40_P13, C57_H_P13, M69_P13, M82_H_P13, #Pool13
                C61_P14, M94_H_P14, M99_H_P14, C3590_P14 #Pool14
)|&gt; setNames(sample_names)</code></pre>
</div>
<div id="initialize-seurat-objects" class="section level2">
<h2>1.4 Initialize Seurat Objects</h2>
<p>Create Seurat objects for each sample and assign unique cell
identifiers.</p>
<pre class="r"><code>samples &lt;- mapply(function(x, nm) {
  obj &lt;- CreateSeuratObject(x, project = nm)
  obj &lt;- RenameCells(obj, add.cell.id = nm)   # make cell names unique per sample
  obj$sample &lt;- nm                            # add sample name to metadata
  return(obj)
}, samples, names(samples), SIMPLIFY = FALSE)</code></pre>
</div>
<div id="quality-control-qc" class="section level2">
<h2>2. Quality Control (QC)</h2>
<p>Calculate and visualize QC metrics to identify low-quality cells.</p>
</div>
<div id="calculate-qc-metrics" class="section level2">
<h2>2.1 Calculate QC Metrics</h2>
<p>Calculate mitochondrial, ribosomal, and erythrocyte gene
percentages.</p>
<pre class="r"><code>for (i in seq_along(samples)) {
  samples[[i]][[&quot;percent_mito&quot;]] &lt;- PercentageFeatureSet(samples[[i]], pattern = &quot;^MT-&quot;)
  samples[[i]][[&quot;percent_ribo&quot;]] &lt;- PercentageFeatureSet(samples[[i]], pattern = &quot;^RP[SLP]&quot;)
  samples[[i]][[&quot;percent_ery&quot;]] &lt;- PercentageFeatureSet(samples[[i]], pattern = &quot;^HB[AB]&quot;)
}
# Create a list to store QC data
qc_data &lt;- list()
# Run QC on all samples (before filtering)
for (i in seq_along(samples)) {
  # Adding sample name as Ident and other metadata features
  Idents(samples[[i]]) &lt;- sample_names[[i]]
  samples[[i]][[&quot;sample_id&quot;]] &lt;- names(samples)[i]

  # Add QC data to the qc_data list
  qc_data[[sample_names[i]]] &lt;- data.frame(
    Sample = sample_names[i],
    Cell_Count = ncol(samples[[i]]),
    Percent_Mito = mean(samples[[i]]$percent_mito, na.rm = TRUE),
    Percent_Ribo = mean(samples[[i]]$percent_ribo, na.rm = TRUE),
    Percent_Ery = mean(samples[[i]]$percent_ery, na.rm = TRUE)
  )
}</code></pre>
</div>
<div id="save-pre-filtering-qc-stats" class="section level2">
<h2>2.2 Save Pre-filtering QC Stats</h2>
<p>Save the QC statistics to an Excel file.</p>
<pre class="r"><code>qc_summary_before &lt;- do.call(rbind, qc_data)
openxlsx::write.xlsx(qc_summary_before, file = file.path(result_dir, &quot;2.2_cell_count_preQC.xlsx&quot;), rowNames = FALSE)</code></pre>
</div>
<div id="visualize-pre-filtering-qc" class="section level2">
<h2>2.3 Visualize Pre-filtering QC</h2>
<p>Visualize QC metrics (nFeature, nCount, Percent Mito, etc.) using
violin plots.</p>
<pre class="r"><code>#create QC plots before filtering seperated
# pdf(&quot;2.3_pre_QC_ViolinPlots_seperated.pdf&quot;, width=11.69, height=8.27)
for (i in seq_along(samples)){
  print(VlnPlot(samples[[i]], features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent_mito&quot;,&quot;percent_ribo&quot;, &quot;percent_ery&quot;), ncol = 5))
}
# dev.off()

#create QC plots before filtering seperated combined
combined_samples &lt;- Reduce(function(x, y) merge(x, y), samples)
# pdf(file.path(result_dir, &quot;2.3_pre_QC_ViolinPlots_combined.pdf&quot;), width = 30, height = 25)
VlnPlot(
  combined_samples, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent_mito&quot;, &quot;percent_ribo&quot;, &quot;percent_ery&quot;), group.by = &quot;sample_id&quot;, pt.size = 0.1, ncol = 2
)
# dev.off()</code></pre>
</div>
<div id="doublet-detection" class="section level2">
<h2>2.4 Doublet Detection</h2>
<p>Use <code>scDblFinder</code> to identify and mark potential doublet
cells.</p>
<pre class="r"><code>#use scDblFinder to exclude doublets
for (i in seq_along(samples)){
  samples_sce &lt;- lapply(samples, as.SingleCellExperiment)
  samples_sce &lt;- lapply(samples_sce, scDblFinder)
  samples[[i]][[&quot;scDblFinder.score&quot;]] &lt;- samples_sce[[i]][[&quot;scDblFinder.score&quot;]]
  samples[[i]][[&quot;scDblFinder.class&quot;]] &lt;- samples_sce[[i]][[&quot;scDblFinder.class&quot;]]
}</code></pre>
</div>
<div id="data-filtering" class="section level2">
<h2>3. Data Filtering</h2>
<p>Remove low-quality cells based on the calculated QC metrics and
doublet status.</p>
</div>
<div id="apply-qc-filters" class="section level2">
<h2>3.1 Apply QC Filters</h2>
<p>Filter cells based on feature counts,
mitochondrial/ribosomal/erythrocyte content, and doublet
classification.</p>
<pre class="r"><code>samples_filteredQC &lt;- lapply(samples, function(s) {
  keep &lt;- s[[&quot;nFeature_RNA&quot;]] &gt; 200 &amp;
    s[[&quot;nFeature_RNA&quot;]] &lt; 4000 &amp;
    s[[&quot;nCount_RNA&quot;]] &lt; 8000 &amp;
    s[[&quot;percent_mito&quot;]] &lt; 5 &amp;
    s[[&quot;percent_ery&quot;]] &lt; 1 &amp;
    s[[&quot;percent_ribo&quot;]] &lt; 5 &amp;
    s[[&quot;scDblFinder.class&quot;]] == &quot;singlet&quot;

  if (sum(keep, na.rm = TRUE) &gt; 0) {
    return(subset(s, cells = colnames(s)[keep]))
  } else {
    return(NULL)
  }
})
which(sapply(samples_filteredQC, is.null))
samples_filteredQC &lt;- Filter(Negate(is.null), samples_filteredQC)</code></pre>
</div>
<div id="save-post-filtering-statistics" class="section level2">
<h2>3.2 Save Post-filtering Statistics</h2>
<p>Save the QC statistics for the filtered dataset.</p>
<pre class="r"><code># Create a list to store QC data
qc_data_after &lt;- list()
for (sample_name in names(samples_filteredQC)) {
  qc_data_after[[sample_name]] &lt;- data.frame(
    Sample       = sample_name,
    Cell_Count   = ncol(samples_filteredQC[[sample_name]]),
    Percent_Mito = mean(samples_filteredQC[[sample_name]]$percent_mito, na.rm = TRUE),
    Percent_Ribo = mean(samples_filteredQC[[sample_name]]$percent_ribo, na.rm = TRUE),
    Percent_Ery  = mean(samples_filteredQC[[sample_name]]$percent_ery, na.rm = TRUE)
  )
}
qc_summary_after &lt;- do.call(rbind, qc_data_after)
write.xlsx(qc_summary_after, file = file.path(result_dir, &quot;3.2_cell_count_postQC.xlsx&quot;), rowNames = FALSE)</code></pre>
</div>
<div id="visualize-post-filtering-qc" class="section level2">
<h2>3.3 Visualize Post-filtering QC</h2>
<p>Visualize QC metrics for the filtered dataset.</p>
<pre class="r"><code>combined_filtered &lt;- Reduce(function(x, y) merge(x, y), samples_filteredQC)
# pdf(file.path(result_dir, &quot;3.3_post_QC_ViolinPlots.pdf&quot;), width = 30, height = 25)
print(VlnPlot(
  combined_filtered, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent_mito&quot;, &quot;percent_ribo&quot;, &quot;percent_ery&quot;), group.by = &quot;sample_id&quot;, pt.size = 0.1, ncol = 2
))
# dev.off()</code></pre>
</div>
<div id="normalization-and-integration" class="section level2">
<h2>4. Normalization and Integration</h2>
<p>Perform SCTransform normalization and integrate datasets using
RPCA.</p>
<pre class="r"><code>### ran on the HPC cluster</code></pre>
</div>
<div id="sctransform" class="section level2">
<h2>4.1 SCTransform</h2>
<p>Normalize data using SCTransform.</p>
<pre class="r"><code>samples_SCT &lt;- lapply(samples_filteredQC, SCTransform, vst.flavor = &quot;v2&quot;, verbose = T) |&gt;
  lapply(RunPCA, npcs = 30, verbose = T)
qsave(samples_SCT, file.path(result_dir, &quot;4.1_samples_SCT.qs&quot;))</code></pre>
</div>
<div id="rpca-integration" class="section level2">
<h2>4.2 RPCA Integration</h2>
<p>Integrate samples using Reciprocal PCA (RPCA).</p>
<pre class="r"><code>features &lt;- SelectIntegrationFeatures(object.list = samples_SCT, nfeatures = 3000)
samples_SCT &lt;- PrepSCTIntegration(samples_SCT, anchor.features = features)
anchors &lt;- FindIntegrationAnchors(samples_SCT, normalization.method = &quot;SCT&quot;,anchor.features = features, reduction = &quot;rpca&quot;)
qsave(anchors, file.path(result_dir, &quot;4.2_integration_anchors_rpca.qs&quot;))
samples_combined &lt;- IntegrateData(anchors, normalization.method = &quot;SCT&quot;) |&gt;
  RunPCA(verbose = T)
qsave(samples_combined, file.path(result_dir, &quot;4.2_samples_combined_rpca.qs&quot;))

# ===== 5. Clustering &amp; marker genes =====</code></pre>
</div>
<div id="clustering-and-marker-genes" class="section level2">
<h2>5. Clustering and Marker Genes</h2>
<p>Cluster cells and identify marker genes for each cluster.</p>
</div>
<div id="clustering-and-umap" class="section level2">
<h2>5.1 Clustering and UMAP</h2>
<p>Perform graph-based clustering and visualize results using UMAP.</p>
<pre class="r"><code>#use Seurat 5.1 (because e.g. Azimuth is not working with Seurat 5.3)
samples_combined &lt;- FindNeighbors(samples_combined, dims = 1:30)
resolution_check &lt;- FindClusters(samples_combined, resolution = c(0.2, 0.4, 0.6, 0.7, 0.8, 1.0, 1.2))
tree &lt;- clustree(resolution_check)
# pdf(&quot;5.1_clusterTree_samples_combined.pdf&quot;, width=18, height=8.27)
tree
# dev.off()
samples_seurat &lt;- FindClusters(samples_combined, resolution = 0.7) #change resolution
samples_seurat &lt;- RunUMAP(samples_seurat, dims = 1:30)
DimPlot(samples_seurat, label = T)
qsave(samples_seurat, file.path(result_dir, &quot;5.1_samples_seurat_res0.7.qs&quot;))

rm(resolution_check, samples_combined, tree)</code></pre>
</div>
<div id="find-marker-genes" class="section level2">
<h2>5.2 Find Marker Genes</h2>
<p>Identify marker genes for each cluster using the SCT assay.</p>
<pre class="r"><code>#Idents(samples_seurat) &lt;- &quot;annotated&quot; #change later if I have decided for annotation
Idents(samples_seurat) &lt;- &quot;seurat_clusters&quot;
samples_seurat &lt;- PrepSCTFindMarkers(samples_seurat)
markers &lt;- FindAllMarkers(samples_seurat, assay = &quot;SCT&quot;, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted &lt;- markers %&gt;%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list &lt;- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = &quot;5.2_Cluster_Markers.xlsx&quot;)

rm(marker_list, markers, markers_sorted)</code></pre>
</div>
<div id="cluster-cell-counts" class="section level2">
<h2>5.3 Cluster Cell Counts</h2>
<p>Calculate and export cell counts and percentages per cluster across
different conditions.</p>
<pre class="r"><code>samples_seurat$annotated &lt;- samples_seurat$seurat_clusters #changed later wiith right annotation --&gt; step.6 and 7
Idents(samples_seurat) &lt;- &quot;annotated&quot;

overall_counts &lt;- table(samples_seurat$annotated)
sample_counts &lt;- table(samples_seurat$annotated, samples_seurat$sample_id)
condition_counts &lt;- table(samples_seurat$annotated, samples_seurat$condition)
cohort_counts &lt;- table(samples_seurat$annotated, samples_seurat$cohort)
biobank_counts &lt;- table(samples_seurat$annotated, samples_seurat$biobank)
diagnosis_counts &lt;- table(samples_seurat$annotated, samples_seurat$diagnosis)

overall_df &lt;- as.data.frame(overall_counts)
colnames(overall_df) &lt;- c(&quot;Cluster&quot;, &quot;Cell_Count&quot;)
sample_df &lt;- as.data.frame.matrix(sample_counts)
sample_df &lt;- cbind(Cluster = rownames(sample_df), sample_df)
condition_df &lt;- as.data.frame.matrix(condition_counts)
condition_df &lt;- cbind(Cluster = rownames(condition_df), condition_df)
cohort_df &lt;- as.data.frame.matrix(cohort_counts)
cohort_df &lt;- cbind(Cluster = rownames(cohort_df), cohort_df)
biobank_df &lt;- as.data.frame.matrix(biobank_counts)
biobank_df &lt;- cbind(Cluster = rownames(biobank_df), biobank_df)
diagnosis_df &lt;- as.data.frame.matrix(diagnosis_counts)
diagnosis_df &lt;- cbind(Cluster = rownames(diagnosis_df), diagnosis_df)

#percentage
calc_column_percent &lt;- function(count_table) {
  percent_matrix &lt;- prop.table(count_table, margin = 2) * 100
  percent_df &lt;- as.data.frame.matrix(round(percent_matrix, 2))
  percent_df &lt;- cbind(Cluster = rownames(percent_df), percent_df)
  return(percent_df)
}

sample_percent_df &lt;- calc_column_percent(sample_counts)
condition_percent_df &lt;- calc_column_percent(condition_counts)
cohort_percent_df &lt;- calc_column_percent(cohort_counts)
biobank_percent_df &lt;- calc_column_percent(biobank_counts)
diagnosis_percent_df &lt;- calc_column_percent(diagnosis_counts)

#save in one excel
write_xlsx(
  list(
    Overall = overall_df,
    By_Sample = sample_df,
    By_Sample_Percent = sample_percent_df,
    By_Condition = condition_df,
    By_Condition_Percent = condition_percent_df,
    By_Cohort = cohort_df,
    By_Cohort_Percent = cohort_percent_df,
    By_Biobank = biobank_df,
    By_Biobank_Percent = biobank_percent_df,
    By_Diagnosis = diagnosis_df,
    By_Diagnosis_Percent = diagnosis_percent_df
  ),
  path = &quot;5.3__Cluster_Cell_Counts.xlsx&quot;
)

#clean enviornment
rm(cohort_df, cohort_percent_df, condition_df, condition_percent_df, overall_df, sample_df, sample_percent_df, cohort_counts, overall_counts, sample_counts, calc_column_percent, biobank_df, biobank_percent_df, biobank_counts, diagnosis_df, diagnosis_percent_df)</code></pre>
</div>
<div id="metadata-processing" class="section level2">
<h2>6. Metadata Processing</h2>
<p>Clean and update sample metadata.</p>
<pre class="r"><code>#three samples had spaces in their samples_ID --&gt; need to be removed
samples_seurat@meta.data$sample_id[samples_seurat@meta.data$sample_id == &quot;M98_H_P9 &quot;] &lt;- &quot;M98_H_P9&quot;
samples_seurat@meta.data$sample_id[samples_seurat@meta.data$sample_id == &quot;C76_H_P9_10 &quot;] &lt;- &quot;C76_H_P9_10&quot;
samples_seurat@meta.data$sample_id[samples_seurat@meta.data$sample_id == &quot;M3509_P10 &quot;] &lt;- &quot;M3509_P10&quot;</code></pre>
</div>
<div id="add-patient-information" class="section level2">
<h2>6.1 Add Patient Information</h2>
<p>Integrate patient-level information (age, sex, condition) into the
single-cell object.</p>
<pre class="r"><code>patient_info &lt;- openxlsx::read.xlsx(&quot;patient_info.xlsx&quot;) #you can use Supplement Figure 1
#add meta.data
meta &lt;- samples_seurat@meta.data
# Add cell name as a new column for subsequent reassignment
meta$cell_id &lt;- rownames(meta)
# Merge `information from `meta` and `patient_info`
meta_new &lt;- left_join(meta, patient_info[, c(&quot;sample_id&quot;, &quot;pool&quot;, &quot;condition&quot;, &quot;dura_regio&quot;, &quot;patient_id&quot;, &quot;biobank&quot;, &quot;sex&quot;, &quot;age&quot;, &quot;pmd_h&quot;, &quot;diagnosis&quot;, &quot;cohort&quot;)], by = c(&quot;sample_id&quot; = &quot;sample_id&quot;))
rownames(meta_new) &lt;- meta$cell_id
#add to seurat_object
samples_seurat@meta.data &lt;- meta_new

samples_seurat@meta.data$condition &lt;- as.factor(samples_seurat@meta.data$condition)
samples_seurat@meta.data$pool &lt;- as.factor(samples_seurat@meta.data$pool)
samples_seurat@meta.data$dura_regio &lt;- as.factor(samples_seurat@meta.data$dura_regio)
samples_seurat@meta.data$patient_id &lt;- as.factor(samples_seurat@meta.data$patient_id)
samples_seurat@meta.data$biobank &lt;- as.factor(samples_seurat@meta.data$biobank)
samples_seurat@meta.data$sex &lt;- as.factor(samples_seurat@meta.data$sex)
samples_seurat@meta.data$age &lt;- as.factor(samples_seurat@meta.data$age)
samples_seurat@meta.data$diagnosis &lt;- as.factor(samples_seurat@meta.data$diagnosis)
samples_seurat@meta.data$cohort &lt;- as.factor(samples_seurat@meta.data$cohort)

rm(meta, meta_new, patient_info)</code></pre>
</div>
<div id="add-cell-annotations" class="section level2">
<h2>6.2 Add Cell Annotations</h2>
<p>Assign biological annotations to clusters based on marker genes.</p>
<pre class="r"><code>samples_seurat$annotated &lt;- recode(samples_seurat$seurat_clusters, &quot;0&quot; = &quot;duraFibro4&quot;, &quot;1&quot; = &quot;duraFibro1&quot;, &quot;2&quot; = &quot;CAM&quot;, &quot;3&quot; = &quot;duraFibro3&quot;, &quot;4&quot; = &quot;vSMC1&quot;, &quot;5&quot; = &quot;capEndo&quot;, &quot;6&quot; = &quot;vascFibro&quot;, &quot;7&quot; = &quot;venEndo&quot;, &quot;8&quot; = &quot;Tc&quot;, &quot;9&quot; = &quot;artEndo&quot;, &quot;10&quot; = &quot;duraFibro7&quot;, &quot;11&quot; = &quot;vSMC2&quot;, &quot;12&quot; = &quot;duraFibro2&quot;, &quot;13&quot; = &quot;Myeloid1&quot;, &quot;14&quot; = &quot;Myeloid5&quot;, &quot;15&quot; = &quot;arach_bordFibro&quot;, &quot;16&quot; = &quot;Peri&quot;, &quot;17&quot; = &quot;Myeloid3&quot;, &quot;18&quot; = &quot;Myeloid2&quot;, &quot;19&quot; = &quot;duraFibro8&quot;, &quot;20&quot; = &quot;duraFibro5&quot;, &quot;21&quot; = &quot;ABC&quot;, &quot;22&quot; = &quot;mixVascStroma&quot;, &quot;23&quot; = &quot;mixEndo&quot;, &quot;24&quot; = &quot;Bc&quot;, &quot;25&quot; = &quot;Myeloid4&quot;, &quot;26&quot; = &quot;Mast&quot;, &quot;27&quot; = &quot;duraFibro6&quot;, &quot;28&quot; = &quot;IFN-CAM&quot;)

samples_seurat$main_groups &lt;- recode(samples_seurat$seurat_clusters, &quot;0&quot; = &quot;duraFibro&quot;, &quot;1&quot; = &quot;duraFibro&quot;, &quot;2&quot; = &quot;Myeloid&quot;, &quot;3&quot; = &quot;duraFibro&quot;, &quot;4&quot; = &quot;vascStroma&quot;, &quot;5&quot; = &quot;Endo&quot;, &quot;6&quot; = &quot;vascStroma&quot;, &quot;7&quot; = &quot;Endo&quot;, &quot;8&quot; = &quot;Tc&quot;, &quot;9&quot; = &quot;Endo&quot;, &quot;10&quot; = &quot;duraFibro&quot;, &quot;11&quot; = &quot;vascStroma&quot;, &quot;12&quot; = &quot;duraFibro&quot;, &quot;13&quot; = &quot;Myeloid&quot;, &quot;14&quot; = &quot;Myeloid&quot;, &quot;15&quot; = &quot;arach_bordFibro&quot;, &quot;16&quot; = &quot;vascStroma&quot;, &quot;17&quot; = &quot;Myeloid&quot;, &quot;18&quot; = &quot;Myeloid&quot;, &quot;19&quot; = &quot;duraFibro&quot;, &quot;20&quot; = &quot;duraFibro&quot;, &quot;21&quot; = &quot;ABC&quot;, &quot;22&quot; = &quot;vascStroma&quot;, &quot;23&quot; = &quot;Endo&quot;, &quot;24&quot; = &quot;Bc&quot;, &quot;25&quot; = &quot;Myeloid&quot;, &quot;26&quot; = &quot;Myeloid&quot;, &quot;27&quot; = &quot;duraFibro&quot;, &quot;28&quot; = &quot;Myeloid&quot;)
cluster_order &lt;- c(&quot;ABC&quot;, &quot;arach_bordFibro&quot;, &quot;duraFibro&quot;, &quot;vascStroma&quot;, &quot;Endo&quot;, &quot;Myeloid&quot;, &quot;Tc&quot;, &quot;Bc&quot;)
samples_seurat@meta.data$main_groups &lt;- factor(samples_seurat@meta.data$main_groups, levels = cluster_order)
Idents(samples_seurat) &lt;- samples_seurat@meta.data$main_groups
Idents(samples_seurat) &lt;- &quot;main_groups&quot;
DefaultAssay(samples_seurat) &lt;- &quot;SCT&quot;</code></pre>
</div>
<div id="define-cluster-colors" class="section level2">
<h2>6.3 Define Cluster Colors</h2>
<p>Define custom color palettes for visualization.</p>
<pre class="r"><code>#extract colors
p &lt;- DimPlot(samples_seurat, group.by = &quot;annotated&quot;)
cluster_colors &lt;- ggplot_build(p)$data[[1]]$colour
cluster_ids &lt;- p$data$annotated
cluster_colors_df &lt;- data.frame(cluster = cluster_ids, color = cluster_colors)
unique_colors &lt;- unique(cluster_colors_df)
unique_colors

#define new colors
cluster_colors &lt;- c(
  &quot;ABC&quot; = &quot;#9584bd&quot;,
  &quot;arach_bordFibro&quot; = &quot;#87be4d&quot;,
  &quot;duraFibro1&quot; = &quot;#38b083&quot;,
  &quot;duraFibro2&quot; = &quot;#5c96d0&quot;,
  &quot;duraFibro3&quot; = &quot;#ee756e&quot;,
  &quot;duraFibro4&quot; = &quot;#d49005&quot;,
  &quot;duraFibro5&quot; = &quot;#828cc5&quot;,
  &quot;duraFibro6&quot; = &quot;#ec67a2&quot;,
  &quot;duraFibro7&quot; = &quot;#3bab4b&quot;,
  &quot;duraFibro8&quot; = &quot;#d88356&quot;,
  &quot;vascFibro&quot; = &quot;#9ea71e&quot;,
  &quot;mixVascStroma&quot; = &quot;#a27eb7&quot;,
  &quot;Peri&quot; = &quot;#06b8e0&quot;,
  &quot;vSMC1&quot; = &quot;#bb4d63&quot;,
  &quot;vSMC2&quot; = &quot;#8e7eb9&quot;,
  &quot;mixEndo&quot; = &quot;#b078b1&quot;,
  &quot;artEndo&quot; = &quot;#3caa34&quot;,
  &quot;capEndo&quot; = &quot;#29aab5&quot;,
  &quot;venEndo&quot; = &quot;#957e25&quot;,
  &quot;Mast&quot; = &quot;#e26aa5&quot;,
  &quot;inflamMono1&quot; = &quot;#36b39c&quot;,
  &quot;inflamMono2&quot; = &quot;#75ae2b&quot;,
  &quot;inflamMono3&quot; = &quot;#12b3e8&quot;,
  &quot;Granulo&quot; = &quot;#cf6ea8&quot;,
  &quot;mixMyeloid&quot; = &quot;#32b6b3&quot;,
  &quot;IFN-CAM&quot; = &quot;#ec67a2&quot;,
  &quot;CAM&quot; = &quot;#e38803&quot;,
  &quot;Bc&quot; = &quot;#bf72ad&quot;,
  &quot;Tc&quot; = &quot;#dd4e10&quot;)


#cluster_color main groups
cluster_colors &lt;- c( &quot;ABC&quot; = &quot;#9584bd&quot;,
                     &quot;arach_bordFibro&quot; = &quot;#87be4d&quot;,
                     &quot;duraFibro&quot; = &quot;#f2cf22&quot;,
                     &quot;vascStroma&quot; = &quot;#00b8df&quot;,
                     &quot;Endo&quot; = &quot;#27a9b5&quot;,
                     &quot;Myeloid&quot; = &quot;#e04c73&quot;,
                     &quot;Bc&quot; = &quot;#bf72ad&quot;,
                     &quot;Tc&quot; = &quot;#dd4e10&quot;)</code></pre>
</div>
<div id="define-cluster-order" class="section level2">
<h2>6.4 Define Cluster Order</h2>
<p>Set the order of clusters for plotting consistency.</p>
<pre class="r"><code>ccluster_order &lt;- c(&quot;artEndo&quot;, &quot;capEndo&quot;, &quot;venEndo&quot;, &quot;mixEndo&quot;, &quot;vSMC1&quot;, &quot;vSMC2&quot;, &quot;Peri&quot;, &quot;mixVascStroma&quot;, &quot;vascFibro&quot;, &quot;Tc&quot;, &quot;Bc&quot;, &quot;CAM&quot;, &quot;IFN-CAM&quot;, &quot;inflamMono1&quot;, &quot;inflamMono2&quot;, &quot;inflamMono3&quot;, &quot;Granulo&quot;, &quot;mixMyeloid&quot;, &quot;Mast&quot;,&quot;ABC&quot;, &quot;arach_bordFibro&quot;, &quot;duraFibro1&quot;, &quot;duraFibro2&quot;, &quot;duraFibro3&quot;, &quot;duraFibro4&quot;, &quot;duraFibro5&quot;, &quot;duraFibro6&quot;, &quot;duraFibro7&quot;, &quot;duraFibro8&quot;)
cluster_order &lt;- rev(cluster_order)
samples_seurat@meta.data$annotated &lt;- factor(samples_seurat@meta.data$annotated, levels = cluster_order)
Idents(samples_seurat) &lt;- samples_seurat@meta.data$annotated

qsave(samples_seurat, file.path(result_dir, &quot;6.4_samples_combined_meta_data.qs&quot;))</code></pre>
</div>
<div id="patient-demographics-age-sex-pmd" class="section level2">
<h2>6.5 Patient Demographics (Age, Sex, PMD)</h2>
<p>Analyze and visualize the distribution of age, sex, and post-mortem
delay (PMD) across conditions.</p>
<pre class="r"><code># Create sample metadata
sample_meta &lt;- samples_seurat@meta.data %&gt;%
  dplyr::select(sample_id, condition, age, sex, pmd_h) %&gt;%
  distinct()

### age ###
# Convert age to numeric (in case it was imported as factor/character)
sample_meta$age &lt;- as.numeric(as.character(sample_meta$age))
# Optional: ensure condition is a factor with correct order
sample_meta$condition &lt;- factor(sample_meta$condition, levels = c(&quot;Ctrl&quot;, &quot;MS&quot;))
# Step 2: Perform t-test
t_test_result &lt;- t.test(age ~ condition, data = sample_meta)
# Step 3: Plot
# pdf(&quot;6.5_age_distribution.pdf&quot;, width = 5, height = 5)
ggplot(sample_meta, aes(x = condition, y = age, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(aes(color = condition), width = 0.15, size = 2, alpha = 0.9) +
  theme_minimal() +
  labs(
    x = NULL,
    y = &quot;age [years]&quot;
  ) +
  scale_fill_manual(values = c(&quot;Ctrl&quot; = &quot;black&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  scale_color_manual(values = c(&quot;Ctrl&quot; = &quot;black&quot;, &quot;MS&quot; = &quot;black&quot;)) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = &quot;black&quot;),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.position = &quot;none&quot;
  ) +
  annotate(
    &quot;text&quot;,
    x = 1.5,
    y = max(sample_meta$age),
    label = paste(&quot;T-test p-value:&quot;, format(t_test_result$p.value, digits = 2)), #scientific = TRUE)
    size = 5,
    color = &quot;black&quot;,
    hjust = 0.5
  )
# dev.off()

### sex ###
sex_counts &lt;- sample_meta %&gt;%
  group_by(condition, sex) %&gt;%
  summarise(count = n(), .groups = &quot;drop&quot;) %&gt;%
  group_by(condition) %&gt;%
  mutate(proportion = count / sum(count))

# pdf(&quot;6.5_sex_distribution.pdf&quot;, width = 4, height = 5)
ggplot(sex_counts, aes(x = condition, y = proportion, fill = sex)) +
  geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = &quot;black&quot;),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.position = &quot;none&quot;
  ) +
  labs(
    title = &quot;Sex Distribution by Condition&quot;,
    x = &quot;Condition&quot;,
    y = &quot;Proportion&quot;,
    fill = &quot;Sex&quot;
  )
# dev.off()

### pmd_h ###
# Convert age to numeric (in case it was imported as factor/character)
sample_meta$pmd_h &lt;- as.numeric(as.character(sample_meta$pmd_h))
# Optional: ensure condition is a factor with correct order
sample_meta$condition &lt;- factor(sample_meta$condition, levels = c(&quot;Ctrl&quot;, &quot;MS&quot;))
# Step 2: Perform t-test
t_test_result &lt;- t.test(pmd_h ~ condition, data = sample_meta)
# Step 3: Plot
# pdf(&quot;6.5_pmd_distribution.pdf&quot;, width = 5, height = 5)
ggplot(sample_meta, aes(x = condition, y = pmd_h, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(aes(color = condition), width = 0.15, size = 2, alpha = 0.9) +
  theme_minimal() +
  labs(
    x = NULL,
    y = &quot;post mortem delay [hours]&quot;
  ) +
  scale_fill_manual(values = c(&quot;Ctrl&quot; = &quot;black&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  scale_color_manual(values = c(&quot;Ctrl&quot; = &quot;black&quot;, &quot;MS&quot; = &quot;black&quot;)) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(color = &quot;black&quot;),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    legend.position = &quot;none&quot;
  ) +
  annotate(
    &quot;text&quot;,
    x = 1.5,
    y = max(sample_meta$pmd_h),
    label = paste(&quot;T-test p-value:&quot;, format(t_test_result$p.value, digits = 2)),
    size = 5,
    color = &quot;black&quot;,
    hjust = 0.5
  )
# dev.off()</code></pre>
</div>
<div id="summary-statistics" class="section level2">
<h2>6.6 Summary Statistics</h2>
<p>Calculate total cells, cells per condition, and average genes per
cell.</p>
<pre class="r"><code>#total cells
ncol(samples_seurat)
#245730

#total cells by condition
table(samples_seurat$condition)
#Ctrl     MS
#125818 119912

#average genes per cell
mean(samples_seurat$nFeature_RNA)
# 796.5089 --&gt; 797

#cells per sample
round(mean(table(samples_seurat$sample_id)))
#10,684</code></pre>
</div>
<div id="cluster-abundance-analysis-confounder-adjusted"
class="section level2">
<h2>7. Cluster Abundance Analysis (Confounder Adjusted)</h2>
<p>Analyze changes in cluster abundance while adjusting for confounding
variables.</p>
</div>
<div id="data-preparation" class="section level2">
<h2>7.1 Data Preparation</h2>
<p>Prepare metadata and count matrices for abundance analysis,
accounting for age, sex, cohort, and pool.</p>
<pre class="r"><code># Extract metadata and ensure all required variables are present
meta_confounders &lt;- samples_seurat@meta.data %&gt;%
  dplyr::select(sample_id, condition, cohort, pool, annotated, age, sex) %&gt;%
  # Remove rows with missing confounder data
  filter(!is.na(age) &amp; !is.na(sex)) %&gt;%
  # Ensure sex is a factor
  mutate(sex = as.factor(sex),
         condition     = as.factor(condition),
         cohort = as.factor(cohort),
         pool = as.factor(pool),
         age = as.numeric(age))

# Create count matrix: samples x cell types
library(tidyr)
count_matrix &lt;- meta_confounders %&gt;%
  group_by(sample_id, annotated) %&gt;%
  summarise(count = n(), .groups = &quot;drop&quot;) %&gt;%
  pivot_wider(names_from = annotated, values_from = count, values_fill = 0) %&gt;%
  column_to_rownames(&quot;sample_id&quot;) %&gt;%
  as.matrix()

# Create sample metadata
sample_meta &lt;- meta_confounders %&gt;%
  dplyr::select(sample_id, condition, cohort, pool, age, sex) %&gt;%
  distinct()
rownames(sample_meta) &lt;- sample_meta$sample_id

# Ensure same sample order
sample_meta &lt;- sample_meta[rownames(count_matrix), ]</code></pre>
</div>
<div id="confounder-adjusted-differential-abundance"
class="section level2">
<h2>7.2 Confounder-Adjusted Differential Abundance</h2>
<p>Run <code>propeller</code> analysis to identify differentially
abundant cell types between MS and Ctrl, adjusting for confounders.</p>
<pre class="r"><code>run_propeller_with_confounders &lt;- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list &lt;- list()

#   pdf(output_file, width = 8, height = 6)

  for (pair in comparisons) {
    group1 &lt;- pair[1]
    group2 &lt;- pair[2]

    cat(paste(&quot;  Analyzing:&quot;, group1, &quot;vs&quot;, group2, &quot;with confounders\n&quot;))

    # Filter to comparison groups
    keep_samples              &lt;- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              &lt;- count_data[keep_samples, , drop = FALSE]
    meta_subset               &lt;- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  &lt;- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str &lt;- paste(&quot;~&quot;, group_var, &quot;+&quot;, paste(confounders, collapse = &quot; + &quot;))
    design_formula &lt;- as.formula(formula_str)
    # design_matrix &lt;- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props &lt;- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit &lt;- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results &lt;- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str &lt;- paste(confounders, collapse = &quot; + &quot;)

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model &lt;- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula &lt;- as.formula(paste(&quot;celltype ~&quot;, group_var, &quot;+&quot;, confounder_str))

        # Fit linear model
        fit &lt;- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name &lt;- paste0(group_var, group1)
        coef_names &lt;- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val &lt;- coef(fit)[coef_name]
          p_val    &lt;- summary(fit)$coefficients[coef_name, &quot;Pr(&gt;|t|)&quot;]

          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- coef_val
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- NA
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- NA
        }
      }

      results$P.Value.Adj &lt;- p.adjust(results$P.Value, method = &quot;BH&quot;)
      results$comparison  &lt;- paste(group1, &quot;vs&quot;, group2, sep = &quot;_&quot;)

      # Store results in list
      results_list[[paste(group1, &quot;vs&quot;, group2)]] &lt;- results

      # Prepare volcano plot dataframe
      volcano_df &lt;- results %&gt;%
        mutate(
          log2_ratio = logFC,
          p.adj = P.Value.Adj,
          neg_log10_p = -log10(p.adj),
          var = CellType
        ) %&gt;%
        dplyr::select(var, log2_ratio, p.adj, neg_log10_p)

      # Volcano plot function
      VolPlot &lt;- function(data) {
        data |&gt;
          ggplot(aes(x = log2_ratio, y = neg_log10_p, color = var, label = var)) +
          geom_point(size = 3) +
          geom_hline(yintercept = -log10(0.05), color = &quot;grey&quot;, linetype = &quot;dashed&quot;) +
          geom_vline(xintercept = 0, color = &quot;grey&quot;, linetype = &quot;dashed&quot;) +
          ggtitle(paste(&quot;Confounder-adjusted: age + sex + cohort + pool&quot;, group1, &quot;vs&quot;, group2)) +
          scale_color_manual(values = cluster_colors) +
          ggrepel::geom_text_repel() +
          theme_classic() +
          theme(legend.position = &quot;none&quot;) +
          xlab(bquote(~ Log[2] ~ &quot;fold change&quot;)) +
          ylab(bquote(~ -Log[10] ~ &quot;adjusted p value&quot;))
      }

      # Print volcano plot
      p &lt;- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste(&quot;Error in analysis for&quot;, group1, &quot;vs&quot;, group2, &quot;:&quot;, e$message, &quot;\n&quot;))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

results_confounders_pms &lt;- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %&gt;% dplyr::select(-sample_id),
  group_var   = &quot;condition&quot;,
  confounders = c(&quot;age&quot;, &quot;sex&quot;, &quot;cohort&quot;, &quot;pool&quot;),
  comparisons = comparisons,
  output_file = file.path(&quot;7.2_confounder_adjusted_propeller.pdf&quot;)
)</code></pre>
</div>
<div id="confounder-adjusted-log2fc-analysis" class="section level2">
<h2>7.3 Confounder-Adjusted Log2FC Analysis</h2>
<p>Perform additional analysis on log2 fold changes, adjusted for
confounders.</p>
<pre class="r"><code>run_propeller_with_confounders &lt;- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list &lt;- list()

#   pdf(output_file, width = 5, height = 5)

  for (pair in comparisons) {
    group1 &lt;- pair[1]
    group2 &lt;- pair[2]

    cat(paste(&quot;  Analyzing:&quot;, group1, &quot;vs&quot;, group2, &quot;with confounders\n&quot;))

    # Filter to comparison groups
    keep_samples              &lt;- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              &lt;- count_data[keep_samples, , drop = FALSE]
    meta_subset               &lt;- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  &lt;- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str &lt;- paste(&quot;~&quot;, group_var, &quot;+&quot;, paste(confounders, collapse = &quot; + &quot;))
    design_formula &lt;- as.formula(formula_str)
    # design_matrix &lt;- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props &lt;- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit &lt;- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results &lt;- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str &lt;- paste(confounders, collapse = &quot; + &quot;)

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model &lt;- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula &lt;- as.formula(paste(&quot;celltype ~&quot;, group_var, &quot;+&quot;, confounder_str))

        # Fit linear model
        fit &lt;- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name &lt;- paste0(group_var, group1)
        coef_names &lt;- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val &lt;- coef(fit)[coef_name]
          p_val    &lt;- summary(fit)$coefficients[coef_name, &quot;Pr(&gt;|t|)&quot;]

          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- coef_val
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- NA
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- NA
        }
      }

      results$P.Value.Adj &lt;- p.adjust(results$P.Value, method = &quot;BH&quot;)
      results$comparison  &lt;- paste(group1, &quot;vs&quot;, group2, sep = &quot;_&quot;)

      # Store results in list
      results_list[[paste(group1, &quot;vs&quot;, group2)]] &lt;- results

      # Prepare volcano plot dataframe
      volcano_df &lt;- results %&gt;%
        mutate(
          log2_ratio = logFC,
          cluster = CellType
        ) %&gt;%
        arrange(log2_ratio) %&gt;%
        mutate(cluster = factor(cluster, levels = cluster))

      # Volcano plot function
      VolPlot &lt;- function(data) {
        ggplot(data, aes(x = log2_ratio, y = cluster, color = cluster)) +
          geom_point(size = 3) +
          geom_vline(xintercept = 0, color = &quot;grey&quot;, linetype = &quot;dashed&quot;) +
          ggtitle(paste(group1, &quot;vs&quot;, group2, &quot;(confounder adjusted)&quot;)) +
          theme_classic() +
          theme(legend.position = &quot;none&quot;) +
          xlab(bquote(~ Log[2] ~ &quot;fold change&quot;)) +
          ylab(&quot;Cluster&quot;) +
          scale_color_manual(values = cluster_colors)
      }

      # Print volcano plot
      p &lt;- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste(&quot;Error in analysis for&quot;, group1, &quot;vs&quot;, group2, &quot;:&quot;, e$message, &quot;\n&quot;))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

results_confounders_pms &lt;- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %&gt;% dplyr::select(-sample_id),
  group_var   = &quot;condition&quot;,
  confounders = c(&quot;sex&quot;, &quot;age&quot;, &quot;cohort&quot;, &quot;pool&quot;),
  comparisons = comparisons,
  output_file = file.path(&quot;7.3_confounder_adjusted_propeller_LogFC_all.pdf&quot;)
)</code></pre>
</div>
<div id="cell-interaction-analysis-nichenet" class="section level2">
<h2>8. Cell Interaction Analysis (NicheNet)</h2>
<p>Predict ligand-receptor interactions between cell types using
NicheNet.</p>
</div>
<div id="nichenet-analysis" class="section level2">
<h2>8.1 NicheNet Analysis</h2>
<p>Perform NicheNet analysis to identify potential intercellular
communication.</p>
<pre class="r"><code>#convert Seurat to single cell experiment and define meta data
sce &lt;- Seurat::as.SingleCellExperiment(samples_seurat, assay = &quot;SCT&quot;)
sce &lt;- alias_to_symbol_SCE(sce, &quot;human&quot;) |&gt; makenames_SCE()

sample_id &lt;- &quot;sample_id&quot;
group_id &lt;- &quot;condition&quot;
celltype_id &lt;- &quot;annotated&quot;
covariates &lt;- NA
batches &lt;- NA

#define organism
organism = &quot;human&quot;

if(organism == &quot;human&quot;){
  lr_network = readRDS(url(&quot;https://zenodo.org/record/7074291/files/lr_network_human_21122021.rds&quot;))
  lr_network = lr_network |&gt; dplyr::rename(ligand = from, receptor = to) |&gt; distinct(ligand, receptor) |&gt; mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url(&quot;https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds&quot;))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |&gt; make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |&gt; make.names()
} else if(organism == &quot;mouse&quot;){
  lr_network = readRDS(url(&quot;https://zenodo.org/record/7074291/files/lr_network_mouse_21122021.rds&quot;))
  lr_network = lr_network |&gt; dplyr::rename(ligand = from, receptor = to) |&gt; distinct(ligand, receptor) |&gt; mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url(&quot;https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds&quot;))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |&gt; make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |&gt; make.names()
}

#change names because _ and dots are not allowed
colData(sce)[, celltype_id] &lt;- factor(gsub(&quot;-&quot;, &quot;_&quot;, colData(sce)[, celltype_id]))
levels(colData(sce)[, celltype_id])

#Sender and receiver cell types need to be defined. Here all cell types in the dataset are used
senders_oi &lt;- SummarizedExperiment::colData(sce)[,celltype_id] |&gt; unique()
receivers_oi &lt;- SummarizedExperiment::colData(sce)[,celltype_id] |&gt; unique()

sce &lt;- sce[, SummarizedExperiment::colData(sce)[,celltype_id] %in% c(senders_oi, receivers_oi)]

min_cells &lt;- 10

abundance_info = get_abundance_info(
  sce = sce,
  sample_id = sample_id,
  group_id = group_id,
  celltype_id = celltype_id,
  min_cells = min_cells,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  batches = batches)

## check for condition-specific cell types
abundance_df_summarized = abundance_info$abundance_data %&gt;% mutate(keep = as.logical(keep)) %&gt;% group_by(group_id, celltype_id) %&gt;% summarise(samples_present = sum((keep)))
celltypes_absent_one_condition = abundance_df_summarized %&gt;% filter(samples_present == 0) %&gt;% pull(celltype_id) %&gt;% unique() # find truly condition-specific cell types by searching for cell types truely absent in at least one condition
celltypes_present_one_condition = abundance_df_summarized %&gt;% filter(samples_present &gt;= 2) %&gt;% pull(celltype_id) %&gt;% unique() # require presence in at least 2 samples of one group so it is really present in at least one condition
condition_specific_celltypes = intersect(celltypes_absent_one_condition, celltypes_present_one_condition)

condition_specific_celltypes_senders = condition_specific_celltypes %&gt;% intersect(senders_oi)
condition_specific_celltypes_receivers = condition_specific_celltypes %&gt;% intersect(receivers_oi)

fraction_cutoff &lt;- 0.05
min_sample_prop &lt;- 0.5
frq_list = get_frac_exprs(sce = sce, sample_id = sample_id, celltype_id =  celltype_id, group_id = group_id, batches = batches, min_cells = min_cells, fraction_cutoff = fraction_cutoff, min_sample_prop = min_sample_prop)

abundance_expression_info &lt;- process_abundance_expression_info(
  sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, min_cells = min_cells,
  senders_oi = union(senders_oi, condition_specific_celltypes_senders),
  receivers_oi = union(receivers_oi, condition_specific_celltypes_receivers),
  lr_network = lr_network, batches = batches, frq_list = frq_list, abundance_info = abundance_info)

#If you compare against two groups, you should divide by 2, if you compare against three groups, you should divide by 3 etcetera
contrasts_oi &lt;- c(&quot;&#39;M-(S+A)/2&#39;,&#39;S-(M+A)/2&#39;,&#39;A-(S+M)/2&#39;&quot;)
#if compare against two groups
contrasts_oi &lt;- c(&quot;&#39;MS-Ctrl&#39;,&#39;Ctrl-MS&#39;&quot;)
contrast_tbl &lt;- tibble(contrast = c(&quot;MS-Ctrl&quot;,&quot;Ctrl-MS&quot;), group = c(&quot;MS&quot;,&quot;Ctrl&quot;))

assay_oi_pb &lt;- &quot;counts&quot;
fun_oi_pb &lt;- &quot;sum&quot;
de_method_oi &lt;- &quot;edgeR&quot;
findMarkers &lt;- FALSE

DE_info = get_DE_info(sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, batches = batches, covariates = covariates, contrasts_oi = contrasts_oi, min_cells = min_cells,
                      assay_oi_pb = assay_oi_pb,
                      fun_oi_pb = fun_oi_pb,
                      de_method_oi = de_method_oi,
                      findMarkers = findMarkers,
                      expressed_df = frq_list$expressed_df)

#check p-value distribution#should be quite straight horizontal line
DE_info$hist_pvals

#if it looks ok, run &quot;empirical_pval == FALSE
empirical_pval = FALSE
#if it looks suboptimal run empirical_pval == TRUE and check quality
empirical_pval = TRUE

if(empirical_pval == TRUE){
  DE_info_emp = get_empirical_pvals(DE_info$celltype_de$de_output_tidy)
}
DE_info_emp$hist_pvals_emp

if(empirical_pval == FALSE){
  celltype_de = DE_info$celltype_de$de_output_tidy
} else {
  celltype_de = DE_info_emp$de_output_tidy_emp %&gt;% dplyr::select(-p_val, -p_adj) %&gt;% dplyr::rename(p_val = p_emp, p_adj = p_adj_emp)
}

sender_receiver_de = combine_sender_receiver_de(
  sender_de = celltype_de,
  receiver_de = celltype_de,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  lr_network = lr_network
)

logFC_threshold = 0.50
p_val_threshold = 0.05
fraction_cutoff = 0.05


# p_val_adj = TRUE #In case of more samples per group + sufficient high number of DE genes per group-celltype (&gt; 20-50), use p_val_adj = TRUE
p_val_adj = T

top_n_target = 400

verbose = TRUE
cores_system = 8
n.cores = min(cores_system, sender_receiver_de$receiver %&gt;% unique() %&gt;% length()) # use one core per receiver cell type

ligand_activities_targets_DEgenes = suppressMessages(suppressWarnings(get_ligand_activities_targets_DEgenes(
  receiver_de = celltype_de,
  receivers_oi = receivers_oi,
  ligand_target_matrix = ligand_target_matrix,
  logFC_threshold = logFC_threshold,
  p_val_threshold = p_val_threshold,
  p_val_adj = T,
  top_n_target = top_n_target,
  verbose = T,
  n.cores = n.cores
)))

prioritizing_weights_DE = c(&quot;de_ligand&quot; = 1,
                            &quot;de_receptor&quot; = 1)
prioritizing_weights_activity = c(&quot;activity_scaled&quot; = 2)

prioritizing_weights_expression_specificity = c(&quot;exprs_ligand&quot; = 2,
                                                &quot;exprs_receptor&quot; = 2)

prioritizing_weights_expression_sufficiency = c(&quot;frac_exprs_ligand_receptor&quot; = 1)

prioritizing_weights_relative_abundance = c( &quot;abund_sender&quot; = 0,
                                             &quot;abund_receiver&quot; = 0)

prioritizing_weights = c(prioritizing_weights_DE,
                         prioritizing_weights_activity,
                         prioritizing_weights_expression_specificity,
                         prioritizing_weights_expression_sufficiency,
                         prioritizing_weights_relative_abundance)

sender_receiver_tbl = sender_receiver_de |&gt; dplyr::distinct(sender, receiver)

metadata_combined = SummarizedExperiment::colData(sce) |&gt; tibble::as_tibble()

if(!is.na(batches)){
  grouping_tbl = metadata_combined[,c(sample_id, group_id, batches)] |&gt; tibble::as_tibble() |&gt; dplyr::distinct()
  colnames(grouping_tbl) = c(&quot;sample&quot;,&quot;group&quot;,batches)
} else {
  grouping_tbl = metadata_combined[,c(sample_id, group_id)] |&gt; tibble::as_tibble() |&gt; dplyr::distinct()
  colnames(grouping_tbl) = c(&quot;sample&quot;,&quot;group&quot;)
}

scenario &lt;- &quot;regular&quot; # all prioritization criteria will be weighted equally
ligand_activity_down &lt;- FALSE # use only upregulatory ligand activities to prioritize

prioritization_tables = suppressMessages(generate_prioritization_tables(
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de = sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  contrast_tbl = contrast_tbl,
  sender_receiver_tbl = sender_receiver_tbl,
  grouping_tbl = grouping_tbl,
  scenario = scenario,
  fraction_cutoff = fraction_cutoff,
  abundance_data_receiver = abundance_expression_info$abundance_data_receiver,
  abundance_data_sender = abundance_expression_info$abundance_data_sender,
  ligand_activity_down = ligand_activity_down
))

lr_target_prior_cor = lr_target_prior_cor_inference(prioritization_tables$group_prioritization_tbl$receiver |&gt; unique(), abundance_expression_info, celltype_de, grouping_tbl, prioritization_tables, ligand_target_matrix, logFC_threshold = logFC_threshold, p_val_threshold = p_val_threshold, p_val_adj = p_val_adj)

#save previous calculations as one large list
multinichenet_output = list(
  celltype_info = abundance_expression_info$celltype_info,
  celltype_de = celltype_de,
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de =  sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  prioritization_tables = prioritization_tables,
  grouping_tbl = grouping_tbl,
  lr_target_prior_cor = lr_target_prior_cor
)
multinichenet_output = make_lite_output(multinichenet_output)

saveRDS(multinichenet_output, file = &quot;8.1_multinichenet.rds&quot;)</code></pre>
</div>
<div id="circos-plot-visualization" class="section level2">
<h2>8.2 Circos Plot Visualization</h2>
<p>Visualize ligand-receptor interactions using Circos plots.</p>
<pre class="r"><code>#create plot for the top100 predictions
prioritized_tbl_oi_all = get_top_n_lr_pairs(multinichenet_output$prioritization_tables, 100, rank_per_group = FALSE)

prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %&gt;%
  filter(id %in% prioritized_tbl_oi_all$id) %&gt;%
  distinct(id, sender, receiver, ligand, receptor, group) %&gt;% left_join(prioritized_tbl_oi_all)
prioritized_tbl_oi$prioritization_score[is.na(prioritized_tbl_oi$prioritization_score)] = 0

senders_receivers = union(prioritized_tbl_oi$sender %&gt;% unique(), prioritized_tbl_oi$receiver %&gt;% unique()) %&gt;% sort()

colors_sender &lt;- cluster_colors[senders_receivers]
colors_receiver &lt;- cluster_colors[senders_receivers]

library(scales)

# pdf(&quot;8.2_top100_circos_plot_newcolor.pdf&quot;, width = 10, height = 10)
circos_list = make_circos_group_comparison(prioritized_tbl_oi, colors_sender, colors_receiver)
# dev.off()

#split bei receiver
# Open multi-page PDF
# pdf(&quot;8.2_circos_split_by_receiver.pdf&quot;, width = 10, height = 10)

unique_receivers &lt;- sort(unique(prioritized_tbl_oi$receiver))

for(receiver in unique_receivers) {

  # Subset top interactions for this receiver
  subset_tbl &lt;- prioritized_tbl_oi %&gt;% filter(receiver == !!receiver)
  if(nrow(subset_tbl) == 0) next

  # Create circos object
  circos_list &lt;- make_circos_group_comparison(subset_tbl, colors_sender, colors_receiver)

  circos.clear()
  circos.par(gap.degree = 5)

  # Initialize sectors
  cell_types &lt;- circos_list$cell_types
  xlim_list &lt;- lapply(cell_types, function(x) c(0,1))
  names(xlim_list) &lt;- cell_types
  for(sector in cell_types){
    circos.initialize(factors = sector, xlim = xlim_list[[sector]])
  }

  # Draw arcs and labels
  cell_colors &lt;- circos_list$colors
  for(sector in cell_types){
    circos.trackPlotRegion(factors = sector, y = c(0,1),
                           bg.col = cell_colors[sector], bg.border = NA,
                           panel.fun = function(x, y){
                             circos.text(CELL_META$xcenter, CELL_META$ycenter,
                                         CELL_META$sector.index,
                                         facing = &quot;clockwise&quot;, niceFacing = TRUE, cex = 0.8)
                           })
  }

  # Draw links
  if(!is.null(circos_list$links) &amp;&amp; nrow(circos_list$links) &gt; 0){
    for(i in seq_len(nrow(circos_list$links))){
      link &lt;- circos_list$links[i, ]
      circos.link(sector.index1 = link$sender, point1 = 0.5,
                  sector.index2 = link$receiver, point2 = 0.5,
                  col = rgb(0,0,0,0.3), border = NA)
    }
  }

  # Each iteration creates a **new page** in the PDF
}

# Close PDF device
# dev.off()

rm(abundance_df_summarized, abundance_expression_info, abundance_info, celltype_de, circos_list, contrast_tbl, de_genes_summary, DE_info, DE_info_emp, frq_list, grouping_tbl, ligand_activities_df, ligand_activities_targets_DEgenes, ligand_activity_summary, ligand_activity_down, ligand_target_matrix, ligand_target_matrix_test, lr_network, lr_target_prior_cor, metadata_combined, multinichenet_output, prioritization_tables, prioritized_tbl_oi, prioritized_tbl_oi_all, sce, sender_receiver_de, sender_receiver_tbl, subset_tbl, summary_ctrl, xlim_list, xlim_matrix, assay_oi_pb, batches, cell_colors, cell_types, celltype_id, celltypes_absent_one_condition, celltypes_present_one_condition, circos_text_y, colors_receiver, colors_sender, condition_specific_celltypes, condition_specific_celltypes_receivers, condition_specific_celltypes_senders, contrasts_oi, cores_system, covariates, de_method_oi, empirical_pval, findMarkers, fraction_cutoff, fun_oi_pb, group_id, ligand_activities_df, logFC_threshold, min_cells, min_sample_prop, n, n.cores, organism, p_val_adj, p_val_threshold, prioritizing_weights, prioritizing_weights_activity, prioritizing_weights_DE, prioritizing_weights_expression_specificity, prioritizing_weights_expression_specificity, prioritizing_weights_expression_sufficiency, receiver, receivers_oi, sample_id, scenario, sector, senario, senders_oi, senders_receivers, senders_receivers_missing, top_n_target, unique_receivers, verbose, circos_plot, prioritizing_weights_relative_abundance)</code></pre>
</div>
<div id="reference-dataset-comparison" class="section level2">
<h2>9. Reference Dataset Comparison</h2>
<p>Compare the current dataset with published reference datasets.</p>
<pre class="r"><code>#prepare human dura data
#save UMAP reduction (same UMAP as for previous analysis)
umap_reduction &lt;- Embeddings(samples_seurat, &quot;umap&quot;)
samples_seurat &lt;- RunUMAP(
  samples_seurat,
  reduction = &quot;pca&quot;,
  dims = 1:30,
  return.model = TRUE,  # store model for MapQuery
  umap.method = &quot;umap-learn&quot;
)
samples_seurat[[&quot;umap&quot;]]@cell.embeddings &lt;- umap_reduction

#load reference datasets
#bran &lt;- Garcia
#liver &lt;- Tallulah/Andrews
#stromal &lt;- Hickey
#lung &lt;- Qian
# skin &lt;- Deng

#rename
fibros &lt;- brain # Garcia
fibros &lt;- liver #Tallulah/Andrews
fibros &lt;- stromal #Hickey
fibros &lt;- lung #Qian
fibros &lt;- skin #deng

#refPlots
Idents(samples_seurat) &lt;- &quot;main_groups&quot;
anchors &lt;- FindTransferAnchors(reference = samples_seurat, query = fibros, dims = 1:30, reference.reduction = &quot;pca&quot;,normalization.method = &quot;SCT&quot;, reference.assay = &quot;integrated&quot;)
predictions &lt;- TransferData(anchorset = anchors, refdata = samples_seurat$main_groups,dims = 1:30)
fibros &lt;- AddMetaData(fibros, metadata = predictions)

Idents(fibros) &lt;- &quot;predicted.id&quot;
Cell_num &lt;- data.frame(predicted.id = fibros@meta.data$predicted.id)
Cell_num &lt;- Cell_num |&gt;
  group_by(predicted.id) |&gt;
  summarise(Nb = n(), .groups = &quot;drop&quot;) |&gt;
  mutate(
    C = sum(Nb),
    percent = Nb / C * 100
  )

#plots references
p2 &lt;- ggplot(Cell_num, aes(x = &quot;Garcia - brain&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)

p3 &lt;- ggplot(Cell_num, aes(x = &quot;Andrews - liver&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)

p4 &lt;- ggplot(Cell_num, aes(x = &quot;Hickey - colon&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)

p5 &lt;- ggplot(Cell_num, aes(x = &quot;Qian - lung&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)

p6 &lt;- ggplot(Cell_num, aes(x = &quot;Deng - skin&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)


#Smyth --&gt; mouse dataset --&gt; convert to human genes
Lepto.Fibro &lt;- Lepto.combined #load Smyth data

#convert into human genes
library(dplyr)
library(nichenetr)
data &lt;- as(as.matrix(GetAssayData(Lepto.Fibro, assay = &quot;SCT&quot;)), &#39;sparseMatrix&#39;)#normalized data
pd &lt;- data.frame(Lepto.Fibro@meta.data)
pData &lt;- pd %&gt;% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, seurat_clusters) #choose metadata
convert &lt;- convert_mouse_to_human_symbols(rownames(data)) #convert mouse to human
rownames(data) &lt;- make.names(convert, unique = T)
fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data)) #integrate human genes
Lepto.Fibro_human &lt;- CreateSeuratObject(data, project = &quot;leptomeninges&quot;, meta.data = pData, assay = &quot;SCT&quot;) #choose pd instead of pData if you need all metadata)
#plot to human dura
Idents(samples_seurat) &lt;- &quot;main_groups&quot;
anchors &lt;- FindTransferAnchors(reference = samples_seurat, query = Lepto.Fibro_human, dims = 1:30, reference.reduction = &quot;pca&quot;,normalization.method = &quot;SCT&quot;, reference.assay = &quot;integrated&quot;)
predictions &lt;- TransferData(anchorset = anchors, refdata = samples_seurat$main_groups,dims = 1:30)
Lepto.Fibro_human &lt;- AddMetaData(Lepto.Fibro_human, metadata = predictions)

Idents(Lepto.Fibro_human) &lt;- &quot;predicted.id&quot;
Cell_num &lt;- data.frame(predicted.id = Lepto.Fibro_human@meta.data$predicted.id)
Cell_num &lt;- Cell_num |&gt;
  group_by(predicted.id) |&gt;
  summarise(Nb = n(), .groups = &quot;drop&quot;) |&gt;
  mutate(
    C = sum(Nb),
    percent = Nb / C * 100
  )


p7 &lt;- ggplot(Cell_num, aes(x = &quot;Smyth - leptomeninges&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) + theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)

#my dura sample
Cell_num &lt;- data.frame(predicted.id = samples_seurat@meta.data$main_groups)
Cell_num &lt;- Cell_num |&gt;
  group_by(predicted.id) |&gt;
  summarise(Nb = n(), .groups = &quot;drop&quot;) |&gt;
  mutate(
    C = sum(Nb),
    percent = Nb / C * 100
  )
p1 &lt;- ggplot(Cell_num, aes(x = &quot;dura&quot;, y = percent, fill = predicted.id))+
  geom_bar(stat = &quot;identity&quot;) + theme_classic(base_size = 14) +
  theme(
    axis.line = element_line(color = &quot;black&quot;, linewidth = 0.8),
    axis.text = element_text(color = &quot;black&quot;),
    axis.ticks = element_line(color = &quot;black&quot;),
    axis.title = element_text(color = &quot;black&quot;)
  ) + scale_fill_manual(values = cluster_colors)


#save plots
p &lt;- p1 + p7 + p2 + p6 + p5 + p3 + p4 + plot_layout(nrow = 1)
print(last_plot()) # ggsave(file.path(result_dir, &quot;9.0_stacked_barplots_references_allcells.pdf&quot;), p , width = 23, height = 5)

#refUMAP
#prepare human dura data
#save UMAP reduction (same UMAP as for previous analysis)
umap_reduction &lt;- Embeddings(samples_seurat, &quot;umap&quot;)
samples_seurat &lt;- RunUMAP(
  samples_seurat,
  reduction = &quot;pca&quot;,
  dims = 1:30,
  return.model = TRUE,  # store model for MapQuery
  umap.method = &quot;umap-learn&quot;
)
samples_seurat[[&quot;umap&quot;]]@cell.embeddings &lt;- umap_reduction

#refUMAP prediction
fibros &lt;- MapQuery(anchorset = anchors, reference = samples_seurat, query = fibros,refdata = list(celltype = &quot;main_groups&quot;), reference.reduction = &quot;pca&quot;, reduction.model = &quot;umap&quot;)
Idents(samples_seurat) &lt;- &quot;main_groups&quot;
U1 &lt;- DimPlot(samples_seurat, reduction = &quot;umap&quot;, group.by = &quot;main_groups&quot;, label.size = 3, repel = TRUE, cols = cluster_colors) +
  NoLegend() + ggtitle(&quot;human Dura&quot;) + ylim(-19,19) + xlim(-10, +15)
U2 &lt;- FeaturePlot(fibros, features = &quot;predicted.celltype.score&quot;, reduction = &quot;ref.umap&quot;, repel = T) +
  ylim(-19,19) + xlim(-10, +15)

# pdf(&quot;9.0_DimPlot_ref_Plot_all_cells_pred.pdf&quot;, width = 8, height = 5)
U1 + U2
# dev.off()</code></pre>
</div>
<div id="endothelial-trajectory-analysis" class="section level2">
<h2>10. Endothelial Trajectory Analysis</h2>
<p>Analyze the developmental trajectory of endothelial cells.</p>
<pre class="r"><code>Endos_combined &lt;- subset(samples_seurat, idents = c(&quot;artEndo&quot;, &quot;capEndo&quot;, &quot;venEndo&quot;, &quot;mixEndo&quot;))

#convert Seurat object into Monocle object
#integrated and SCT (slot = &quot;scale.data&quot;) do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don&#39;t use scale.data
data &lt;- as(as.matrix(GetAssayData(Endos_combined, assay = &quot;RNA&quot;, slot = &quot;counts&quot;)), &#39;sparseMatrix&#39;)
pd &lt;- data.frame(Endos_combined@meta.data)
pData &lt;- pd %&gt;% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

Endo_monocle &lt;- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(Endo_monocle)$gene_short_name &lt;- rownames(fData(Endo_monocle))
recreate.partitions &lt;- c(rep(1, length(Endo_monocle@colData@rownames)))
names(recreate.partitions) &lt;- Endo_monocle@colData@rownames
recreate.partitions &lt;- as.factor(recreate.partitions)
recreate.partitions
Endo_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;partitions&quot;]] &lt;- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster &lt;- Endos_combined@active.ident
Endo_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;clusters&quot;]] &lt;- list.cluster
Endo_monocle@int_colData@listData[[&quot;reducedDims&quot;]]@listData[[&quot;UMAP&quot;]] &lt;- Endos_combined@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object

cluster_colors &lt;- c(&quot;#19B700&quot;, &quot;#26aab5&quot;, &quot;#957e26&quot;, &quot;#E46DF6&quot;)
cluster.before.traj &lt;- plot_cells(Endo_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = &quot;right&quot;) +  scale_color_manual(values = cluster_colors)

#let it calculate trajectory
#Endo_monocle &lt;- learn_graph(Endo_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
Endo_monocle &lt;- learn_graph(Endo_monocle, use_partition = F, verbose = T, close_loop = F)

#plot trajectory into UMAP
# pdf(&quot;10.0_Endo_traj_plot.pdf&quot;, width = 6, height = 5)
plot_cells(Endo_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
Endo_monocle &lt;- order_cells(Endo_monocle, reduction_method = &quot;UMAP&quot;, root_cells = colnames(Endo_monocle[, clusters(Endo_monocle) == 5]))
#if this Error appears &quot;Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds&quot;, leave root_cells = NULL to manually select starting point
Endo_monocle &lt;- order_cells(Endo_monocle, reduction_method = &quot;UMAP&quot;, root_cells = NULL)

# pdf(&quot;10.0_Endo_traj_plot_UMAP_pseudotime.pdf&quot;, width = 6, height = 5)
plot_cells(Endo_monocle, color_cells_by = &quot;pseudotime&quot;, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
Endo_monocle$monocle3_pseudotime &lt;- pseudotime(Endo_monocle)
qsave(Endo_monocle, &quot;10.0_Endo_traj_pseudotime.qs&quot;)
data.pseudo &lt;- as.data.frame(colData(Endo_monocle))

# pdf(&quot;10.0_Endo_traj_pseudotime.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab(&quot;&quot;)
# dev.off()
#or alternatively order by pseudotime
# pdf(&quot;10.0_Endo_traj_pseudotime_order.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab(&quot;pseudotime&quot;) + ylab(&quot;&quot;)
# dev.off()

#find genes that change in pseudotime
deg &lt;- graph_test(Endo_monocle, neighbor_graph = &quot;principal_graph&quot;)
deg |&gt; arrange(q_value, desc(morans_I)) |&gt; filter(status == &quot;OK&quot;) |&gt; head()


#deg gene list can be looked at and saved
#Moran&#39;s value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, &quot;10.0_Endos_monocle_DEG.xlsx&quot;)

#one can also save pseudotime values into Seurat object and then plot for
Endos_combined$pseudotime &lt;- pseudotime(Endo_monocle)
# pdf(&quot;10.0_Endo_FP_pseudotime.pdf&quot;, width = 8, height = 5)
FeaturePlot(Endos_combined, features = &quot;pseudotime&quot;)
# dev.off()

#one can do multiple expression plots with certain identified genes
RidgePlot(Endos_combined, features = c(&quot;VIM&quot;, &quot;ARL15&quot;, &quot;FBLN2&quot;), sort = F, cols = cluster_colors)

#or also
my_genes &lt;- row.names(subset(fData(Endo_monocle), gene_short_name %in% c(&quot;VIM&quot;, &quot;ARL15&quot;, &quot;NR4A1&quot;, &quot;GJA5&quot;, &quot;FTL1&quot;, &quot;IL1R1&quot;)))
#arterial
my_genes &lt;- row.names(subset(fData(Endo_monocle), gene_short_name %in% c(&quot;ARL15&quot;, &quot;PLCB4&quot;, &quot;TMTC1&quot;, &quot;VEGFC&quot;)))
#capillary
my_genes &lt;- row.names(subset(fData(Endo_monocle), gene_short_name %in% c(&quot;APOLD1&quot;, &quot;FLT1&quot;, &quot;STC1&quot;, &quot;INSR&quot;)))
#venous
my_genes &lt;- row.names(subset(fData(Endo_monocle), gene_short_name %in% c(&quot;FABP4&quot;, &quot;IL1R1&quot;, &quot;LRRC1&quot;, &quot;VWF&quot;)))

#or load in list
Genes &lt;- unlist(read_csv(&quot;Genes to Plot.txt&quot;, col_names = FALSE))

my_genes &lt;- row.names(subset(fData(Endo_monocle), gene_short_name %in% c(Genes)))
Endo_monocle_subset &lt;- Endo_monocle[my_genes,]
plot_genes_in_pseudotime(Endo_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
#or
# pdf(&quot;10.0_Endo_traj_genes_venous.pdf&quot;, width = 5, height = 4)
plot_genes_in_pseudotime(Endo_monocle_subset, color_cells_by = &quot;annotated&quot; ) + scale_color_manual(values = cluster_colors)
# dev.off()


#plot top5 genes that change over pseudotime in each cluster
deg_sig &lt;- deg %&gt;% filter(q_value &lt; 0.05, status == &quot;OK&quot;)

deg_sig$cluster &lt;- Endo_monocle$annotated[ match(deg_sig$gene_short_name,
                                                 rownames(Endo_monocle)) ]

top5_per_cluster &lt;- deg_sig %&gt;%
  group_by(cluster) %&gt;%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot &lt;- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf(&quot;10.0_Endo_top5_per_cluster_genes_pseudotime.pdf&quot;, width = 5, height = 15)

plot_genes_in_pseudotime(
  Endo_monocle[genes_to_plot, ],
  color_cells_by = &quot;annotated&quot;,
  min_expr = 0.1
) + scale_color_manual(values = cluster_colors)

# dev.off()</code></pre>
</div>
<div id="b-cell-bc-analysis" class="section level2">
<h2>11. B-cell (Bc) Analysis</h2>
<p>Perform detailed analysis of B-cells, including reclustering, marker
identification, differential expression, and trajectory analysis.</p>
<div id="b-cell-subset-and-reclustering" class="section level3">
<h3>11.0 B-cell Subset and Reclustering</h3>
<p>Isolate B-cells, re-integrate data (handling small samples
separately), and perform clustering.</p>
<pre class="r"><code>#Bc subset and new integration ####
#### subset Bc cluster ####
Bc_subset &lt;- subset(samples_seurat, idents = c(&quot;Bc&quot;))
Bc_subset@assays$integrated &lt;- NULL
Bc_subset@assays$SCT &lt;- NULL

qs::qsave(Bc_subset, file.path(result_dir, &quot;11.0_Bc_subset.qs&quot;))

#### cut off min 50 cells per sample ####
# split by sample
DefaultAssay(Bc_subset) &lt;- &quot;RNA&quot;
Bc_list &lt;- SplitObject(Bc_subset, split.by = &quot;sample_id&quot;)
qs::qsave(Bc_list, file.path(result_dir, &quot;11.0_Bc_list.qs&quot;))

Bc_list_cutoff &lt;- Bc_list[sapply(Bc_list, ncol) &gt; 50] #cut_off 50

qs::qsave(Bc_list_cutoff, file.path(result_dir, &quot;11.0_Bc_list_cutoff50.qs&quot;))

#### new integration wih 12 samples (&gt; 50 cells) ####
# SCTransform per sample
Bc_list_cutoff &lt;- lapply(Bc_list_cutoff, function(x) {
  SCTransform(x, vst.flavor = &quot;v2&quot;, verbose = TRUE)
})

# Select integration features
features &lt;- SelectIntegrationFeatures(Bc_list_cutoff, nfeatures = 3000)

# Prepare SCT integration (computes residuals etc.)
Bc_list_SCT &lt;- PrepSCTIntegration(Bc_list_cutoff, anchor.features = features)

# Find anchors
anchors &lt;- FindIntegrationAnchors(object.list = Bc_list_SCT,
                                  normalization.method = &quot;SCT&quot;,
                                  anchor.features = features,
                                  dims = 1:30)

# Integrate
Bc_combined &lt;- IntegrateData(anchorset = anchors,
                             normalization.method = &quot;SCT&quot;, k.weight = 53)

Bc_combined &lt;- RunPCA(Bc_combined, verbose = TRUE)
Bc_combined &lt;- RunUMAP(Bc_combined, dims = 1:30)
Bc_combined &lt;- FindNeighbors(Bc_combined, dims = 1:30)

qs::qsave(Bc_combined, file.path(result_dir, &quot;11.0_Bc_combined.qs&quot;))

resolution_check &lt;- FindClusters(Bc_combined, resolution = c(0.2, 0.4, 0.6, 0.7, 0.8, 1.0, 1.2))
tree &lt;- clustree(resolution_check)

Bc_seurat &lt;- FindClusters(Bc_combined, resolution = 0.6) #change

qs::qsave(Bc_all_seurat, file.path(result_dir, &quot;11.0_Bc_all_seurat_cutoff50_res0.6.qs&quot;))

# pdf(&quot;11.0_DimPlot.pdf&quot;, width = 5, height = 5)
DimPlot(Bc_seurat, label = T)
# dev.off()

# pdf(&quot;11.0_DimPlot_condition.pdf&quot;, width = 8, height = 5)
DimPlot(Bc_seurat, label = T, split.by = &quot;condition&quot;)
# dev.off()

# pdf(&quot;11.0_DimPlot_samples.pdf&quot;, width = 22, height = 20)
DimPlot(Bc_seurat, label = T, split.by = &quot;sample_id&quot;, ncol = 5)
# dev.off()

# pdf(&quot;11.0_DimPlot_condition_group.pdf&quot;, width = 5, height = 5)
DimPlot(Bc_seurat, group.by = &quot;condition&quot;)
# dev.off()

# pdf(&quot;11.0_DimPlot_samples_group.pdf&quot;, width = 5, height = 5)
DimPlot(Bc_seurat, group.by = &quot;sample_id&quot;)
# dev.off()

#### Prepare backbone (already integrated and clustered of samples with &gt; 50 cells) ####
Bc_seurat &lt;- qread(&quot;11.0_Bc_seurat_cutoff50_res0.6.qs&quot;)
# Ensure UMAP model exists for mapping
if (!&quot;umap&quot; %in% names(Bc_seurat@reductions)) {
  Bc_seurat &lt;- RunUMAP(
    Bc_seurat, dims = 1:30, reduction = &quot;pca&quot;,
    return.model = TRUE
  )
}
if (is.null(Bc_seurat@reductions$umap@misc$model)) {
  Bc_seurat &lt;- RunUMAP(
    Bc_seurat, dims = 1:30, reduction = &quot;pca&quot;,
    return.model = TRUE
  )
}

#### prepare samples with &lt;50 cells ####
# Load all B cells
Bc_list &lt;- qread(&quot;11.0_Bc_list.qs&quot;)
# Split small samples (&lt;50 cells)
Bc_list_smaller50 &lt;- Bc_list[sapply(Bc_list, ncol) &lt; 50]
# Merge small samples (I had to merge them, otherwise the integration would not have worked for samples with 15 cells)
Bc_smaller50_merged &lt;- merge(Bc_list_smaller50[[1]], y = Bc_list_smaller50[-1])
# SCT normalize small samples
DefaultAssay(Bc_smaller50_merged) &lt;- &quot;RNA&quot;
Bc_smaller50_merged &lt;- SCTransform(Bc_smaller50_merged, vst.flavor = &quot;v2&quot;, verbose = TRUE)

qs::qsave(Bc_smaller50_merged, file.path(result_dir, &quot;11.0_Bc_smaller50_merged.qs&quot;))

# map remaining samples (with &lt;50 cells) into the &quot;backbone&quot; ####
# Find anchors and transfer clusters
anchors &lt;- FindTransferAnchors(
  reference = Bc_seurat,
  query = Bc_smaller50_merged,
  dims = 1:30,
  reference.reduction = &quot;pca&quot;,
  normalization.method = &quot;SCT&quot;,
  reference.assay = &quot;integrated&quot;
)

predictions &lt;- TransferData(
  anchorset = anchors,
  refdata = Bc_seurat$seurat_clusters,
  dims = 1:30
)

# Add predicted clusters to small samples
Bc_smaller50_merged$predicted_clusters &lt;- predictions$predicted.id

# Map small cells to UMAP
mapped &lt;- MapQuery(
  anchorset = anchors,
  query = Bc_smaller50_merged,
  reference = Bc_seurat,
  refdata = Bc_seurat$seurat_clusters,
  reduction.model = &quot;umap&quot;
)

# pdf(&quot;11.01_Bc_onlymapped.pdf&quot;, width = 5, height = 5)
DimPlot(mapped, label = T)
# dev.off()

#Prepare SCT assays for merging
Bc_seurat_sct &lt;- subset(Bc_seurat, features = rownames(Bc_seurat[[&quot;SCT&quot;]]))
Bc_smaller50_merged_sct &lt;- subset(Bc_smaller50_merged, features = rownames(Bc_smaller50_merged[[&quot;SCT&quot;]]))

Bc_seurat_sct@assays &lt;- list(SCT = Bc_seurat[[&quot;SCT&quot;]])
Bc_smaller50_merged_sct@assays &lt;- list(SCT = Bc_smaller50_merged[[&quot;SCT&quot;]])

DefaultAssay(Bc_seurat_sct) &lt;- &quot;SCT&quot;
DefaultAssay(Bc_smaller50_merged_sct) &lt;- &quot;SCT&quot;

# add reduction information
Bc_smaller50_merged_sct@reductions$umap &lt;- mapped@reductions$ref.umap
Bc_smaller50_merged_sct$seurat_clusters &lt;- Bc_smaller50_merged_sct$predicted_clusters

#merge samples
Bc_all &lt;- merge(
  x = Bc_seurat_sct,
  y = Bc_smaller50_merged_sct
)

DefaultAssay(Bc_all) &lt;- &quot;SCT&quot;

umap_combined &lt;- rbind(
  Embeddings(Bc_seurat_sct, &quot;umap&quot;),
  Embeddings(Bc_smaller50_merged_sct, &quot;umap&quot;)
)

rownames(umap_combined) &lt;- colnames(Bc_all)

Bc_all[[&quot;umap&quot;]] &lt;- CreateDimReducObject(
  embeddings = umap_combined,
  key = &quot;UMAP_&quot;,
  assay = &quot;SCT&quot;
)

qs::qsave(Bc_all, file.path(result_dir, &quot;11.0_Bc_all_mapped.qs&quot;))

Bc_all_seurat &lt;- Bc_all
Bc_all_seurat &lt;- qread(&quot;11.0_Bc_all_mapped.qs&quot;)


# pdf(&quot;11.01_DimPlot_Bc_all.pdf&quot;, width = 5, height = 5)
DimPlot(Bc_all_seurat, label = T)
# dev.off()

# pdf(&quot;11.01_DimPlot_condition_Bc_all.pdf&quot;, width = 8, height = 5)
DimPlot(Bc_all_seurat, label = T, split.by = &quot;condition&quot;)
# dev.off()

# pdf(&quot;11.01_DimPlot_samples_Bc_all.pdf&quot;, width = 22, height = 20)
DimPlot(Bc_all_seurat, label = T, split.by = &quot;sample_id&quot;, ncol = 5)
# dev.off()

# pdf(&quot;11.01_DimPlot_condition_group_Bc_all.pdf&quot;, width = 5, height = 5)
DimPlot(Bc_all_seurat, group.by = &quot;condition&quot;)
# dev.off()

# pdf(&quot;11.01_DimPlot_samples_group_Bc_all.pdf&quot;, width = 5, height = 5)
DimPlot(Bc_all_seurat, group.by = &quot;sample_id&quot;)
# dev.off()</code></pre>
</div>
<div id="marker-gene-identification" class="section level3">
<h3>11.1 Marker Gene Identification</h3>
<p>Identify marker genes for B-cell clusters.</p>
<pre class="r"><code>Idents(Bc_all_seurat) &lt;- &quot;seurat_clusters&quot;
DefaultAssay(Bc_all_seurat) &lt;- &quot;SCT&quot;

# Fix umi.assay across all SCT models (works in v4 and v5)
#https://github.com/satijalab/seurat/issues/8515
#https://github.com/satijalab/seurat/issues/9725
if (&quot;SCT&quot; %in% names(Bc_all_seurat@assays)) {
  sct_models &lt;- Bc_all_seurat@assays$SCT@SCTModel.list
  for (i in seq_along(sct_models)) {
    message(&quot;Fixing umi.assay for SCT model &quot;, i)
    slot(Bc_all_seurat@assays$SCT@SCTModel.list[[i]], name = &quot;umi.assay&quot;) &lt;- &quot;SCT&quot;
  }
}

# Double-check the results
SCTResults(Bc_all_seurat, slot = &quot;umi.assay&quot;)
Bc_all_seurat &lt;- PrepSCTFindMarkers(Bc_all_seurat, assay = &quot;SCT&quot;)
qsave(Bc_all_seurat, file.path(result_dir, &quot;11.1_Bc_all_seurat_downstream_analysis.qs&quot;))
markers &lt;- FindAllMarkers(Bc_all_seurat, assay = &quot;SCT&quot;, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted &lt;- markers %&gt;%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list &lt;- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = &quot;11.1_Bc_Cluster_Markers.xlsx&quot;)

rm(marker_list, markers, markers_sorted)</code></pre>
</div>
<div id="plot-top-marker-genes" class="section level3">
<h3>11.1.1 Plot Top Marker Genes</h3>
<p>Visualize the top 5 marker genes using a dot plot.</p>
<pre class="r"><code>Idents(Bc_all_seurat) &lt;- &quot;seurat_clusters&quot;
DefaultAssay(Bc_all_seurat) &lt;- &quot;SCT&quot;
genes&lt;- read_csv(&quot;marker_genes_Bc_top5.txt&quot;, col_names = FALSE)
# pdf(&quot;11.1.1_DotPlot_marker_genes_Bc_top5.pdf&quot;, width = 12, heigh = 6)
DotPlot(Bc_all_seurat, assay =&quot;SCT&quot;, features = genes)+
  scale_color_viridis_c()+RotatedAxis()
# dev.off()</code></pre>
</div>
<div id="differential-expression-de-analysis" class="section level3">
<h3>11.3 Differential Expression (DE) Analysis</h3>
<p>Perform DE analysis between MS and Control conditions for each B-cell
cluster.</p>
<pre class="r"><code>Bc_all_seurat &lt;- qread(&quot;11.1_Bc_all_seurat_downstream_analysis.qs&quot;)
DefaultAssay(Bc_all_seurat) &lt;- &quot;SCT&quot;
Idents(Bc_all_seurat) &lt;- &quot;seurat_clusters&quot;
Bc_all_seurat$annotated &lt;- factor(Bc_all_seurat$seurat_clusters)
Idents(Bc_all_seurat) &lt;- &quot;annotated&quot;

de_nested_list &lt;- list()
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

for (comp in comparisons) {
  ident_1 &lt;- comp[1]
  ident_2 &lt;- comp[2]
  comp_name &lt;- paste0(ident_1, &quot;_vs_&quot;, ident_2)

  message(&quot;Running comparison: &quot;, comp_name)
  de_nested_list[[comp_name]] &lt;- list()

  for (i in levels(Bc_all_seurat$annotated)) {
    message(&quot;  Processing cluster: &quot;, i)

    cells_in_cluster &lt;- WhichCells(Bc_all_seurat, idents = i)
    cluster_meta &lt;- Bc_all_seurat@meta.data[cells_in_cluster, ]

    group_counts &lt;- table(cluster_meta$condition)

    cluster_name &lt;- paste0(&quot;Cluster_&quot;, i)

    if (all(c(ident_1, ident_2) %in% names(group_counts)) &amp;&amp;
        all(group_counts[c(ident_1, ident_2)] &gt;= 3)) {

      de &lt;- tryCatch({
        FindMarkers(
          Bc_all_seurat,
          ident.1 = ident_1,
          ident.2 = ident_2,
          subset.ident = i,
          group.by = &quot;condition&quot;,
          recorrect_umi = FALSE
        )
      }, error = function(e) {
        message(&quot;    ERROR in cluster &quot;, i, &quot;: &quot;, conditionMessage(e))
        return(NULL)
      })

      if (!is.null(de) &amp;&amp; nrow(de) &gt; 0) {
        de$gene &lt;- rownames(de)
        de &lt;- de[order(de$p_val_adj, -de$avg_log2FC), ]
        de_nested_list[[comp_name]][[cluster_name]] &lt;- de
      } else {
        message(&quot;    No DE genes found for cluster &quot;, i)
        de_nested_list[[comp_name]][[cluster_name]] &lt;- data.frame(
          Note = &quot;No DE genes found despite sufficient cells&quot;
        )
      }

    } else {
      message(&quot;    Skipping cluster &quot;, i, &quot;  too few cells in one or both groups&quot;)
      de_nested_list[[comp_name]][[cluster_name]] &lt;- data.frame(
        Note = paste(&quot;Too few cells in&quot;, ident_1, &quot;or&quot;, ident_2)
      )
    }
  }
}

saveRDS(de_nested_list, &quot;11.3_de_nested_list_Bc_SCT_condition.rds&quot;)

# Save each comparison as its own Excel file
for (comp_name in names(de_nested_list)) {
  file_name &lt;- paste0(&quot;11.3_DE_SCT_Bc_&quot;, comp_name, &quot;.xlsx&quot;)
  write.xlsx(de_nested_list[[comp_name]], file = file_name)
  message(&quot;Saved: &quot;, file_name)
}</code></pre>
</div>
<div id="volcano-plots-for-de-genes" class="section level3">
<h3>11.3.1 Volcano Plots for DE Genes</h3>
<p>Visualize DE results using volcano plots.</p>
<pre class="r"><code>de_file &lt;- &quot;11.3_DE_SCT_Bc_MS_vs_Ctrl.xlsx&quot;

all_clusters &lt;- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message(&quot;Processing cluster: &quot;, cluster)

  # Read cluster sheet
  de_data &lt;- read.xlsx(de_file, sheet = cluster)

  # Check if de_data is empty
  if (nrow(de_data) == 0 || !&quot;gene&quot; %in% colnames(de_data)) {
    message(paste(&quot;Skipping cluster&quot;, cluster, &quot;- no DE genes found&quot;))
  } else {
    volcano_genes &lt;- de_data

    #remove MT, RPL, RPS genes and Lnc
    volcano_genes &lt;- volcano_genes %&gt;% filter(!grepl(&quot;^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.&quot;, gene))
    #Define sig. up/down-reg genes
    volcano_genes$DE &lt;- &quot;NO&quot;
    volcano_genes$DE[volcano_genes$avg_log2FC &gt; 0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Up&quot;
    volcano_genes$DE[volcano_genes$avg_log2FC &lt; -0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Down&quot;
    #sign. up &amp; down
    volcano_genes$sig &lt;- ifelse(volcano_genes$DE == &quot;NO&quot;, &quot;&quot;, volcano_genes$gene)
    sig &lt;- volcano_genes$sig
    volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
    volcano_genes$DE &lt;- factor(volcano_genes$DE, levels = c(&quot;Down&quot;, &quot;NO&quot;, &quot;Up&quot;))
    volcano_genes$logP &lt;- -log10(volcano_genes$p_val_adj)
    volcano_genes$logP &lt;- pmin(volcano_genes$logP, 50)

    # Count up- and down-regulated genes
    n_up &lt;- sum(volcano_genes$DE == &quot;Up&quot;, na.rm = TRUE)
    n_down &lt;- sum(volcano_genes$DE == &quot;Down&quot;, na.rm = TRUE)

    # Filter only significant DE genes
    sig_genes &lt;- volcano_genes %&gt;%
      filter(DE != &quot;NO&quot;)
    # Rank first by adjusted p-value, then by absolute log2FC
    top_genes &lt;- sig_genes %&gt;%
      arrange(p_val_adj, desc(abs(avg_log2FC))) %&gt;%  # first p-value, then log2FC
      slice_head(n = 200) %&gt;%                         # top 200 genes
      pull(gene)

    # Update sig column to label only top 200 genes
    volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

    p &lt;- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
      geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
      geom_hline(yintercept = -log10(0.001), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
      geom_point(size = 3, alpha = 0.8) +
      scale_color_manual(values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
                         labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)) +
      geom_text_repel(max.overlaps = 50, size = 3) +
      theme_classic(base_size = 14) +
      labs(
        x = &quot;log Fold Change&quot;,
        y = expression(-log[10](&quot;adjusted p-value&quot;)),
        color = &quot;Regulation&quot;
      ) +
      annotate(&quot;text&quot;, x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0(&quot;Up: &quot;, n_up), hjust = 1, vjust = -0.5, color = &quot;#3d70b5&quot;, size = 5) +
      annotate(&quot;text&quot;, x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0(&quot;Down: &quot;, n_down), hjust = 0, vjust = -0.5, color = &quot;black&quot;, size = 5)

    # Save per cluster
    out_file &lt;- paste0(&quot;11.3.1_VolcanoPlot_DE_&quot;, cluster, &quot;_DE.pdf&quot;)
    print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
  }
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)</code></pre>
</div>
<div id="monocle-trajectory-analysis" class="section level3">
<h3>11.4 Monocle Trajectory Analysis</h3>
<p>Analyze B-cell developmental trajectories using Monocle3.</p>
<div id="pseudotime-calculation" class="section level4">
<h4>11.4.0 Pseudotime Calculation</h4>
<p>Convert Seurat object to Monocle3, learn trajectory graph, and order
cells in pseudotime.</p>
<pre class="r"><code>#convert Seurat object into Monocle object
#integrated and SCT (slot = &quot;scale.data&quot;) do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don&#39;t use scale.data
#best is to use &quot;RNA&quot;, &quot;counts&quot;

#needed to remove one cells because the cell had no information
Bc_all_seurat &lt;- subset(
  Bc_all_seurat,
  cells = colnames(Bc_all_seurat)[colnames(Bc_all_seurat) != &quot;C115_H_P10_CAAGGTTAGTCATAAGAGTAGGCT-1&quot;]
)


Idents(Bc_all_seurat) &lt;- &quot;seurat_clusters&quot;
data &lt;- as(as.matrix(GetAssayData(Bc_all_seurat, assay = &quot;SCT&quot;, slot = &quot;counts&quot;)), &#39;sparseMatrix&#39;) #normally on RNA
pd &lt;- data.frame(Bc_all_seurat@meta.data)
pData &lt;- pd %&gt;% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

Bc_monocle &lt;- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(Bc_monocle)$gene_short_name &lt;- rownames(fData(Bc_monocle))
recreate.partitions &lt;- c(rep(1, length(Bc_monocle@colData@rownames)))
names(recreate.partitions) &lt;- Bc_monocle@colData@rownames
recreate.partitions &lt;- as.factor(recreate.partitions)
recreate.partitions
Bc_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;partitions&quot;]] &lt;- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster &lt;- Bc_all_seurat@active.ident
Bc_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;clusters&quot;]] &lt;- list.cluster
Bc_monocle@int_colData@listData[[&quot;reducedDims&quot;]]@listData[[&quot;UMAP&quot;]] &lt;- Bc_all_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors &lt;- c(&quot;#a3a500&quot;, &quot;#f8766d&quot;, &quot;#00b0f6&quot;, &quot;#e76bf3&quot;, &quot;#00bf7d&quot;)
cluster.before.traj &lt;- plot_cells(Bc_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = &quot;right&quot;) +  scale_color_manual(values = cluster_colors)

# pdf(&quot;11.4.0_Bc_before_traj_plot.pdf&quot;, width = 4, height = 3)
cluster.before.traj
# dev.off()

#let it calculate trajectory
Bc_monocle &lt;- learn_graph(Bc_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
Bc_monocle &lt;- learn_graph(Bc_monocle, use_partition = F, verbose = T, close_loop = F)

#plot trajectory into UMAP
# pdf(&quot;11.4.0_Bc_traj_plot.pdf&quot;, width = 4, height = 3)
plot_cells(Bc_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
Bc_monocle &lt;- order_cells(Bc_monocle, reduction_method = &quot;UMAP&quot;, root_cells = colnames(Bc_monocle[, clusters(Bc_monocle) == 5]))
#if this Error appears &quot;Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds&quot;, leave root_cells = NULL to manually select starting point
#Bc_monocle &lt;- order_cells(Bc_monocle, reduction_method = &quot;UMAP&quot;, root_cells = NULL)

# pdf(&quot;11.4.0_Bc_traj_plot_UMAP_pseudotime.pdf&quot;, width = 5, height = 4)
plot_cells(Bc_monocle, color_cells_by = &quot;pseudotime&quot;, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
Bc_monocle$monocle3_pseudotime &lt;- pseudotime(Bc_monocle)
data.pseudo &lt;- as.data.frame(colData(Bc_monocle))

# pdf(&quot;11.4.0_Bc_traj_pseudotime.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab(&quot;&quot;)
# dev.off()
#or alternatively order by pseudotime
# pdf(&quot;11.4.0_Bc_traj_pseudotime_order.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab(&quot;pseudotime&quot;) + ylab(&quot;&quot;)
# dev.off()

qsave(Bc_monocle, &quot;11.4.0_Bc_monocle.qs&quot;)</code></pre>
</div>
<div id="genes-changing-along-pseudotime" class="section level4">
<h4>11.4.1 Genes Changing Along Pseudotime</h4>
<p>Identify and visualize genes that change expression along the
pseudotime trajectory.</p>
<pre class="r"><code>#find genes that change in pseudotime
deg &lt;- graph_test(Bc_monocle, neighbor_graph = &quot;principal_graph&quot;, verbose = TRUE)
deg |&gt; arrange(q_value, desc(morans_I)) |&gt; filter(status == &quot;OK&quot;) |&gt; head()

#deg gene list can be looked at and saved
#Moran&#39;s value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, &quot;11.4.1_Bcs_monocle_DEG.xlsx&quot;)

#one can also save pseudotime values into Seurat object and then plot for
Bc_all_seurat$pseudotime &lt;- pseudotime(Bc_monocle)
# pdf(&quot;11.4.1_Bc_FP_pseudotime.pdf&quot;, width = 4, height = 3)
FeaturePlot(Bc_all_seurat, features = &quot;pseudotime&quot;)
# dev.off()</code></pre>
</div>
<div id="gene-expression-along-pseudotime" class="section level4">
<h4>11.4.2 Gene Expression Along Pseudotime</h4>
<p>Plot expression trends for specific genes of interest along the
pseudotime.</p>
<pre class="r"><code>#one can do multiple expression plots with certain identified genes
# pdf(&quot;11.4.2_Bc_pseudotime_RP_genes_of_ineterest.pdf&quot;, width = 8, height = 9)
RidgePlot(Bc_all_seurat, features = c(&quot;CD19&quot;, &quot;CD79A&quot;, &quot;CD79B&quot;, &quot;IGHG1&quot;, &quot;IGHG2&quot;, &quot;IGHA1&quot;, &quot;IGHA2&quot;, &quot;IGHM&quot;, &quot;IGHD&quot;, &quot;CD179A&quot;, &quot;SDC1&quot;, &quot;CD38&quot;, &quot;MZB1&quot;, &quot;VPREB3&quot;, &quot;MS4A1&quot;), sort = F, cols = cluster_colors)
# dev.off()


my_genes &lt;- c(&quot;CD19&quot;, &quot;CD79A&quot;, &quot;CD79B&quot;, &quot;IGHG1&quot;, &quot;IGHA1&quot;, &quot;IGHA2&quot;, &quot;IGHM&quot;, &quot;IGHD&quot;, &quot;SDC1&quot;, &quot;CD38&quot;, &quot;MZB1&quot;, &quot;MS4A1&quot;)
Bc_monocle_subset &lt;- Bc_monocle[my_genes,]
plot_genes_in_pseudotime(Bc_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
#or
# pdf(&quot;11.4.2_Bc_genes_of_ineterest_traj_pseudocolor.pdf&quot;, width = 5, height = 10)
plot_genes_in_pseudotime(Bc_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
# dev.off()

# pdf(&quot;11.4.2_Bc_genes_of_ineterest_traj_annotated.pdf&quot;, width = 5, height = 10)
plot_genes_in_pseudotime(Bc_monocle_subset, color_cells_by = &quot;annotated&quot; )
# dev.off()</code></pre>
</div>
<div id="top-changing-genes-in-pseudotime" class="section level4">
<h4>11.4.3 Top Changing Genes in Pseudotime</h4>
<p>Visualize the top 5 genes with the most significant changes along
pseudotime for each cluster.</p>
<pre class="r"><code>#plot top5 genes that change over pseudotime in each cluster
deg_sig &lt;- deg %&gt;% filter(q_value &lt; 0.05, status == &quot;OK&quot;)

deg_sig$cluster &lt;- Bc_monocle$annotated[ match(deg_sig$gene_short_name,
                                               rownames(Bc_monocle)) ]

top5_per_cluster &lt;- deg_sig %&gt;%
  group_by(cluster) %&gt;%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot &lt;- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf(&quot;11.4.3_Bc_top_genes_pseudotime.pdf&quot;, width = 5, height = 25)

plot_genes_in_pseudotime(
  Bc_monocle[genes_to_plot, ],
  color_cells_by = &quot;annotated&quot;,
  min_expr = 0.1
)

# dev.off()</code></pre>
</div>
<div id="condition-dependent-gene-expression" class="section level4">
<h4>11.4.4 Condition-Dependent Gene Expression</h4>
<p>Identify genes whose expression changes along pseudotime differ
between conditions.</p>
<pre class="r"><code>#find genes that vary across condition
gene_fits &lt;- fit_models(Bc_monocle, model_formula_str = &quot;~condition&quot;)
gene_fits_tbl &lt;- coefficient_table(gene_fits)
write.xlsx(gene_fits_tbl, &quot;11.4.4_Bcs_pseudotime_condition.xlsx&quot;)

# Keep only the condition coefficients
deg_cond &lt;- gene_fits_tbl %&gt;%
  filter(term != &quot;(Intercept)&quot;)

# Significant genes
sig_genes &lt;- deg_cond %&gt;%
  filter(q_value &lt; 0.05)

# Rank for labeling: first q-value, then |estimate|
top_genes &lt;- sig_genes %&gt;%
  arrange(q_value, desc(abs(estimate))) %&gt;%
  slice_head(n = 50) %&gt;%
  pull(gene_short_name)

deg_volcano &lt;- deg_cond %&gt;%
  mutate(
    logFC = estimate,
    negLogQ = -log10(q_value),
    DE = case_when(
      estimate &gt; 0.5  &amp; q_value &lt; 0.05 ~ &quot;Up&quot;,
      estimate &lt; -0.5 &amp; q_value &lt; 0.05 ~ &quot;Down&quot;,
      TRUE                              ~ &quot;NO&quot;
    ),
    logP = pmin(negLogQ, 50),      # cap values for nicer plot
    label_it = ifelse(gene_short_name %in% top_genes, gene_short_name, NA)
  )


deg_volcano$label_italic &lt;- ifelse(
  is.na(deg_volcano$label_it),
  NA,
  paste0(&quot;italic(&#39;&quot;, deg_volcano$label_it, &quot;&#39;)&quot;)
)

p &lt;- ggplot(deg_volcano, aes(x = logFC, y = logP, color = DE)) +
  geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
  geom_hline(yintercept = -log10(0.05), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
  geom_point(size = 3, alpha = 0.8) +

  scale_color_manual(
    values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
    labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)
  ) +

  ggrepel::geom_text_repel(
    aes(label = label_italic),
    parse = TRUE,
    max.overlaps = 50,
    size = 3
  ) +

  theme_classic(base_size = 14) +
  labs(
    title = &quot;Condition-dependent DEGs along trajectory&quot;,
    x = &quot;log Fold Change&quot;,
    y = expression(-log[10](&quot;adjusted p-value&quot;)),
    color = &quot;Regulation&quot;
  )

print(last_plot()) # ggsave(file.path(result_dir, &quot;11.4.4_Bc_pseudotime_VolcanoPlot_DE_MS_vs_ctrl.pdf&quot;), p , width = 10, height = 7)

#plot genes over pseudotime
top_genes &lt;- top_sig$gene_short_name

p &lt;- plot_genes_in_pseudotime(
  Bc_monocle[top_genes, ],
  color_cells_by = &quot;condition&quot;
)

print(last_plot()) # ggsave(file.path(result_dir, &quot;11.4.4_Bc_pseudotime_along_traj_Plot_DE_MS_vs_ctrl.pdf&quot;), p , width = 5, height = 25)</code></pre>
</div>
</div>
</div>
<div id="score-analysis" class="section level2">
<h2>12. Score Analysis</h2>
<p>Calculate and analyze Fibrosis and IFN scores across conditions.</p>
</div>
<div id="fibrosis-score" class="section level2">
<h2>12.1 Fibrosis Score</h2>
<p>Compute fibrosis scores based on a gene set and compare between MS
and Control.</p>
<pre class="r"><code>DefaultAssay(samples_seurat) &lt;- &quot;SCT&quot;
fibrosis &lt;- read_csv(&quot;fibrosis.txt&quot;, col_names = FALSE) #genes from GO:0030198 = ECM related and upregulated in strucFibro reclustered
fibrosis_score &lt;- AddModuleScore(samples_seurat, features = fibrosis, name = &quot;fibrosisScore&quot;)
FeaturePlot(fibrosis_score, features =&quot;fibrosisScore1&quot;, split.by = &quot;condition&quot;)
VlnPlot(fibrosis_score, features =&quot;fibrosisScore1&quot;, split.by = &quot;condition&quot;,  cols = c(&quot;grey&quot;, &quot;darkblue&quot;))
Idents(fibrosis_score) &lt;- &quot;condition&quot;
DotPlot(fibrosis_score, features =&quot;fibrosisScore1&quot;)

df &lt;- FetchData(fibrosis_score, vars = c(&quot;fibrosisScore1&quot;, &quot;condition&quot;, &quot;annotated&quot;, &quot;sample_id&quot;))
df_avg &lt;- df %&gt;%
  group_by(annotated, condition, sample_id) %&gt;%
  summarise(fibrosisScore1 = mean(fibrosisScore1, na.rm = TRUE), .groups = &quot;drop&quot;)
df_collapsed &lt;- df_avg %&gt;%
  group_by(sample_id, condition) %&gt;%
  summarise(fibrosisScore1 = mean(fibrosisScore1), .groups = &quot;drop&quot;)

# pdf(&quot;12.1_MzH_human_dura_fibrosis_score_MS_vs_Ctrl_all_cluster.pdf&quot;, width = 4, height = 6)
ggplot(df_collapsed, aes(x = condition, y = fibrosisScore1, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6, size = 2, width = 0.2) +
  stat_compare_means(label = &quot;p.signif&quot;, method = &quot;wilcox.test&quot;) +
  scale_fill_manual(values = c(&quot;Ctrl&quot; = &quot;darkgrey&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  theme_classic() +
  labs(title = &quot;fibrosis score all cluster MzH_human_dura&quot;, x = &quot;Condition&quot;, y = &quot;average fibrosis score per sample&quot;)
# dev.off()</code></pre>
</div>
<div id="ifn-score" class="section level2">
<h2>12.2 IFN Score</h2>
<p>Compute Interferon (IFN) scores and compare between MS and
Control.</p>
<pre class="r"><code>#extract IF genes
all_genes &lt;- rownames(samples_seurat)
IFN_genes &lt;- grep(&quot;^(IFI)&quot;, all_genes, value = TRUE, ignore.case = TRUE) #interferone induced

IFN_score &lt;- AddModuleScore(samples_seurat, features = IFN_genes, name = &quot;IFNScore&quot;)

df &lt;- FetchData(IFN_score, vars = c(&quot;IFNScore1&quot;, &quot;condition&quot;, &quot;annotated&quot;, &quot;sample_id&quot;))
df_avg &lt;- df %&gt;%
  group_by(annotated, condition, sample_id) %&gt;%
  summarise(IFNScore1 = mean(IFNScore1, na.rm = TRUE), .groups = &quot;drop&quot;)
df_collapsed &lt;- df_avg %&gt;%
  group_by(sample_id, condition) %&gt;%
  summarise(IFNScore1 = mean(IFNScore1), .groups = &quot;drop&quot;)

p &lt;- ggplot(df_collapsed, aes(x = condition, y = IFNScore1, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6, size = 2, width = 0.2) +
  stat_compare_means(label = &quot;p.signif&quot;, method = &quot;wilcox.test&quot;) +
  scale_fill_manual(values = c(&quot;Ctrl&quot; = &quot;darkgrey&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  scale_color_manual(values = c(&quot;Ctrl&quot; = &quot;darkgrey&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  theme_classic() +
  labs(title = &quot;IFN-induced score all cluster MzH_human_dura&quot;, x = &quot;Condition&quot;, y = &quot;average IFN score per sample&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;12.2_MzH_human_dura_IFN-induced_score_MS_vs_Ctrl_all_cluster.pdf&quot;), p, width = 4, height = 6)</code></pre>
</div>
<div id="score-correlation" class="section level2">
<h2>12.3 Score Correlation</h2>
<p>Analyze the correlation between Fibrosis and IFN scores.</p>
<pre class="r"><code>fibrosis &lt;- read_csv(&quot;fibrosis.txt&quot;, col_names = FALSE) #genes from DE strucFibro fibrosis related
fibrosis_score &lt;- AddModuleScore(samples_seurat, features = fibrosis, name = &quot;fibrosisScore&quot;)
df_fibrosis &lt;- FetchData(fibrosis_score, vars = c(&quot;fibrosisScore1&quot;, &quot;condition&quot;, &quot;annotated&quot;, &quot;sample_id&quot;))
df_avg_fibrosis &lt;- df_fibrosis %&gt;%
  group_by(annotated, condition, sample_id) %&gt;%
  summarise(fibrosisScore1 = mean(fibrosisScore1, na.rm = TRUE), .groups = &quot;drop&quot;)
IFN_genes &lt;- grep(&quot;^(IFI)&quot;, all_genes, value = TRUE, ignore.case = TRUE)
IFN_score &lt;- AddModuleScore(samples_seurat, features = IFN_genes, name = &quot;IFNScore&quot;)
df_IFN &lt;- FetchData(IFN_score, vars = c(&quot;IFNScore1&quot;, &quot;condition&quot;, &quot;annotated&quot;, &quot;sample_id&quot;))
df_avg_IFN &lt;- df_IFN %&gt;%
  group_by(annotated, condition, sample_id) %&gt;%
  summarise(IFNScore1 = mean(IFNScore1, na.rm = TRUE), .groups = &quot;drop&quot;)

df_merged &lt;- inner_join(df_fibrosis, df_IFN, by = c(&quot;sample_id&quot;, &quot;condition&quot;, &quot;annotated&quot;))

df &lt;- df_merged %&gt;%
  dplyr::select(fibrosisScore1, IFNScore1) %&gt;%
  filter(!is.na(fibrosisScore1) &amp; !is.na(IFNScore1))

df_patient &lt;- df_merged %&gt;%
  group_by(sample_id, condition) %&gt;%
  summarise(
    fibrosis_avg = mean(fibrosisScore1, na.rm = TRUE),
    IFN_avg = mean(IFNScore1, na.rm = TRUE)
  )

cor_test &lt;- cor.test(df_patient$fibrosis_avg, df_patient$IFN_avg, method = &quot;spearman&quot;)
r_val &lt;- round(cor_test$estimate, 2)
p_val &lt;- cor_test$p.value
p_label &lt;- ifelse(p_val &lt; 0.001, &quot;&lt; 0.001&quot;, paste0(&quot;= &quot;, signif(p_val, 2)))
n_obs &lt;- nrow(df_patient)

p &lt;- ggplot(df_patient, aes(x = IFN_avg, y = fibrosis_avg, color = condition)) +
  geom_point(size = 3, alpha = 0.8) +       # points colored by condition
  geom_smooth(method = &quot;lm&quot;, se = TRUE, color = &quot;black&quot;, size = 0.7) +  # single overall trend line
  theme_classic(base_size = 12) +
  labs(
    title = paste0(&quot;Fibrosis vs IFN-induced score per patient (rho = &quot;, r_val, &quot;, p &quot;, p_label, &quot;, n = &quot;, n_obs, &quot;)&quot;),
    x = &quot;IFN score (per patient)&quot;,
    y = &quot;Fibrosis score (per patient)&quot;,
    color = &quot;Condition&quot;
  ) +
  scale_color_manual(values = c(&quot;Ctrl&quot; = &quot;darkgrey&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  theme(plot.title = element_text(face = &quot;bold&quot;, size = 13))

print(last_plot()) # ggsave(&quot;12.3_Fibrosis_vs_IFN_per_patient_corelation_all_cluster.pdf&quot;, p, width = 8, height = 6)</code></pre>
</div>
<div id="score-density-pca" class="section level2">
<h2>12.4 Score Density PCA</h2>
<p>Visualize the distribution of Fibrosis and IFN scores using PCA
density plots.</p>
<pre class="r"><code>#use df_patient from step 12.3
df_pca &lt;- df_patient %&gt;%
  ungroup() %&gt;%
  dplyr::select(fibrosis_avg, IFN_avg)

pca_res &lt;- prcomp(df_pca, center = TRUE, scale. = TRUE)

pca_scores &lt;- as.data.frame(pca_res$x)
pca_scores$sample_id &lt;- df_patient$sample_id
pca_scores$condition &lt;- df_patient$condition

p &lt;- ggplot(pca_scores, aes(x = PC1, y = PC2, color = condition)) +
  geom_point(size = 3, alpha = 0.8) +
  theme_classic(base_size = 12) +
  stat_ellipse(geom = &quot;polygon&quot;, aes(fill = after_scale(alpha(colour, 0.2))),
               size = 1) +
  labs(
    title = &quot;PCA of Fibrosis and IFN scores per patient&quot;,
    x = paste0(&quot;PC1 (&quot;, round(summary(pca_res)$importance[2,1]*100, 1), &quot;%)&quot;),
    y = paste0(&quot;PC2 (&quot;, round(summary(pca_res)$importance[2,2]*100, 1), &quot;%)&quot;),
    color = &quot;Condition&quot;
  ) +
  scale_color_manual(values = c(&quot;Ctrl&quot; = &quot;darkgrey&quot;, &quot;MS&quot; = &quot;#3d70b5&quot;)) +
  theme(plot.title = element_text(face = &quot;bold&quot;, size = 13))

library(ggExtra)

p_marginal &lt;- ggMarginal(p, type = &quot;density&quot;, groupColour = TRUE, groupFill = TRUE)
print(last_plot()) # ggsave(&quot;12.4_Fibrosis_vs_IFN_per_patient_density_PCA.pdf&quot;, p_marginal, width = 6, height = 6)</code></pre>
</div>
<div id="fibrosis-score-in-fibrotic-tissue" class="section level2">
<h2>12.5 fibrosis score in fibrotic tissue</h2>
<pre class="r"><code>skin &lt;- skin_fibros_Deng #load fibrotic skin dataset Deng
rm(anchors, p1, p2, predictions, samples_combined, skin_fibros_Deng)

fibrosis &lt;- read_csv(&quot;fibrosis.txt&quot;, col_names = FALSE) #genes from GO:0030198 = ECM related and upregulated in strucFibro reclustered
fibrosis_score &lt;- AddModuleScore(skin, features = fibrosis, name = &quot;fibrosisScore&quot;)

df &lt;- FetchData(fibrosis_score, vars = c(&quot;fibrosisScore1&quot;, &quot;condition&quot;, &quot;sample&quot;))
df_avg &lt;- df %&gt;%
  group_by(condition, sample) %&gt;%
  summarise(fibrosisScore1 = mean(fibrosisScore1, na.rm = TRUE), .groups = &quot;drop&quot;)
df_collapsed &lt;- df_avg %&gt;%
  group_by(sample, condition) %&gt;%
  summarise(fibrosisScore1 = mean(fibrosisScore1), .groups = &quot;drop&quot;)
df_collapsed$condition &lt;- factor(df_collapsed$condition, levels = c(&quot;NF&quot;, &quot;KF&quot;))

# pdf(&quot;12.5_fibrosis_score_in_Deng_fibrotic_skin.pdf&quot;, width = 4, height = 6)
ggplot(df_collapsed, aes(x = condition, y = fibrosisScore1, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6, size = 2, width = 0.2) +
  stat_compare_means(label = &quot;p.signif&quot;, method = &quot;wilcox.test&quot;) +
  scale_fill_manual(values = c(&quot;NF&quot; = &quot;darkgrey&quot;, &quot;KF&quot; = &quot;#3d70b5&quot;)) +
  theme_classic() +
  labs(title = &quot;fibrosis score in fibrotic skin&quot;, x = &quot;Condition&quot;, y = &quot;average fibrosis score per sample&quot;)
# dev.off()</code></pre>
</div>
<div id="milo-differential-abundance-analysis" class="section level2">
<h2>13. Milo Differential Abundance Analysis</h2>
<p>Perform differential abundance analysis using Milo to identify
neighborhoods with significant changes in cell counts between
conditions.</p>
<pre class="r"><code>#https://marionilab.github.io/miloR/articles/milo_demo.html
# Key concepts:
# 1. Neighborhoods: Groups of similar cells defined by k-nearest neighbors in reduced dimension space
# 2. Differential Abundance (DA): Statistical testing to find neighborhoods with significantly
#    different cell counts between conditions (e.g., treatment vs control)
# 3. Spatial FDR: Multiple testing correction that considers the overlap structure of neighborhoods</code></pre>
<div id="pre-processing" class="section level3">
<h3>13.1 Pre-processing</h3>
<p>Prepare the Seurat object for Milo analysis by converting it to a
SingleCellExperiment object and adding dimensionality reduction
data.</p>
<pre class="r"><code># need lognormalized data
samples_seurat_log &lt;- NormalizeData(samples_seurat, assay = &quot;RNA&quot;, normalization.method = &quot;LogNormalize&quot;)
# Convert Seurat object to SingleCellExperiment (SCE) object required by Milo
sce &lt;- as.SingleCellExperiment(samples_seurat_log)
# add PCA and UMAP data
reducedDim(sce, &quot;PCA&quot;) &lt;- samples_seurat@reductions$pca@cell.embeddings
reducedDim(sce, &quot;UMAP&quot;) &lt;- samples_seurat@reductions$umap@cell.embeddings</code></pre>
</div>
<div id="create-milo-object" class="section level3">
<h3>13.2 Create Milo Object</h3>
<p>Initialize the Milo object and add relevant metadata (sample,
condition, etc.).</p>
<pre class="r"><code>milo &lt;- Milo(sce)
# Add sample information (donor_id) to Milo object
milo@colData$sample &lt;- samples_seurat@meta.data$sample
milo@colData$condition &lt;- samples_seurat@meta.data$condition
milo@colData$age &lt;- samples_seurat@meta.data$age
milo@colData$sex &lt;- samples_seurat@meta.data$sex
milo@colData$cohort &lt;- samples_seurat@meta.data$cohort
milo@colData$pool &lt;- samples_seurat@meta.data$pool
milo@colData$biobank &lt;- samples_seurat@meta.data$biobank
milo@colData$annotated &lt;- samples_seurat@meta.data$annotated</code></pre>
</div>
<div id="estimate-neighborhood-size-k" class="section level3">
<h3>13.3 Estimate Neighborhood Size (K)</h3>
<p>Estimate the optimal k parameter for neighborhood definition.</p>
<pre class="r"><code>ks_to_test &lt;- c(20, 30, 40, 50, 80, 100)

nhood_size_estimates &lt;- estimate_neighbourhood_sizes(milo, k_grid = ks_to_test, order = 2, prop = 0.1, filtering = TRUE, reducedDim_name = &quot;UMAP&quot;, plot_stat = T)

best_k &lt;- 80</code></pre>
</div>
<div id="assign-neighborhoods" class="section level3">
<h3>13.4 Assign Neighborhoods</h3>
<p>Assign cells to neighborhoods based on the optimal k.</p>
<pre class="r"><code>set.seed(42)
milo_k &lt;- assign_neighbourhoods(milo, k = best_k, order = 2, filtering = TRUE, reducedDim_name = &quot;UMAP&quot;, verbose = F)

nhoods_milo &lt;- nhoods(milo_k)
# assign cell types for nhoods
nhood_stat_ct &lt;- data.frame(Nhood = 1:ncol(nhoods_milo) , Nhood_center = colnames(nhoods_milo))
nhood_stat_ct &lt;- miloR::annotateNhoods(milo_k , nhood_stat_ct , coldata_col = &quot;annotated&quot;)
p &lt;- plot_milo_by_single_metric(milo_k, nhood_stat_ct, colour_by = &quot;annotated&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_manual(values = cluster_colors , name = &quot;cluster&quot;)

print(last_plot()) # ggsave(file.path(result_dir, &quot;13.4_neighborhoods_k80_cluster.pdf&quot;), p, width = 8, heigh = 5)
qsave(milo_k, file.path(result_dir, &quot;13.4_neighborhoods_k80.qs&quot;))</code></pre>
</div>
<div id="milo-differential-expression-milode" class="section level3">
<h3>13.5 Milo Differential Expression (miloDE)</h3>
<p>Calculate differential expression per neighborhood.</p>
<pre class="r"><code>#time-expensive --&gt; use parallization
library(BiocParallel)
ncores = 16
mcparam &lt;- SnowParam(workers = ncores, type = &quot;SOCK&quot;)
register(mcparam)

stat_auc &lt;- suppressWarnings(calc_AUC_per_neighbourhood(milo_k , sample_id = &quot;sample&quot; , condition_id = &quot;condition&quot;, min_n_cells_per_sample = 1, BPPARAM = mcparam))
p &lt;- plot_milo_by_single_metric(milo_k, stat_auc, colour_by = &quot;auc&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;AUC&quot;)
p
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.5_miloDE_AUC.pdf&quot;), p, width = 5, heigh = 5)
qsave(stat_auc, file.path(result_dir, &quot;13.5_milo_k80_DE_stat_auc.qs&quot;))

# miloDE is time and memory expensive --&gt; run on hpc

#main part =
de_stat = de_test_neighbourhoods(milo_k,
                                 sample_id = &quot;sample&quot;,
                                 design = ~condition,
                                 covariates = c(&quot;condition&quot;),
                                 subset_nhoods = stat_auc$Nhood[!is.na(stat_auc$auc)],
                                 output_type = &quot;SCE&quot;,
                                 plot_summary_stat = TRUE,
                                 layout = &quot;UMAP&quot;,
                                 verbose = T)
qsave(de_stat, file.path(result_dir, &quot;13.5_milo_de.qs&quot;))
milo_DE &lt;- qread(&quot;13.5_milo_de.qs&quot;)</code></pre>
</div>
<div id="milo-de-genes-analysis" class="section level3">
<h3>13.6 Milo DE Genes Analysis</h3>
<p>Analyze DE genes within neighborhoods, including specific DE
genes.</p>
<pre class="r"><code>### Get neighbourhood ranking by the extent of DE ###
# transcriptional regions of noteworthy signs of DE
stat_de_magnitude &lt;- rank_neighbourhoods_by_DE_magnitude(milo_DE)
write.xlsx(stat_de_magnitude, file = file.path(result_dir, &quot;13.6_milo_DE_counts.xlsx&quot;), rowNames = FALSE)

#n`n_DE_genes` - for each neighbourhood, we calculate how many genes are assigned as DE. Since we are doing it within each neighbourhood, we use `pval_corrected_across_genes`
p &lt;- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = &quot;n_DE_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# DE genes&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.6_miloDE_all_corrected_across_genes.pdf&quot;), p, width = 5, heigh = 5)
p &lt;- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = &quot;n_DE_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# DE genes&quot;, limits = c(0, 55))
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.6_miloDE_all_corrected_across_genes_max55.pdf&quot;), p, width = 5, heigh = 5)
#n_specific_DE_genes` which neighbourhoods differ from others more so than we would expect. To assess this, we are interested in which neighbourhoods contain genes, that are DE &#39;specifically&#39; in those neighbourhoods.
#To calculate this, for each gene we now use z-transformation of `pval_corrected_across_nhoods`
#This would tell us that the gene is signifciantly DE in the neighbourhood *compared to most other neighbourhoods*.
p &lt;- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = &quot;n_specific_DE_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# specific\nDE genes&quot; , option = &quot;inferno&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.6_miloDE_specific_all_corrected_across_nhoods.pdf&quot;), p, width = 5, heigh = 5)

p &lt;- plot_milo_by_single_metric(milo_k, stat_de_magnitude, colour_by = &quot;n_specific_DE_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# specific\nDE genes&quot; , option = &quot;inferno&quot;, limits = c(0, 600))
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.6_miloDE_specific_all_corrected_across_nhoods_max600.pdf&quot;), p, width = 5, heigh = 5)

### data frame of DE
#define parameter
logFC_matrix &lt;- assay(milo_DE, &quot;logFC&quot;)
pval_matrix &lt;- assay(milo_DE, &quot;pval&quot;)
pval_corrected_across_genes_matrix &lt;- assay(milo_DE, &quot;pval_corrected_across_genes&quot;)
pval_corrected_across_nhoods_matrix &lt;- assay(milo_DE, &quot;pval_corrected_across_nhoods&quot;)

#define data frame for each parameter
library(tidyr)
logFC_df &lt;- as.data.frame(logFC_matrix) %&gt;%
  rownames_to_column(var = &quot;gene&quot;) %&gt;%
  pivot_longer(
    cols = -gene,
    names_to = &quot;neighborhood&quot;,
    values_to = &quot;logFC&quot;
  )

pval_df &lt;- as.data.frame(pval_matrix) %&gt;%
  rownames_to_column(var = &quot;gene&quot;) %&gt;%
  pivot_longer(
    cols = -gene,
    names_to = &quot;neighborhood&quot;,
    values_to = &quot;pval&quot;
  )

pval_genes_df &lt;- as.data.frame(pval_corrected_across_genes_matrix) %&gt;%
  rownames_to_column(var = &quot;gene&quot;) %&gt;%
  pivot_longer(
    cols = -gene,
    names_to = &quot;neighborhood&quot;,
    values_to = &quot;pval_corrected_across_genes&quot;
  )

pval_nhoods_df &lt;- as.data.frame(pval_corrected_across_nhoods_matrix) %&gt;%
  rownames_to_column(var = &quot;gene&quot;) %&gt;%
  pivot_longer(
    cols = -gene,
    names_to = &quot;neighborhood&quot;,
    values_to = &quot;pval_corrected_across_nhoods&quot;
  )

#combine data frame
combined_df &lt;- logFC_df %&gt;%
  left_join(pval_df, by = c(&quot;gene&quot;, &quot;neighborhood&quot;)) %&gt;%
  left_join(pval_genes_df, by = c(&quot;gene&quot;, &quot;neighborhood&quot;)) %&gt;%
  left_join(pval_nhoods_df, by = c(&quot;gene&quot;, &quot;neighborhood&quot;))

#arrange and sort data frame
combined_df &lt;- combined_df %&gt;%
  arrange(neighborhood, gene)

#replace NAs with 1
combined_df &lt;- combined_df %&gt;%
  mutate(
    pval_corrected_across_genes = ifelse(is.na(pval_corrected_across_genes), 1, pval_corrected_across_genes),
    pval_corrected_across_nhoods = ifelse(is.na(pval_corrected_across_nhoods), 1, pval_corrected_across_nhoods)
  )

#calculate z values, similar as in the rank_neighbourhoods_by_DE_magnitude() function and add to dataframe
z_matrix &lt;- combined_df %&gt;%
  dplyr::select(gene, neighborhood, pval_corrected_across_nhoods) %&gt;%
  pivot_wider(names_from = neighborhood, values_from = pval_corrected_across_nhoods) %&gt;%
  column_to_rownames(&quot;gene&quot;) %&gt;%
  as.matrix()

z_matrix &lt;- t(apply(z_matrix, 1, function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)))

z_df &lt;- as.data.frame(z_matrix) %&gt;%
  rownames_to_column(&quot;gene&quot;) %&gt;%
  pivot_longer(cols = -gene, names_to = &quot;neighborhood&quot;, values_to = &quot;z_score&quot;)

combined_df_z &lt;- combined_df %&gt;%
  left_join(z_df, by = c(&quot;gene&quot;, &quot;neighborhood&quot;))

#filtere data.frame for pval.thresh = 0.1, z.thresh = -3
pval_thresh &lt;- 0.1
z_thresh &lt;- -3

de_genes_df &lt;- combined_df_z %&gt;%
  filter(pval_corrected_across_genes &lt; pval_thresh) %&gt;%
  dplyr::select(gene, neighborhood, logFC, pval, pval_corrected_across_genes)
qsave(de_genes_df, file.path(result_dir, &quot;13.6_milo_de_filtered_corrected_across_genes.qs&quot;))

specific_de_genes_df &lt;- combined_df_z %&gt;%
  filter(z_score &lt; z_thresh) %&gt;%
  dplyr::select(gene, neighborhood, logFC, pval_corrected_across_nhoods, z_score)
qsave(specific_de_genes_df, file.path(result_dir, &quot;13.6_milo_de_filtered_corrected_across_nhoods.qs&quot;))

rm(combined_df, logFC_df, logFC_matrix, pval_corrected_across_genes_matrix, pval_corrected_across_nhoods_matrix, pval_df, pval_genes_df, pval_matrix, pval_nhoods_df, z_df, z_matrix, p, pval_thresh, z_thresh)
#save lists, each sheet = nhood, milo_de_corrected_across_genes
wb &lt;- createWorkbook()
neighborhoods &lt;- unique(de_genes_df$neighborhood)
for(nhood in neighborhoods){
  df_subset &lt;- de_genes_df %&gt;% filter(neighborhood == nhood)
  addWorksheet(wb, sheetName = nhood)
  writeData(wb, sheet = nhood, df_subset)
}
saveWorkbook(wb, file = &quot;13.6_milo_DE_filtered_corrected_across_genes.xlsx&quot;, overwrite = TRUE)

#save lists, each sheet = nhood, milo_de_corrected_across_nhoods
wb2 &lt;- createWorkbook()
neighborhoods2 &lt;- unique(specific_de_genes_df$neighborhood)
for(nhood in neighborhoods2){
  df_subset &lt;- specific_de_genes_df %&gt;% filter(neighborhood == nhood)
  addWorksheet(wb2, sheetName = nhood)
  writeData(wb2, sheet = nhood, df_subset)
}
saveWorkbook(wb2, file = &quot;13.6_milo_DE_specific_filtered_corrected_across_nhoods.xlsx&quot;, overwrite = TRUE)

rm(wb, wb2, df_subset, neighborhoods, neighborhoods2, nhood)</code></pre>
</div>
<div id="upregulated-genes-in-ms" class="section level3">
<h3>13.7 Upregulated Genes in MS</h3>
<p>Identify and visualize genes upregulated in MS across
neighborhoods.</p>
<pre class="r"><code>## DE_corrected_across_genes
de_genes_df_upregulated &lt;- de_genes_df %&gt;%
  filter(logFC &gt; 0) %&gt;%
  dplyr::select(gene, neighborhood, logFC, pval, pval_corrected_across_genes)
qsave(de_genes_df_upregulated, file.path(result_dir, &quot;13.7_milo_de_upregulated_MS_corrected_across_genes.qs&quot;))

n_upregulated_per_nhood &lt;- de_genes_df_upregulated %&gt;%
  group_by(neighborhood) %&gt;%
  summarise(n_upregulated_genes = n()) %&gt;%
  arrange(desc(n_upregulated_genes))

n_upregulated_per_nhood &lt;- n_upregulated_per_nhood %&gt;%
  rename(Nhood = neighborhood)

n_upregulated_per_nhood &lt;- n_upregulated_per_nhood %&gt;%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_upregulated_per_nhood, file = file.path(result_dir, &quot;13.7_milo_DE_upregulated_MS_counts_corrected_across_genes.xlsx&quot;), rowNames = FALSE)

p &lt;- plot_milo_by_single_metric(milo_k, n_upregulated_per_nhood, colour_by = &quot;n_upregulated_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# DE genes&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.7_miloDE_upregulated_MS_corrected_across_genes.pdf&quot;), p, width = 5, heigh = 5)

## DE_corrected_across_neighbourhoods
specific_de_genes_df_upregulated &lt;- specific_de_genes_df %&gt;%
  filter(logFC &gt; 0) %&gt;%
  dplyr::select(gene, neighborhood, logFC, pval_corrected_across_nhoods)
qsave(specific_de_genes_df_upregulated, file.path(result_dir, &quot;13.7_milo_de_upregulated_MS_corrected_across_nhoods.qs&quot;))

n_specific_upregulated_per_nhood &lt;- specific_de_genes_df_upregulated %&gt;%
  group_by(neighborhood) %&gt;%
  summarise(n_upregulated_genes = n()) %&gt;%
  arrange(desc(n_upregulated_genes))

n_specific_upregulated_per_nhood &lt;- n_specific_upregulated_per_nhood %&gt;%
  rename(Nhood = neighborhood)

n_specific_upregulated_per_nhood &lt;- n_specific_upregulated_per_nhood %&gt;%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_specific_upregulated_per_nhood , file = file.path(result_dir, &quot;13.7_milo_DE_upregulated_MS_counts_corrected_across_nhoods.xlsx&quot;), rowNames = FALSE)

p &lt;- plot_milo_by_single_metric(milo_k, n_specific_upregulated_per_nhood, colour_by = &quot;n_upregulated_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# specific DE genes&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.7_miloDE_upregulated_MS_corrected_across_nhoods.pdf&quot;), p, width = 5, heigh = 5)

p &lt;- plot_milo_by_single_metric(milo_k, n_specific_upregulated_per_nhood, colour_by = &quot;n_upregulated_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# specific DE genes&quot;, limits = c(0, 400))
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.7_miloDE_upregulated_MS_corrected_across_nhoods_max400.pdf&quot;), p, width = 5, heigh = 5)</code></pre>
</div>
<div id="downregulated-genes-in-ms" class="section level3">
<h3>13.8 Downregulated Genes in MS</h3>
<p>Identify and visualize genes downregulated in MS across
neighborhoods.</p>
<pre class="r"><code>## DE_corrected_across_genes
de_genes_df_downregulated &lt;- de_genes_df %&gt;%
  filter(logFC &lt; 0) %&gt;%
  dplyr::select(gene, neighborhood, logFC, pval, pval_corrected_across_genes)
qsave(de_genes_df_downregulated, file.path(result_dir, &quot;13.8_milo_de_downregulated_MS_corrected_across_genes.qs&quot;))

n_downregulated_per_nhood &lt;- de_genes_df_downregulated %&gt;%
  group_by(neighborhood) %&gt;%
  summarise(n_downregulated_genes = n()) %&gt;%
  arrange(desc(n_downregulated_genes))

n_downregulated_per_nhood &lt;- n_downregulated_per_nhood %&gt;%
  rename(Nhood = neighborhood)

n_downregulated_per_nhood &lt;- n_downregulated_per_nhood %&gt;%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_downregulated_per_nhood, file = file.path(result_dir, &quot;13.8_milo_DE_downregulated_MS_counts_corrected_across_genes.xlsx&quot;), rowNames = FALSE)

p &lt;- plot_milo_by_single_metric(milo_k, n_downregulated_per_nhood, colour_by = &quot;n_downregulated_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# DE genes&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.8_miloDE_downregulated_MS_corrected_across_genes.pdf&quot;), p, width = 5, heigh = 5)

## DE_corrected_across_neighbourhoods
specific_de_genes_df_downregulated &lt;- specific_de_genes_df %&gt;%
  filter(logFC &lt; 0) %&gt;%
  dplyr::select(gene, neighborhood, logFC, pval_corrected_across_nhoods)
qsave(specific_de_genes_df_downregulated, file.path(result_dir, &quot;13.8_milo_de_downregulated_corrected_across_nhoods.qs&quot;))

n_specific_downregulated_per_nhood &lt;- specific_de_genes_df_downregulated %&gt;%
  group_by(neighborhood) %&gt;%
  summarise(n_downregulated_genes = n()) %&gt;%
  arrange(desc(n_downregulated_genes))

n_specific_downregulated_per_nhood &lt;- n_specific_downregulated_per_nhood %&gt;%
  rename(Nhood = neighborhood)

n_specific_downregulated_per_nhood &lt;- n_specific_downregulated_per_nhood %&gt;%
  mutate(Nhood = as.numeric(as.character(Nhood)))
write.xlsx(n_specific_downregulated_per_nhood, file = file.path(result_dir, &quot;13.8_milo_DE_downregulated_MS_counts_corrected_across_nhoods.xlsx&quot;), rowNames = FALSE)

p &lt;- plot_milo_by_single_metric(milo_k, n_specific_downregulated_per_nhood, colour_by = &quot;n_downregulated_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# specific DE genes&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.8_miloDE_downregulated_MS_corrected_across_nhoods.pdf&quot;), p, width = 5, heigh = 5)

p &lt;- plot_milo_by_single_metric(milo_k, n_specific_downregulated_per_nhood, colour_by = &quot;n_downregulated_genes&quot; ,
                                layout = &quot;UMAP&quot; , size_range = c(1.5,3) , edge_width = c(0.2,0.5)) +
  scale_fill_viridis(name = &quot;# specific DE genes&quot;, limits = c(0, 300))
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.8_miloDE_downregulated_MS_corrected_across_nhoods_max300.pdf&quot;), p, width = 5, heigh = 5)</code></pre>
</div>
<div id="differential-abundance-testing" class="section level3">
<h3>13.9 Differential Abundance Testing</h3>
<p>Perform the final differential abundance testing on the neighborhoods
using the Negative Binomial GLM.</p>
<pre class="r"><code>milo_k &lt;- qread(&quot;13.4_neighborhoods_k80.qs&quot;)
#calculate neighbourhood counts
milo_k &lt;- buildNhoodGraph(milo_k)
colData(milo_k)$sample_condi &lt;- paste(colData(milo_k)$sample, colData(milo_k)$condition, sep=&quot;_&quot;)
milo_k &lt;- countCells(milo_k, meta.data = data.frame(colData(milo_k)), samples=&quot;sample_condi&quot;)
plotNhoodSizeHist(milo_k)

#create milo_design
milo_design &lt;- data.frame(colData(milo_k))[,c(&quot;sample_condi&quot;, &quot;sample&quot;, &quot;condition&quot;)]
milo_design &lt;- distinct(milo_design)
rownames(milo_design) &lt;- milo_design$sample_condi
#Reorder rownames to match columns of nhoodCounts(milo)
milo_design &lt;- milo_design[colnames(nhoodCounts(milo_k)), , drop=FALSE]

#DA analysis
test_condi &lt;- c(&quot;conditionMS - conditionCtrl&quot;)
milo_DA &lt;- testNhoods(milo_k, design = ~ 0 + condition, design.df = milo_design, model.contrasts = test_condi,
                      fdr.weighting=&quot;graph-overlap&quot;, norm.method=&quot;TMM&quot;)
write.xlsx(milo_DA, file = file.path(result_dir, &quot;13.9_milo_DA.xlsx&quot;), rowNames = FALSE)

p &lt;- plotNhoodGraphDA(milo_k, milo_DA, alpha = 0.05)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.9_milo_DA_FDR_0.05_sig.pdf&quot;), p, width = 5, heigh = 5)

p &lt;- plotNhoodGraphDA(milo_k, milo_DA, alpha = 1)
print(last_plot()) # ggsave(file.path(result_dir, &quot;13.9_milo_DA_FDR_1_all.pdf&quot;), p, width = 5, heigh = 5)</code></pre>
</div>
</div>
<div id="myeloid-subset-analysis" class="section level2">
<h2>14. Myeloid Subset Analysis</h2>
<p>Recluster and analyze myeloid cells to identify subpopulations and
their differential expression.</p>
<div id="myeloid-subset-and-reclustering" class="section level3">
<h3>14.0 Myeloid Subset and Reclustering</h3>
<p>Subset myeloid clusters, remove fibroblast contamination, and
re-integrate data.</p>
<pre class="r"><code>##### subset myeloid Cluster &amp; SCT transform #####
myeloid_subset &lt;- subset(samples_seurat, idents = c(&quot;CAM&quot;, &quot;IFN-CAM&quot;, &quot;Myeloid1&quot;, &quot;Myeloid2&quot;, &quot;Myeloid3&quot;, &quot;Myeloid4&quot;, &quot;Myeloid5&quot;, &quot;Mast&quot;))
myeloid_subset@assays$integrated &lt;- NULL
myeloid_subset@assays$SCT &lt;- NULL

# split by sample
DefaultAssay(myeloid_subset) &lt;- &quot;RNA&quot;
myeloid_list &lt;- SplitObject(myeloid_subset, split.by = &quot;sample_id&quot;)

# SCTransform per sample
myeloid_list &lt;- lapply(myeloid_list, function(x) {
  SCTransform(x, vst.flavor = &quot;v2&quot;, verbose = TRUE)
})

###### re-integration and re-clustering ######
features &lt;- SelectIntegrationFeatures(object.list = myeloid_list, nfeatures = 3000)
myeloid_list &lt;- PrepSCTIntegration(myeloid_list, anchor.features = features)
#rpca because otherwise too big
anchors &lt;- FindIntegrationAnchors(myeloid_list, normalization.method = &quot;SCT&quot;,anchor.features = features, reduction = &quot;rpca&quot;)
qsave(anchors, file.path(result_dir, &quot;14.0_integration_anchors_myeloid_rpca.qs&quot;))
#I ran it on the cluster
myeloid_combinedhttp://127.0.0.1:23813/graphics/plot_zoom_png?width=1751&amp;height=884 &lt;- IntegrateData(anchors, normalization.method = &quot;SCT&quot;) |&gt;
  RunPCA(verbose = T)
qsave(myeloid_combined, file.path(result_dir, &quot;14.0_myeloid_combined_rpca.qs&quot;))
myeloid_combined &lt;- RunPCA(myeloid_combined, verbose = TRUE)
myeloid_combined &lt;- RunUMAP(myeloid_combined, dims = 1:30)
myeloid_combined &lt;- FindNeighbors(myeloid_combined, dims = 1:30)
qsave(myeloid_combined, file.path(result_dir, &quot;14.0_myeloid_subset_integrated_before_clustering.qs&quot;))

res_check &lt;- FindClusters(myeloid_combined, resolution = c(0.05, 0.06, 0.07, 0.08, 0.09))
tree &lt;- clustree(res_check)
print(last_plot()) # ggsave(file.path(result_dir, &quot;14.0_myeloid_subset_reclustering_restree.pdf&quot;), tree, width = 10, height = 5)

myeloid_seurat &lt;- FindClusters(myeloid_combined, resolution = 0.07) #change resolution
myeloid_seurat &lt;- RunUMAP(myeloid_seurat, dims = 1:30)
DimPlot(myeloid_seurat, label = T)
qsave(myeloid_seurat, file.path(result_dir, &quot;14.0_myeloid_reclustered_res0.07.qs&quot;))

p &lt;- DimPlot(myeloid_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, &quot;14.0_DimPlot_myeloid_reclustered_res0.07.pdf&quot;), p, width = 6, height = 6)


p &lt;- DimPlot(myeloid_seurat, label = T, split.by = &quot;sample_id&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;14.0_DimPlot_myeloid_reclustered_res0.07_by_patient.pdf&quot;), p, width = 30, height = 6)


###### subset cluster with more than 1000 cells ######
#cluster 0     1     2     3     4     5     6     7     8
#cells 21789 14800  9758  1969  1011   845   549   127    80

Idents(myeloid_seurat) &lt;- &quot;seurat_clusters&quot;
tab &lt;- table(Idents(myeloid_seurat), myeloid_seurat$sample_id)
clusters_complete &lt;- rownames(tab)[apply(tab &gt; 0, 1, all)]

myeloid_main_seurat &lt;- subset(myeloid_seurat, idents = clusters_complete)

Idents(myeloid_main_seurat) &lt;- &quot;seurat_clusters&quot;
myeloid_main_seurat &lt;- subset(myeloid_main_seurat, idents = c(&quot;0&quot;, &quot;1&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)) #remove Fibro contamination</code></pre>
</div>
<div id="myeloid-marker-genes" class="section level3">
<h3>14.1 Myeloid Marker Genes</h3>
<p>Identify marker genes for myeloid subpopulations.</p>
<pre class="r"><code>Idents(myeloid_main_seurat) &lt;- &quot;seurat_clusters&quot;
DefaultAssay(myeloid_main_seurat) &lt;- &quot;SCT&quot;

myeloid_main_seurat &lt;- PrepSCTFindMarkers(myeloid_main_seurat, assay = &quot;SCT&quot;)
qsave(myeloid_main_seurat, file.path(result_dir, &quot;14.1_myeloid_main_seurat_downstream_analysis.qs&quot;))
markers &lt;- FindAllMarkers(myeloid_main_seurat, assay = &quot;SCT&quot;, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted &lt;- markers %&gt;%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list &lt;- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = &quot;14.1_myeloid_Cluster_Markers.xlsx&quot;)

rm(marker_list, markers, markers_sorted)</code></pre>
</div>
<div id="plot-myeloid-marker-genes" class="section level3">
<h3>14.1.1 Plot Myeloid Marker Genes</h3>
<p>Visualize top marker genes for myeloid subsets.</p>
<pre class="r"><code>Idents(myeloid_main_seurat) &lt;- &quot;seurat_clusters&quot;
DefaultAssay(myeloid_main_seurat) &lt;- &quot;SCT&quot;
genes&lt;- read_csv(&quot;marker_genes_myeloid_top5.txt&quot;, col_names = FALSE)
# pdf(&quot;14.1.1_DotPlot_marker_genes_myeloid_top5.pdf&quot;, width = 12, heigh = 6)
DotPlot(myeloid_main_seurat, features = genes$X1)+
  scale_color_viridis_c()+RotatedAxis()
# dev.off()

#annotation
myeloid_main_seurat$annotated &lt;- myeloid_main_seurat$seurat_clusters
myeloid_main_seurat$annotated &lt;- recode(myeloid_main_seurat$annotated, &quot;0&quot; = &quot;CAM&quot;, &quot;1&quot; = &quot;inflamMono&quot;, &quot;3&quot; = &quot;IFN-CAM&quot;, &quot;4&quot; = &quot;granulo&quot;, &quot;5&quot; = &quot;mast&quot;)

Idents(myeloid_main_seurat) &lt;- &quot;annotated&quot;
p &lt;- DimPlot(myeloid_main_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, &quot;14.1.1_DimPlot_myeloid_main_annotated.pdf&quot;), p, width = 6, height = 6)

p &lt;- DimPlot(myeloid_main_seurat, label = T, split.by = &quot;condition&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;14.1.1_DimPlot_myeloid_main_annotated_Ms_vs_Ctrl.pdf&quot;), p, width = 10, height = 6)

p &lt;- DimPlot(myeloid_main_seurat, label = T, split.by = &quot;sample_id&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;14.1.1_DimPlot_myeloid_main_annotated_by_patient.pdf&quot;), p, width = 30, height = 6)

#plotting marker genes
Idents(myeloid_main_seurat) &lt;- &quot;annotated&quot;
cluster_order &lt;- c(&quot;inflamMono&quot;, &quot;CAM&quot;, &quot;IFN-CAM&quot;, &quot;granulo&quot;, &quot;mast&quot;)
cluster_order &lt;- rev(cluster_order)
myeloid_main_seurat@meta.data$annotated &lt;- factor(myeloid_main_seurat@meta.data$annotated, levels = cluster_order)
Idents(myeloid_main_seurat) &lt;- &quot;annotated&quot;
DefaultAssay(myeloid_main_seurat) &lt;- &quot;SCT&quot;
genes&lt;- read_csv(&quot;marker_genes_myeloid_top5.txt&quot;, col_names = FALSE)
dp &lt;- DotPlot(myeloid_main_seurat, assay = &quot;SCT&quot;, features = genes$X1)
dp$data &lt;- subset(dp$data, pct.exp &gt;10)
# pdf(&quot;14.1.1_DotPlot_marker_genes_myeloid_top5_perc10.pdf&quot;, width = 8, heigh = 3)
dp + scale_color_viridis_c() + RotatedAxis()
# dev.off()</code></pre>
</div>
<div id="myeloid-de-analysis" class="section level3">
<h3>14.3 Myeloid DE Analysis</h3>
<p>Perform differential expression analysis for myeloid clusters.</p>
<pre class="r"><code>DefaultAssay(myeloid_main_seurat) &lt;- &quot;SCT&quot;
Idents(myeloid_main_seurat) &lt;- &quot;seurat_clusters&quot;
myeloid_main_seurat$annotated &lt;- factor(myeloid_main_seurat$seurat_clusters)
Idents(myeloid_main_seurat) &lt;- &quot;annotated&quot;

de_nested_list &lt;- list()
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

for (comp in comparisons) {
  ident_1 &lt;- comp[1]
  ident_2 &lt;- comp[2]
  comp_name &lt;- paste0(ident_1, &quot;_vs_&quot;, ident_2)

  message(&quot;Running comparison: &quot;, comp_name)
  de_nested_list[[comp_name]] &lt;- list()

  for (i in levels(myeloid_main_seurat$annotated)) {
    message(&quot;  Processing cluster: &quot;, i)

    cells_in_cluster &lt;- WhichCells(myeloid_main_seurat, idents = i)
    cluster_meta &lt;- myeloid_main_seurat@meta.data[cells_in_cluster, ]

    group_counts &lt;- table(cluster_meta$condition)

    cluster_name &lt;- paste0(&quot;Cluster_&quot;, i)

    if (all(c(ident_1, ident_2) %in% names(group_counts)) &amp;&amp;
        all(group_counts[c(ident_1, ident_2)] &gt;= 3)) {

      de &lt;- tryCatch({
        FindMarkers(
          myeloid_main_seurat,
          ident.1 = ident_1,
          ident.2 = ident_2,
          subset.ident = i,
          group.by = &quot;condition&quot;,
          recorrect_umi = FALSE
        )
      }, error = function(e) {
        message(&quot;    ERROR in cluster &quot;, i, &quot;: &quot;, conditionMessage(e))
        return(NULL)
      })

      if (!is.null(de) &amp;&amp; nrow(de) &gt; 0) {
        de$gene &lt;- rownames(de)
        de &lt;- de[order(de$p_val_adj, -de$avg_log2FC), ]
        de_nested_list[[comp_name]][[cluster_name]] &lt;- de
      } else {
        message(&quot;    No DE genes found for cluster &quot;, i)
        de_nested_list[[comp_name]][[cluster_name]] &lt;- data.frame(
          Note = &quot;No DE genes found despite sufficient cells&quot;
        )
      }

    } else {
      message(&quot;    Skipping cluster &quot;, i, &quot;  too few cells in one or both groups&quot;)
      de_nested_list[[comp_name]][[cluster_name]] &lt;- data.frame(
        Note = paste(&quot;Too few cells in&quot;, ident_1, &quot;or&quot;, ident_2)
      )
    }
  }
}

saveRDS(de_nested_list, &quot;14.3_de_nested_list_myeloid_SCT_condition.rds&quot;)

# Save each comparison as its own Excel file
for (comp_name in names(de_nested_list)) {
  file_name &lt;- paste0(&quot;14.3_DE_SCT_myeloid_&quot;, comp_name, &quot;.xlsx&quot;)
  write.xlsx(de_nested_list[[comp_name]], file = file_name)
  message(&quot;Saved: &quot;, file_name)
}</code></pre>
</div>
<div id="volcano-plots-for-myeloid-de" class="section level3">
<h3>14.3.1 Volcano Plots for Myeloid DE</h3>
<p>Visualize DE genes using volcano plots.</p>
<pre class="r"><code>de_file &lt;- &quot;14.3_DE_SCT_myeloid_MS_vs_Ctrl.xlsx&quot;

all_clusters &lt;- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message(&quot;Processing cluster: &quot;, cluster)

  # Read cluster sheet
  de_data &lt;- read.xlsx(de_file, sheet = cluster)

  # Check if de_data is empty
  if (nrow(de_data) == 0 || !&quot;gene&quot; %in% colnames(de_data)) {
    message(paste(&quot;Skipping cluster&quot;, cluster, &quot;- no DE genes found&quot;))
  } else {
    volcano_genes &lt;- de_data

    #remove MT, RPL, RPS genes and Lnc
    volcano_genes &lt;- volcano_genes %&gt;% filter(!grepl(&quot;^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.&quot;, gene))
    #Define sig. up/down-reg genes
    volcano_genes$DE &lt;- &quot;NO&quot;
    volcano_genes$DE[volcano_genes$avg_log2FC &gt; 0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Up&quot;
    volcano_genes$DE[volcano_genes$avg_log2FC &lt; -0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Down&quot;
    #sign. up &amp; down
    volcano_genes$sig &lt;- ifelse(volcano_genes$DE == &quot;NO&quot;, &quot;&quot;, volcano_genes$gene)
    sig &lt;- volcano_genes$sig
    volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
    volcano_genes$DE &lt;- factor(volcano_genes$DE, levels = c(&quot;Down&quot;, &quot;NO&quot;, &quot;Up&quot;))
    volcano_genes$logP &lt;- -log10(volcano_genes$p_val_adj)
    volcano_genes$logP &lt;- pmin(volcano_genes$logP, 50)

    # Count up- and down-regulated genes
    n_up &lt;- sum(volcano_genes$DE == &quot;Up&quot;, na.rm = TRUE)
    n_down &lt;- sum(volcano_genes$DE == &quot;Down&quot;, na.rm = TRUE)

    # Filter only significant DE genes
    sig_genes &lt;- volcano_genes %&gt;%
      filter(DE != &quot;NO&quot;)
    # Rank first by adjusted p-value, then by absolute log2FC
    top_genes &lt;- sig_genes %&gt;%
      arrange(p_val_adj, desc(abs(avg_log2FC))) %&gt;%  # first p-value, then log2FC
      slice_head(n = 200) %&gt;%                         # top 200 genes
      pull(gene)

    # Update sig column to label only top 200 genes
    volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

    p &lt;- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
      geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
      geom_hline(yintercept = -log10(0.001), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
      geom_point(size = 3, alpha = 0.8) +
      scale_color_manual(values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
                         labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)) +
      geom_text_repel(max.overlaps = 50, size = 3) +
      theme_classic(base_size = 14) +
      labs(
        x = &quot;log Fold Change&quot;,
        y = expression(-log[10](&quot;adjusted p-value&quot;)),
        color = &quot;Regulation&quot;
      ) +
      annotate(&quot;text&quot;, x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0(&quot;Up: &quot;, n_up), hjust = 1, vjust = -0.5, color = &quot;#3d70b5&quot;, size = 5) +
      annotate(&quot;text&quot;, x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0(&quot;Down: &quot;, n_down), hjust = 0, vjust = -0.5, color = &quot;black&quot;, size = 5)

    # Save per cluster
    out_file &lt;- paste0(&quot;14.3.1_VolcanoPlot_DE_&quot;, cluster, &quot;_DE.pdf&quot;)
    print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
  }
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)</code></pre>
</div>
<div id="go-enrichment-analysis" class="section level3">
<h3>14.3.2 GO Enrichment Analysis</h3>
<p>Perform Gene Ontology enrichment analysis on DE genes.</p>
<pre class="r"><code>set.seed(42)
read_all_sheets &lt;- function(path) {
  sheet_names &lt;- excel_sheets(path)
  sheets &lt;- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) &lt;- sheet_names
  return(sheets)
}

DE_MS_vs_Ctrl &lt;- read_all_sheets(file.path(result_dir, &quot;14.3_DE_SCT_myeloid_MS_vs_Ctrl.xlsx&quot;))

all_de_lists &lt;- list(
  MS_vs_Ctrl = DE_MS_vs_Ctrl
)

# Clusters of interest
target_clusters &lt;- as.character(myeloid_main_seurat@meta.data$seurat_clusters)
target_clusters &lt;- unique(target_clusters)
# Function for enrichment and plotting
run_enrichment_and_plotting &lt;- function(de_df, gene_list, direction, cluster, comparison) {
  if (length(gene_list) &lt; 5) {
    message(&quot;Not enough genes for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison)
    return(NULL)
  }
  ego &lt;- enrichGO(
    gene          = gene_list,
    OrgDb         = org.Hs.eg.db,
    keyType       = &quot;SYMBOL&quot;,
    ont           = &quot;ALL&quot;,
    pAdjustMethod = &quot;BH&quot;,
    qvalueCutoff  = 0.05,
    readable      = TRUE
  )
  if (is.null(ego) || nrow(ego) == 0) {
    message(&quot;No enrichment results for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison)
    return(NULL)
  }
  # Save GO table
  file_base &lt;- paste0(&quot;14.3.2_GO_DE_SCT_myeloid_&quot;, direction, &quot;&quot;, cluster, &quot;&quot;, comparison)
  write.xlsx(as.data.frame(ego), file = paste0(file_base, &quot;.xlsx&quot;))
  # Plots
#   pdf(paste0(file_base, &quot;.pdf&quot;), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;dotplot&quot;)
    print(barplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;barplot&quot;)
    sim &lt;- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste(&quot;Enrichment Map -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;emapplot&quot;)
    print(emapplot(sim, group = T) + ggtitle(paste(&quot;Cluster Map -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;emapplot_cluster&quot;)
    de_df &lt;- as.data.frame(de_df)
    rownames(de_df) &lt;- de_df$gene
    fc_vector &lt;- de_df[gene_list, &quot;avg_log2FC&quot;]
    names(fc_vector) &lt;- gene_list
    print(cnetplot(ego, categorySize = &quot;pvalue&quot;, foldChange = fc_vector) +
            ggtitle(paste(&quot;Cnetplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;cnetplot&quot;)
  }, error = function(e) {
    message(&quot;Plotting failed for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison, &quot;: &quot;, e$message)
  })
#   dev.off()
}

#Main loop
for (comparison in names(all_de_lists)) {
  print(comparison)
  de_list &lt;- all_de_lists[[comparison]]
  for (cluster in target_clusters) {
    print(cluster)
    cluster_name &lt;- paste0(&quot;Cluster_&quot;, cluster)
    if (!cluster_name %in% names(de_list)) {
      message(&quot;Skipping &quot;, cluster, &quot; in &quot;, comparison, &quot;  not found.&quot;)
      next
    }
    de_df &lt;- de_list[[cluster_name]]
    # Skip placeholder messages
    if (!&quot;avg_log2FC&quot; %in% colnames(de_df)) {
      message(&quot;Skipping &quot;, cluster, &quot; in &quot;, comparison, &quot;  not a valid DE result.&quot;)
      next
    }
    # UP-regulated
    gene_list_up &lt;- de_df %&gt;% filter(avg_log2FC &gt; 0.5 &amp; p_val_adj &lt; 0.001) %&gt;% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_up, &quot;Up&quot;, cluster, comparison)
    # DOWN-regulated
    gene_list_down &lt;- de_df %&gt;% filter(avg_log2FC &lt; -0.5 &amp; p_val_adj &lt; 0.001) %&gt;% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_down, &quot;Down&quot;, cluster, comparison)
  }
}</code></pre>
</div>
<div id="myeloid-trajectory-analysis-all-clusters"
class="section level3">
<h3>14.4 Myeloid Trajectory Analysis (All Clusters)</h3>
<p>Analyze the developmental trajectory of all myeloid clusters.</p>
<div id="pseudotime-calculation-1" class="section level4">
<h4>14.4.0 Pseudotime Calculation</h4>
<p>Convert Seurat object to Monocle3 and calculate pseudotime.</p>
<pre class="r"><code>#convert Seurat object into Monocle object
#integrated and SCT (slot = &quot;scale.data&quot;) do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don&#39;t use scale.data
#best is to use &quot;RNA&quot;, &quot;counts&quot;

Idents(myeloid_main_seurat) &lt;- &quot;annotated&quot;
data &lt;- as(as.matrix(GetAssayData(myeloid_main_seurat, assay = &quot;RNA&quot;, slot = &quot;counts&quot;)), &#39;sparseMatrix&#39;) #normally on RNA
pd &lt;- data.frame(myeloid_main_seurat@meta.data)
pData &lt;- pd %&gt;% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

myeloid_monocle &lt;- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(myeloid_monocle)$gene_short_name &lt;- rownames(fData(myeloid_monocle))
recreate.partitions &lt;- c(rep(1, length(myeloid_monocle@colData@rownames)))
names(recreate.partitions) &lt;- myeloid_monocle@colData@rownames
recreate.partitions &lt;- as.factor(recreate.partitions)
recreate.partitions
myeloid_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;partitions&quot;]] &lt;- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster &lt;- myeloid_main_seurat@active.ident
myeloid_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;clusters&quot;]] &lt;- list.cluster
myeloid_monocle@int_colData@listData[[&quot;reducedDims&quot;]]@listData[[&quot;UMAP&quot;]] &lt;- myeloid_main_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors &lt;- c(&quot;#f8766d&quot;, &quot;#b79f00&quot;, &quot;#00ba38&quot;, &quot;#619cff&quot;, &quot;#f564e3&quot;)
cluster.before.traj &lt;- plot_cells(myeloid_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = &quot;right&quot;) +  scale_color_manual(values = cluster_colors)

# pdf(&quot;14.4.0_myeloid_before_traj_plot.pdf&quot;, width = 4, height = 3)
cluster.before.traj
# dev.off()

#let it calculate trajectory
myeloid_monocle &lt;- learn_graph(myeloid_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
myeloid_monocle &lt;- learn_graph(myeloid_monocle, use_partition = F, verbose = T, close_loop = F, learn_graph_control=list(ncenter=100)) #changed ncenter to reduce branches

#plot trajectory into UMAP
# pdf(&quot;14.4.0_myeloid_traj_plot.pdf&quot;, width = 5, height = 4)
plot_cells(myeloid_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
myeloid_monocle &lt;- order_cells(myeloid_monocle, reduction_method = &quot;UMAP&quot;, root_cells = colnames(myeloid_monocle[, clusters(myeloid_monocle) == 5]))
#if this Error appears &quot;Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds&quot;, leave root_cells = NULL to manually select starting point
myeloid_monocle &lt;- order_cells(myeloid_monocle, reduction_method = &quot;UMAP&quot;, root_cells = NULL)

# pdf(&quot;14.4.0_myeloid_traj_plot_UMAP_pseudotime.pdf&quot;, width = 5, height = 4)
plot_cells(myeloid_monocle, color_cells_by = &quot;pseudotime&quot;, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
myeloid_monocle$monocle3_pseudotime &lt;- pseudotime(myeloid_monocle)
data.pseudo &lt;- as.data.frame(colData(myeloid_monocle))

# pdf(&quot;14.4.0_myeloid_traj_pseudotime.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab(&quot;&quot;)
# dev.off()
#or alternatively order by pseudotime
# pdf(&quot;14.4.0_myeloid_traj_pseudotime_order.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab(&quot;pseudotime&quot;) + ylab(&quot;&quot;)
# dev.off()

qsave(myeloid_monocle, &quot;14.4.0_myeloid_monocle.qs&quot;)</code></pre>
</div>
<div id="genes-along-pseudotime" class="section level4">
<h4>14.4.1 Genes Along Pseudotime</h4>
<p>Identify genes changing along the myeloid trajectory.</p>
<pre class="r"><code>#find genes that change in pseudotime
deg &lt;- graph_test(myeloid_monocle, neighbor_graph = &quot;principal_graph&quot;, verbose = TRUE)
deg |&gt; arrange(q_value, desc(morans_I)) |&gt; filter(status == &quot;OK&quot;) |&gt; head()

#deg gene list can be looked at and saved
#Moran&#39;s value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, &quot;14.4.1_myeloids_monocle_DEG.xlsx&quot;)

#one can also save pseudotime values into Seurat object and then plot for
myeloid_main_seurat$pseudotime &lt;- pseudotime(myeloid_monocle)
# pdf(&quot;14.4.1_myeloid_FP_pseudotime.pdf&quot;, width = 4, height = 3)
FeaturePlot(myeloid_main_seurat, features = &quot;pseudotime&quot;)
# dev.off()</code></pre>
</div>
<div id="plot-genes-of-interest" class="section level4">
<h4>14.4.2 Plot Genes of Interest</h4>
<p>Visualize expression of specific genes along pseudotime.</p>
<pre class="r"><code>#one can do multiple expression plots with certain identified genes
# pdf(&quot;14.4.2_myeloid_pseudotime_RP_genes_of_ineterest.pdf&quot;, width = 8, height = 9)
RidgePlot(myeloid_main_seurat, features = c(&quot;CD209&quot;, &quot;LYVE1&quot;, &quot;MRC1&quot;, &quot;CD163&quot;, &quot;F13A1&quot;, &quot;VSIG4&quot;, &quot;SELENOP&quot;, &quot;C1QA&quot;, &quot;C1QB&quot;, &quot;IFIT2&quot;, &quot;IFI44L&quot; , &quot;IFI44&quot;, &quot;IFIH1&quot;), sort = F, cols = cluster_colors)
# dev.off()


my_genes &lt;- c(&quot;CD209&quot;, &quot;LYVE1&quot;, &quot;MRC1&quot;, &quot;CD163&quot;, &quot;F13A1&quot;, &quot;VSIG4&quot;, &quot;SELENOP&quot;, &quot;C1QA&quot;, &quot;C1QB&quot;, &quot;IFIT2&quot;, &quot;IFI44L&quot; , &quot;IFI44&quot;, &quot;IFIH1&quot;) #CAM + IFI
myeloid_monocle_subset &lt;- myeloid_monocle[my_genes,]
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
#or
# pdf(&quot;14.4.2_myeloid_genes_of_interest_traj_pseudocolor.pdf&quot;, width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
# dev.off()

# pdf(&quot;14.4.2_myeloid_genes_of_ineterest_traj_annotated.pdf&quot;, width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = &quot;annotated&quot; )
# dev.off()</code></pre>
</div>
<div id="top-changing-genes-in-pseudotime-1" class="section level4">
<h4>14.4.3 Top Changing Genes in Pseudotime</h4>
<p>Visualize the top 5 most significant genes per cluster along
pseudotime.</p>
<pre class="r"><code>#plot top5 genes that change over pseudotime in each cluster
deg_sig &lt;- deg %&gt;% filter(q_value &lt; 0.05, status == &quot;OK&quot;)

deg_sig$cluster &lt;- myeloid_monocle$annotated[ match(deg_sig$gene_short_name,
                                                    rownames(myeloid_monocle)) ]

top5_per_cluster &lt;- deg_sig %&gt;%
  group_by(cluster) %&gt;%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot &lt;- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf(&quot;14.4.3_myeloid_top_genes_pseudotime.pdf&quot;, width = 5, height = 25)

plot_genes_in_pseudotime(
  myeloid_monocle[genes_to_plot, ],
  color_cells_by = &quot;annotated&quot;,
  min_expr = 0.1
)

# dev.off()</code></pre>
</div>
</div>
<div id="myeloid-trajectory-analysis-focused-subset"
class="section level3">
<h3>14.5 Myeloid Trajectory Analysis (Focused Subset)</h3>
<p>Analyze trajectory for specific myeloid clusters (1, 0, 3) excluding
granulocytes and mast cells.</p>
<div id="pseudotime-calculation-subset" class="section level4">
<h4>14.5.0 Pseudotime Calculation (Subset)</h4>
<p>Convert subset Seurat object to Monocle3 and calculate
pseudotime.</p>
<pre class="r"><code>#convert Seurat object into Monocle object
#integrated and SCT (slot = &quot;scale.data&quot;) do not work as those are not saved as absolute values by Seurat but as differences from raw counts. So don&#39;t use scale.data
#best is to use &quot;RNA&quot;, &quot;counts&quot;

#exclude granulo and mast cells because they are not in traj
myeloid_main_seurat &lt;- subset(myeloid_main_seurat, idents = c(&quot;1&quot;, &quot;0&quot;, &quot;3&quot;))

Idents(myeloid_main_seurat) &lt;- &quot;annotated&quot;
data &lt;- as(as.matrix(GetAssayData(myeloid_main_seurat, assay = &quot;RNA&quot;, slot = &quot;counts&quot;)), &#39;sparseMatrix&#39;) #normally on RNA
pd &lt;- data.frame(myeloid_main_seurat@meta.data)
pData &lt;- pd %&gt;% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, sample, condition)
fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

myeloid_monocle &lt;- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(myeloid_monocle)$gene_short_name &lt;- rownames(fData(myeloid_monocle))
recreate.partitions &lt;- c(rep(1, length(myeloid_monocle@colData@rownames)))
names(recreate.partitions) &lt;- myeloid_monocle@colData@rownames
recreate.partitions &lt;- as.factor(recreate.partitions)
recreate.partitions
myeloid_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;partitions&quot;]] &lt;- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster &lt;- myeloid_main_seurat@active.ident
myeloid_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;clusters&quot;]] &lt;- list.cluster
myeloid_monocle@int_colData@listData[[&quot;reducedDims&quot;]]@listData[[&quot;UMAP&quot;]] &lt;- myeloid_main_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors &lt;- c(&quot;#f8766d&quot;, &quot;#b79f00&quot;, &quot;#34b6b8&quot;)
cluster.before.traj &lt;- plot_cells(myeloid_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = &quot;right&quot;) +  scale_color_manual(values = cluster_colors)

# pdf(&quot;14.5.0_myeloid_before_traj_plot.pdf&quot;, width = 4, height = 3)
cluster.before.traj
# dev.off()

#let it calculate trajectory
myeloid_monocle &lt;- learn_graph(myeloid_monocle, use_partition = F, verbose = T)
#if no loop trajectory makes sense do
myeloid_monocle &lt;- learn_graph(myeloid_monocle, use_partition = F, verbose = T, close_loop = F, learn_graph_control=list(ncenter=100)) #changed ncenter to reduce branches

#plot trajectory into UMAP
# pdf(&quot;14.5.0_myeloid_traj_plot.pdf&quot;, width = 5, height = 4)
plot_cells(myeloid_monocle, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = T, label_leaves = F,
           group_label_size = 4) + scale_color_manual(values = cluster_colors)
# dev.off()

#order the cells in pseudotime
myeloid_monocle &lt;- order_cells(myeloid_monocle, reduction_method = &quot;UMAP&quot;, root_cells = colnames(myeloid_monocle[, clusters(myeloid_monocle) == 5]))
#if this Error appears &quot;Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds&quot;, leave root_cells = NULL to manually select starting point
myeloid_monocle &lt;- order_cells(myeloid_monocle, reduction_method = &quot;UMAP&quot;, root_cells = NULL)

# pdf(&quot;14.5.0_myeloid_traj_plot_UMAP_pseudotime.pdf&quot;, width = 5, height = 4)
plot_cells(myeloid_monocle, color_cells_by = &quot;pseudotime&quot;, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
myeloid_monocle$monocle3_pseudotime &lt;- pseudotime(myeloid_monocle)
data.pseudo &lt;- as.data.frame(colData(myeloid_monocle))

# pdf(&quot;14.5.0_myeloid_traj_pseudotime.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab(&quot;&quot;)
# dev.off()
#or alternatively order by pseudotime
# pdf(&quot;14.5.0_myeloid_traj_pseudotime_order.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab(&quot;pseudotime&quot;) + ylab(&quot;&quot;)
# dev.off()

qsave(myeloid_monocle, &quot;14.5.0_myeloid_monocle_focusMono.qs&quot;)</code></pre>
</div>
<div id="genes-along-pseudotime-subset" class="section level4">
<h4>14.5.1 Genes Along Pseudotime (Subset)</h4>
<p>Identify genes changing along the focused myeloid trajectory.</p>
<pre class="r"><code>#find genes that change in pseudotime
deg &lt;- graph_test(myeloid_monocle, neighbor_graph = &quot;principal_graph&quot;, verbose = TRUE)
deg |&gt; arrange(q_value, desc(morans_I)) |&gt; filter(status == &quot;OK&quot;) |&gt; head()

#deg gene list can be looked at and saved
#Moran&#39;s value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, &quot;14.5.1_myeloids_monocle_DEG.xlsx&quot;)

#one can also save pseudotime values into Seurat object and then plot for
myeloid_main_seurat$pseudotime &lt;- pseudotime(myeloid_monocle)
# pdf(&quot;14.5.1_myeloid_FP_pseudotime.pdf&quot;, width = 4, height = 3)
FeaturePlot(myeloid_main_seurat, features = &quot;pseudotime&quot;)
# dev.off()</code></pre>
</div>
<div id="plot-genes-of-interest-subset" class="section level4">
<h4>14.5.2 Plot Genes of Interest (Subset)</h4>
<p>Visualize expression of specific genes along the focused
pseudotime.</p>
<pre class="r"><code>#one can do multiple expression plots with certain identified genes
# pdf(&quot;14.5.2_myeloid_pseudotime_RP_genes_of_ineterest.pdf&quot;, width = 8, height = 9)
RidgePlot(myeloid_main_seurat, features = c(&quot;CD209&quot;, &quot;LYVE1&quot;, &quot;MRC1&quot;, &quot;CD163&quot;, &quot;F13A1&quot;, &quot;VSIG4&quot;, &quot;SELENOP&quot;, &quot;C1QA&quot;, &quot;C1QB&quot;, &quot;IFIT2&quot;, &quot;IFI44L&quot; , &quot;IFI44&quot;, &quot;IFIH1&quot;), sort = F, cols = cluster_colors)
# dev.off()


my_genes &lt;- c(&quot;CD209&quot;, &quot;LYVE1&quot;, &quot;MRC1&quot;, &quot;CD163&quot;, &quot;F13A1&quot;, &quot;VSIG4&quot;, &quot;SELENOP&quot;, &quot;C1QA&quot;, &quot;C1QB&quot;, &quot;IFIT2&quot;, &quot;IFI44L&quot; , &quot;IFI44&quot;, &quot;IFIH1&quot;) #CAM + IFI
myeloid_monocle_subset &lt;- myeloid_monocle[my_genes,]
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
#or
# pdf(&quot;14.5.2_myeloid_genes_of_interest_traj_pseudocolor.pdf&quot;, width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
# dev.off()

# pdf(&quot;14.5.2_myeloid_genes_of_ineterest_traj_annotated.pdf&quot;, width = 5, height = 10)
plot_genes_in_pseudotime(myeloid_monocle_subset, color_cells_by = &quot;annotated&quot; ) + scale_color_manual(values = cluster_colors)
# dev.off()</code></pre>
</div>
<div id="top-changing-genes-subset" class="section level4">
<h4>14.5.3 Top Changing Genes (Subset)</h4>
<p>Visualize the top 5 most significant genes per cluster along the
focused pseudotime.</p>
<pre class="r"><code>#plot top5 genes that change over pseudotime in each cluster
deg_sig &lt;- deg %&gt;% filter(q_value &lt; 0.05, status == &quot;OK&quot;)

deg_sig$cluster &lt;- myeloid_monocle$annotated[ match(deg_sig$gene_short_name,
                                                    rownames(myeloid_monocle)) ]

top5_per_cluster &lt;- deg_sig %&gt;%
  group_by(cluster) %&gt;%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot &lt;- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf(&quot;14.5.3_myeloid_top_genes_pseudotime.pdf&quot;, width = 5, height = 15)

plot_genes_in_pseudotime(
  myeloid_monocle[genes_to_plot, ],
  color_cells_by = &quot;annotated&quot;,
  min_expr = 0.1
) + scale_color_manual(values = cluster_colors)

# dev.off()</code></pre>
</div>
<div id="condition-dependent-expression" class="section level4">
<h4>14.4.4 Condition-Dependent Expression</h4>
<p>Identify genes whose expression changes along pseudotime differ
between conditions.</p>
<pre class="r"><code>#find genes that vary across condition
gene_fits &lt;- fit_models(myeloid_monocle, model_formula_str = &quot;~condition&quot;)
gene_fits_tbl &lt;- coefficient_table(gene_fits)
write.xlsx(gene_fits_tbl, &quot;14.5.4_myeloids_pseudotime_condition.xlsx&quot;)

# Keep only the condition coefficients
deg_cond &lt;- gene_fits_tbl %&gt;%
  filter(term != &quot;(Intercept)&quot;)

# Significant genes
sig_genes &lt;- deg_cond %&gt;%
  filter(q_value &lt; 0.05)

# Rank for labeling: first q-value, then |estimate|
top_genes &lt;- sig_genes %&gt;%
  arrange(q_value, desc(abs(estimate))) %&gt;%
  slice_head(n = 50) %&gt;%
  pull(gene_short_name)

deg_volcano &lt;- deg_cond %&gt;%
  mutate(
    logFC = estimate,
    negLogQ = -log10(q_value),
    DE = case_when(
      estimate &gt; 0.5  &amp; q_value &lt; 0.05 ~ &quot;Up&quot;,
      estimate &lt; -0.5 &amp; q_value &lt; 0.05 ~ &quot;Down&quot;,
      TRUE                              ~ &quot;NO&quot;
    ),
    logP = pmin(negLogQ, 50),      # cap values for nicer plot
    label_it = ifelse(gene_short_name %in% top_genes, gene_short_name, NA)
  )


deg_volcano$label_italic &lt;- ifelse(
  is.na(deg_volcano$label_it),
  NA,
  paste0(&quot;italic(&#39;&quot;, deg_volcano$label_it, &quot;&#39;)&quot;)
)

p &lt;- ggplot(deg_volcano, aes(x = logFC, y = logP, color = DE)) +
  geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
  geom_hline(yintercept = -log10(0.05), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
  geom_point(size = 3, alpha = 0.8) +

  scale_color_manual(
    values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
    labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)
  ) +

  ggrepel::geom_text_repel(
    aes(label = label_italic),
    parse = TRUE,
    max.overlaps = 50,
    size = 3
  ) +

  theme_classic(base_size = 14) +
  labs(
    title = &quot;Condition-dependent DEGs along trajectory&quot;,
    x = &quot;log Fold Change&quot;,
    y = expression(-log[10](&quot;adjusted p-value&quot;)),
    color = &quot;Regulation&quot;
  )

print(last_plot()) # ggsave(file.path(result_dir, &quot;14.5.4_myeloid_pseudotime_VolcanoPlot_DE_MS_vs_ctrl.pdf&quot;), p , width = 10, height = 7)

#plot genes over pseudotime
top_genes &lt;- top_sig$gene_short_name

p &lt;- plot_genes_in_pseudotime(
  myeloid_monocle[top_genes, ],
  color_cells_by = &quot;condition&quot;
)

print(last_plot()) # ggsave(file.path(result_dir, &quot;14.5.4_myeloid_pseudotime_along_traj_Plot_DE_MS_vs_ctrl.pdf&quot;), p , width = 5, height = 25)</code></pre>
</div>
</div>
<div id="cluster-abundance-analysis-confounder-adjusted-1"
class="section level3">
<h3>14.6 Cluster Abundance Analysis (Confounder Adjusted)</h3>
<p>Analyze changes in myeloid cluster abundance while adjusting for
confounding variables.</p>
<div id="data-preparation-confounders" class="section level4">
<h4>14.6.1 Data Preparation (Confounders)</h4>
<p>Prepare metadata and count matrices for abundance analysis.</p>
<pre class="r"><code># Extract metadata and ensure all required variables are present
meta_confounders &lt;- myeloid_main_seurat@meta.data %&gt;%
  dplyr::select(sample_id, condition, cohort, pool, annotated, age, sex) %&gt;%
  # Remove rows with missing confounder data
  filter(!is.na(age) &amp; !is.na(sex)) %&gt;%
  # Ensure sex is a factor
  mutate(sex = as.factor(sex),
         condition     = as.factor(condition),
         cohort = as.factor(cohort),
         pool = as.factor(pool),
         age = as.numeric(age))

# Create count matrix: samples x cell types
library(tidyr)
count_matrix &lt;- meta_confounders %&gt;%
  group_by(sample_id, annotated) %&gt;%
  summarise(count = n(), .groups = &quot;drop&quot;) %&gt;%
  pivot_wider(names_from = annotated, values_from = count, values_fill = 0) %&gt;%
  column_to_rownames(&quot;sample_id&quot;) %&gt;%
  as.matrix()

# Create sample metadata
sample_meta &lt;- meta_confounders %&gt;%
  dplyr::select(sample_id, condition, cohort, pool, sex) %&gt;% #age
  distinct()
rownames(sample_meta) &lt;- sample_meta$sample_id

# Ensure same sample order
sample_meta &lt;- sample_meta[rownames(count_matrix), ]</code></pre>
</div>
<div id="confounder-adjusted-differential-abundance-1"
class="section level4">
<h4>14.6.2 Confounder-Adjusted Differential Abundance</h4>
<p>Run <code>propeller</code> analysis to identify differentially
abundant myeloid cell types between MS and Ctrl.</p>
<pre class="r"><code>run_propeller_with_confounders &lt;- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list &lt;- list()

#   pdf(output_file, width = 8, height = 6)

  for (pair in comparisons) {
    group1 &lt;- pair[1]
    group2 &lt;- pair[2]

    cat(paste(&quot;  Analyzing:&quot;, group1, &quot;vs&quot;, group2, &quot;with confounders\n&quot;))

    # Filter to comparison groups
    keep_samples              &lt;- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              &lt;- count_data[keep_samples, , drop = FALSE]
    meta_subset               &lt;- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  &lt;- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str &lt;- paste(&quot;~&quot;, group_var, &quot;+&quot;, paste(confounders, collapse = &quot; + &quot;))
    design_formula &lt;- as.formula(formula_str)
    # design_matrix &lt;- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props &lt;- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit &lt;- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results &lt;- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str &lt;- paste(confounders, collapse = &quot; + &quot;)

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model &lt;- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula &lt;- as.formula(paste(&quot;celltype ~&quot;, group_var, &quot;+&quot;, confounder_str))

        # Fit linear model
        fit &lt;- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name &lt;- paste0(group_var, group1)
        coef_names &lt;- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val &lt;- coef(fit)[coef_name]
          p_val    &lt;- summary(fit)$coefficients[coef_name, &quot;Pr(&gt;|t|)&quot;]

          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- coef_val
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- NA
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- NA
        }
      }

      results$P.Value.Adj &lt;- p.adjust(results$P.Value, method = &quot;BH&quot;)
      results$comparison  &lt;- paste(group1, &quot;vs&quot;, group2, sep = &quot;_&quot;)

      # Store results in list
      results_list[[paste(group1, &quot;vs&quot;, group2)]] &lt;- results

      # Prepare volcano plot dataframe
      volcano_df &lt;- results %&gt;%
        mutate(
          log2_ratio = logFC,
          p.adj = P.Value.Adj,
          neg_log10_p = -log10(p.adj),
          var = CellType
        ) %&gt;%
        dplyr::select(var, log2_ratio, p.adj, neg_log10_p)

      # Volcano plot function
      VolPlot &lt;- function(data) {
        data |&gt;
          ggplot(aes(x = log2_ratio, y = neg_log10_p, color = var, label = var)) +
          geom_point(size = 3) +
          geom_hline(yintercept = -log10(0.05), color = &quot;grey&quot;, linetype = &quot;dashed&quot;) +
          geom_vline(xintercept = 0, color = &quot;grey&quot;, linetype = &quot;dashed&quot;) +
          ggtitle(paste(&quot;Confounder-adjusted: sex + cohort + pool&quot;, group1, &quot;vs&quot;, group2)) +
          scale_color_manual(values = cluster_colors) +
          ggrepel::geom_text_repel() +
          theme_classic() +
          theme(legend.position = &quot;none&quot;) +
          xlab(bquote(~ Log[2] ~ &quot;fold change&quot;)) +
          ylab(bquote(~ -Log[10] ~ &quot;adjusted p value&quot;))
      }

      # Print volcano plot
      p &lt;- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste(&quot;Error in analysis for&quot;, group1, &quot;vs&quot;, group2, &quot;:&quot;, e$message, &quot;\n&quot;))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

results_confounders_pms &lt;- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %&gt;% dplyr::select(-sample_id),
  group_var   = &quot;condition&quot;,
  confounders = c(&quot;sex&quot;, &quot;cohort&quot;, &quot;pool&quot;), #age
  comparisons = comparisons,
  output_file = file.path(&quot;14.6.2_confounder_adjusted_propeller.pdf&quot;)
)</code></pre>
</div>
<div id="confounder-adjusted-log2-fold-changes" class="section level4">
<h4>14.6.3 Confounder-Adjusted Log2 Fold Changes</h4>
<p>Calculate and visualize log2 fold changes for myeloid clusters,
adjusting for confounders.</p>
<pre class="r"><code>run_propeller_with_confounders &lt;- function(count_data, sample_data, group_var, confounders, comparisons, output_file) {

  results_list &lt;- list()

#   pdf(output_file, width = 3, height = 3)

  for (pair in comparisons) {
    group1 &lt;- pair[1]
    group2 &lt;- pair[2]

    cat(paste(&quot;  Analyzing:&quot;, group1, &quot;vs&quot;, group2, &quot;with confounders\n&quot;))

    # Filter to comparison groups
    keep_samples              &lt;- sample_data[[group_var]] %in% c(group1, group2)
    count_subset              &lt;- count_data[keep_samples, , drop = FALSE]
    meta_subset               &lt;- sample_data[keep_samples, , drop = FALSE]
    meta_subset[[group_var]]  &lt;- relevel(factor(meta_subset[[group_var]]), ref = group2)

    # Create design matrix with confounders (not directly used but good for reference)
    formula_str &lt;- paste(&quot;~&quot;, group_var, &quot;+&quot;, paste(confounders, collapse = &quot; + &quot;))
    design_formula &lt;- as.formula(formula_str)
    # design_matrix &lt;- model.matrix(design_formula, data = meta_subset)

    tryCatch({
      # Calculate proportions and logit transform
      props &lt;- (count_subset + 1) / (rowSums(count_subset) + ncol(count_subset))
      props_logit &lt;- log(props / (1 - props + 1e-6))

      # Prepare results dataframe
      results &lt;- data.frame(
        CellType = colnames(props_logit),
        stringsAsFactors = FALSE
      )

      # Build formula string for linear model with confounders
      confounder_str &lt;- paste(confounders, collapse = &quot; + &quot;)

      for (celltype in colnames(props_logit)) {
        # Prepare model dataframe
        df_model &lt;- data.frame(
          celltype = props_logit[, celltype],
          meta_subset
        )

        # Construct formula dynamically
        formula &lt;- as.formula(paste(&quot;celltype ~&quot;, group_var, &quot;+&quot;, confounder_str))

        # Fit linear model
        fit &lt;- lm(formula = formula, data = df_model)

        # Extract coefficient and p-value for group effect
        coef_name &lt;- paste0(group_var, group1)
        coef_names &lt;- names(coef(fit))

        if (coef_name %in% coef_names) {
          coef_val &lt;- coef(fit)[coef_name]
          p_val    &lt;- summary(fit)$coefficients[coef_name, &quot;Pr(&gt;|t|)&quot;]

          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- coef_val
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- p_val
        } else {
          # In case coef not found (e.g. reference level), assign NA
          results[results$CellType == celltype, &quot;logFC&quot;] &lt;- NA
          results[results$CellType == celltype, &quot;P.Value&quot;] &lt;- NA
        }
      }

      results$P.Value.Adj &lt;- p.adjust(results$P.Value, method = &quot;BH&quot;)
      results$comparison  &lt;- paste(group1, &quot;vs&quot;, group2, sep = &quot;_&quot;)

      # Store results in list
      results_list[[paste(group1, &quot;vs&quot;, group2)]] &lt;- results

      # Prepare volcano plot dataframe
      volcano_df &lt;- results %&gt;%
        mutate(
          log2_ratio = logFC,
          cluster = CellType
        ) %&gt;%
        arrange(log2_ratio) %&gt;%
        mutate(cluster = factor(cluster, levels = cluster))

      # Volcano plot function
      VolPlot &lt;- function(data) {
        ggplot(data, aes(x = log2_ratio, y = cluster, color = cluster)) +
          geom_point(size = 3) +
          geom_vline(xintercept = 0, color = &quot;grey&quot;, linetype = &quot;dashed&quot;) +
          ggtitle(paste(group1, &quot;vs&quot;, group2, &quot;(confounder adjusted)&quot;)) +
          theme_classic() +
          theme(legend.position = &quot;none&quot;) +
          xlab(bquote(~ Log[2] ~ &quot;fold change&quot;)) +
          ylab(&quot;Cluster&quot;) +
          scale_color_manual(values = cluster_colors)
      }

      # Print volcano plot
      p &lt;- VolPlot(volcano_df)
      print(p)

    }, error = function(e) {
      cat(paste(&quot;Error in analysis for&quot;, group1, &quot;vs&quot;, group2, &quot;:&quot;, e$message, &quot;\n&quot;))
    })
  }

#   dev.off()
  return(results_list)
}

# for condition_PMS
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

results_confounders_pms &lt;- run_propeller_with_confounders(
  count_data  = count_matrix,
  sample_data = sample_meta %&gt;% dplyr::select(-sample_id),
  group_var   = &quot;condition&quot;,
  confounders = c(&quot;sex&quot;, &quot;cohort&quot;, &quot;pool&quot;), #age
  comparisons = comparisons,
  output_file = file.path(&quot;14.6.3_confounder_adjusted_propeller_LogFC_all.pdf&quot;)
)</code></pre>
</div>
</div>
</div>
<div id="fibroblast-subset-analysis" class="section level2">
<h2>15. Fibroblast Subset Analysis</h2>
<p>Recluster and analyze fibroblast cells to identify subpopulations and
their differential expression.</p>
<div id="fibroblast-subset-and-reclustering" class="section level3">
<h3>15.0 Fibroblast Subset and Reclustering</h3>
<p>Subset fibroblast clusters, re-integrate data, and perform
clustering.</p>
<pre class="r"><code>##### subset Fibro Cluster &amp; SCT transform #####
Idents(samples_seurat) &lt;- &quot;annotated&quot;
Fibro_subset &lt;- subset(samples_seurat, idents = c(&quot;duraFibro1&quot;, &quot;duraFibro2&quot;, &quot;duraFibro3&quot;, &quot;duraFibro4&quot;, &quot;duraFibro5&quot;, &quot;duraFibro6&quot;, &quot;duraFibro7&quot;, &quot;duraFibro8&quot;, &quot;ABC&quot;, &quot;arach_bordFibro&quot;))
Fibro_subset@assays$integrated &lt;- NULL
Fibro_subset@assays$SCT &lt;- NULL

# split by sample
DefaultAssay(Fibro_subset) &lt;- &quot;RNA&quot;
Fibro_list &lt;- SplitObject(Fibro_subset, split.by = &quot;sample_id&quot;)

# SCTransform per sample
Fibro_list &lt;- lapply(Fibro_list, function(x) {
  SCTransform(x, vst.flavor = &quot;v2&quot;, verbose = TRUE)
})

###### re-integration and re-clustering ######
features &lt;- SelectIntegrationFeatures(object.list = Fibro_list, nfeatures = 3000)
Fibro_list &lt;- PrepSCTIntegration(Fibro_list, anchor.features = features)
#rpca because otherwise too big
anchors &lt;- FindIntegrationAnchors(Fibro_list, normalization.method = &quot;SCT&quot;,anchor.features = features, reduction = &quot;rpca&quot;)
qsave(anchors, file.path(result_dir, &quot;15.0_integration_anchors_Fibro_rpca.qs&quot;))
#ran it on the hpc
Fibro_combined &lt;- IntegrateData(anchors, normalization.method = &quot;SCT&quot;) |&gt;
  RunPCA(verbose = T)
qsave(Fibro_combined, file.path(result_dir, &quot;15.0_Fibro_combined_rpca.qs&quot;))
Fibro_combined &lt;- RunPCA(Fibro_combined, verbose = TRUE)
Fibro_combined &lt;- RunUMAP(Fibro_combined, dims = 1:30)
Fibro_combined &lt;- FindNeighbors(Fibro_combined, dims = 1:30)
qsave(Fibro_combined, file.path(result_dir, &quot;15.0_Fibro_subset_integrated_before_clustering.qs&quot;))

Fibro_combined@meta.data$integrated_snn_res.0.7 &lt;- NULL
res_check &lt;- FindClusters(Fibro_combined, resolution = c(0.01, 0.02, 0.03, 0.035, 0.04))
tree &lt;- clustree(res_check)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.0_Fibro_subset_reclustering_restree.pdf&quot;), tree, width = 10, height = 5)

Fibro_seurat &lt;- FindClusters(Fibro_combined, resolution = 0.15) #change resolution
Fibro_seurat &lt;- RunUMAP(Fibro_seurat, dims = 1:30)
DimPlot(Fibro_seurat, label = T)
qsave(Fibro_seurat, file.path(result_dir, &quot;15.0_Fibro_reclustered_res0.15.qs&quot;))

p &lt;- DimPlot(Fibro_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.0_DimPlot_Fibro_reclustered_res0.15.pdf&quot;), p, width = 6, height = 6)

p &lt;- DimPlot(Fibro_seurat, label = T, split.by = &quot;sample_id&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.0_DimPlot_Fibro_reclustered_res0.15_by_patient.pdf&quot;), p, width = 34, height = 6)

###### subset cluster with more than 1000 cells ######
table(Fibro_seurat$seurat_clusters)
#cluster 0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15
#cells 28116 12604 11860 11053 10001  9594  5375  4969  2217  1245   442   342   195   179   178   119

Idents(Fibro_seurat) &lt;- &quot;seurat_clusters&quot;
tab &lt;- table(Idents(Fibro_seurat), Fibro_seurat$sample_id)
clusters_complete &lt;- rownames(tab)[apply(tab &gt; 0, 1, all)]

Fibro_main_seurat &lt;- subset(Fibro_seurat, idents = clusters_complete)

p &lt;- DimPlot(Fibro_main_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.0_DimPlot_Fibro_main_res0.15_removedClusters.pdf&quot;), p, width = 6, height = 6)

p &lt;- DimPlot(Fibro_main_seurat, label = T, split.by = &quot;sample_id&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.0_DimPlot_Fibro_main_res0.15_removedClusters_by_patient.pdf&quot;), p, width = 30, height = 6)</code></pre>
</div>
<div id="fibroblast-marker-genes" class="section level3">
<h3>15.1 Fibroblast Marker Genes</h3>
<p>Identify marker genes for fibroblast subpopulations.</p>
<pre class="r"><code>Idents(Fibro_main_seurat) &lt;- &quot;seurat_clusters&quot;
Fibro_main_seurat &lt;- PrepSCTFindMarkers(Fibro_main_seurat)
qsave(Fibro_main_seurat, file.path(result_dir, &quot;15.1_Fibro_main_seurat_res0.15_downstream_analysis.qs&quot;))
markers &lt;- FindAllMarkers(Fibro_main_seurat, assay = &quot;SCT&quot;, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
markers_sorted &lt;- markers %&gt;%
  arrange(cluster, p_val_adj, desc(avg_log2FC))
marker_list &lt;- split(markers_sorted, markers_sorted$cluster)
write.xlsx(marker_list, file = &quot;15.1_Cluster_Markers_Fibro.xlsx&quot;)</code></pre>
</div>
<div id="go-enrichment-on-fibroblast-markers" class="section level3">
<h3>15.2 GO Enrichment on Fibroblast Markers</h3>
<p>Perform Gene Ontology enrichment analysis on the identified marker
genes.</p>
<pre class="r"><code>set.seed(42)
# Function to read all sheets from an Excel file
read_all_sheets &lt;- function(path) {
  sheet_names &lt;- excel_sheets(path)
  sheets &lt;- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) &lt;- sheet_names
  return(sheets)
}

# Load marker genes
marker_genes &lt;- read_all_sheets(file.path(result_dir, &quot;15.1_Cluster_Markers_Fibro.xlsx&quot;))

# Function to run GO enrichment and plotting for a single cluster
run_enrichment_markers &lt;- function(marker_genes_list, cluster_name) {

  # Extract gene column
  if (!&quot;gene&quot; %in% colnames(marker_genes_list[[cluster_name]])) {
    message(&quot;Cluster &quot;, cluster_name, &quot; does not have a &#39;gene&#39; column. Skipping.&quot;)
    return(NULL)
  }

  gene_list &lt;- as.character(marker_genes_list[[cluster_name]]$gene)

  # Skip small lists
  if (length(gene_list) &lt; 5) {
    message(&quot;Not enough genes for cluster &quot;, cluster_name, &quot; (&quot;, length(gene_list), &quot; genes). Skipping.&quot;)
    return(NULL)
  }

  # Run GO enrichment (Biological Process)
  ego &lt;- enrichGO(
    gene = gene_list,
    OrgDb = org.Hs.eg.db,
    keyType = &quot;SYMBOL&quot;,
    ont = &quot;BP&quot;,
    pAdjustMethod = &quot;BH&quot;,
    qvalueCutoff = 0.05,
    readable = TRUE
  )

  if (is.null(ego) || nrow(ego) == 0) {
    message(&quot;No enrichment results for cluster &quot;, cluster_name)
    return(NULL)
  }

  # Save GO table
  write.xlsx(as.data.frame(ego), file = paste0(&quot;15.2_GO_Fibro_Subset_&quot;, cluster_name, &quot;_markers.xlsx&quot;))

  # Plotting
#   pdf(paste0(&quot;15.2_GO_Fibro_Subset_&quot;, cluster_name, &quot;_markers.pdf&quot;), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, cluster_name)))
    print(barplot(ego) + ggtitle(paste(&quot;Barplot -&quot;, cluster_name)))
    sim &lt;- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste(&quot;Enrichment Map -&quot;, cluster_name)))
    print(emapplot(sim, group = T) + ggtitle(paste(&quot;Cluster Map -&quot;, cluster_name)))
  }, error = function(e) {
    message(&quot;Plotting failed for cluster &quot;, cluster_name, &quot;: &quot;, e$message)
  })
#   dev.off()

  return(ego)
}

# Loop over all clusters
results_enrichment &lt;- list()
for (cluster in names(marker_genes)) {
  message(&quot;Running enrichment for cluster: &quot;, cluster)
  ego &lt;- run_enrichment_markers(marker_genes, cluster)
  if (!is.null(ego)) {
    results_enrichment[[cluster]] &lt;- ego
  }
}</code></pre>
</div>
<div id="fibroblast-de-analysis" class="section level3">
<h3>15.3 Fibroblast DE Analysis</h3>
<p>Perform differential expression analysis for fibroblast clusters
between conditions.</p>
<pre class="r"><code>DefaultAssay(Fibro_main_seurat) &lt;- &quot;SCT&quot;
Idents(Fibro_main_seurat) &lt;- &quot;seurat_clusters&quot;
Fibro_main_seurat$annotated &lt;- factor(Fibro_main_seurat$seurat_clusters)
Idents(Fibro_main_seurat) &lt;- &quot;annotated&quot;

de_nested_list &lt;- list()
comparisons &lt;- list(
  c(&quot;MS&quot;, &quot;Ctrl&quot;)
)

for (comp in comparisons) {
  ident_1 &lt;- comp[1]
  ident_2 &lt;- comp[2]
  comp_name &lt;- paste0(ident_1, &quot;_vs_&quot;, ident_2)

  message(&quot;Running comparison: &quot;, comp_name)
  de_nested_list[[comp_name]] &lt;- list()

  for (i in levels(Fibro_main_seurat$annotated)) {
    message(&quot;  Processing cluster: &quot;, i)

    cells_in_cluster &lt;- WhichCells(Fibro_main_seurat, idents = i)
    cluster_meta &lt;- Fibro_main_seurat@meta.data[cells_in_cluster, ]

    group_counts &lt;- table(cluster_meta$condition)

    cluster_name &lt;- paste0(&quot;Cluster_&quot;, i)

    if (all(c(ident_1, ident_2) %in% names(group_counts)) &amp;&amp;
        all(group_counts[c(ident_1, ident_2)] &gt;= 3)) {

      de &lt;- tryCatch({
        FindMarkers(
          Fibro_main_seurat,
          ident.1 = ident_1,
          ident.2 = ident_2,
          subset.ident = i,
          group.by = &quot;condition&quot;,
          recorrect_umi = FALSE
        )
      }, error = function(e) {
        message(&quot;    ERROR in cluster &quot;, i, &quot;: &quot;, conditionMessage(e))
        return(NULL)
      })

      if (!is.null(de) &amp;&amp; nrow(de) &gt; 0) {
        de$gene &lt;- rownames(de)
        de &lt;- de[order(de$p_val_adj, -de$avg_log2FC), ]
        de_nested_list[[comp_name]][[cluster_name]] &lt;- de
      } else {
        message(&quot;    No DE genes found for cluster &quot;, i)
        de_nested_list[[comp_name]][[cluster_name]] &lt;- data.frame(
          Note = &quot;No DE genes found despite sufficient cells&quot;
        )
      }

    } else {
      message(&quot;    Skipping cluster &quot;, i, &quot;  too few cells in one or both groups&quot;)
      de_nested_list[[comp_name]][[cluster_name]] &lt;- data.frame(
        Note = paste(&quot;Too few cells in&quot;, ident_1, &quot;or&quot;, ident_2)
      )
    }
  }
}

saveRDS(de_nested_list, &quot;15.3_de_nested_list_Fibro_SCT_condition.rds&quot;)

# Save each comparison as its own Excel file
for (comp_name in names(de_nested_list)) {
  file_name &lt;- paste0(&quot;15.3_DE_SCT_Fibro_&quot;, comp_name, &quot;.xlsx&quot;)
  write.xlsx(de_nested_list[[comp_name]], file = file_name)
  message(&quot;Saved: &quot;, file_name)
}</code></pre>
</div>
<div id="volcano-plots-for-fibroblast-de" class="section level3">
<h3>15.4 Volcano Plots for Fibroblast DE</h3>
<p>Visualize fibroblast DE genes using volcano plots.</p>
<pre class="r"><code>de_file &lt;- &quot;15.3_DE_SCT_Fibro_MS_vs_Ctrl.xlsx&quot;

all_clusters &lt;- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message(&quot;Processing cluster: &quot;, cluster)

  # Read cluster sheet
  de_data &lt;- read.xlsx(de_file, sheet = cluster)

  # Check if de_data is empty
  if (nrow(de_data) == 0 || !&quot;gene&quot; %in% colnames(de_data)) {
    message(paste(&quot;Skipping cluster&quot;, cluster, &quot;- no DE genes found&quot;))
  } else {
    volcano_genes &lt;- de_data

    #remove MT, RPL, RPS genes and Lnc
    volcano_genes &lt;- volcano_genes %&gt;% filter(!grepl(&quot;^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.&quot;, gene))
    #Define sig. up/down-reg genes
    volcano_genes$DE &lt;- &quot;NO&quot;
    volcano_genes$DE[volcano_genes$avg_log2FC &gt; 0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Up&quot;
    volcano_genes$DE[volcano_genes$avg_log2FC &lt; -0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Down&quot;
    #sign. up &amp; down
    volcano_genes$sig &lt;- ifelse(volcano_genes$DE == &quot;NO&quot;, &quot;&quot;, volcano_genes$gene)
    sig &lt;- volcano_genes$sig
    volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
    volcano_genes$DE &lt;- factor(volcano_genes$DE, levels = c(&quot;Down&quot;, &quot;NO&quot;, &quot;Up&quot;))
    volcano_genes$logP &lt;- -log10(volcano_genes$p_val_adj)
    volcano_genes$logP &lt;- pmin(volcano_genes$logP, 50)

    # Count up- and down-regulated genes
    n_up &lt;- sum(volcano_genes$DE == &quot;Up&quot;, na.rm = TRUE)
    n_down &lt;- sum(volcano_genes$DE == &quot;Down&quot;, na.rm = TRUE)

    # Filter only significant DE genes
    sig_genes &lt;- volcano_genes %&gt;%
      filter(DE != &quot;NO&quot;)
    # Rank first by adjusted p-value, then by absolute log2FC
    top_genes &lt;- sig_genes %&gt;%
      arrange(p_val_adj, desc(abs(avg_log2FC))) %&gt;%  # first p-value, then log2FC
      slice_head(n = 200) %&gt;%                         # top 200 genes
      pull(gene)

    # Update sig column to label only top 200 genes
    volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

    p &lt;- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
      geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
      geom_hline(yintercept = -log10(0.001), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
      geom_point(size = 3, alpha = 0.8) +
      scale_color_manual(values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
                         labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)) +
      geom_text_repel(max.overlaps = 50, size = 3) +
      theme_classic(base_size = 14) +
      labs(
        x = &quot;log Fold Change&quot;,
        y = expression(-log[10](&quot;adjusted p-value&quot;)),
        color = &quot;Regulation&quot;
      ) +
      annotate(&quot;text&quot;, x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0(&quot;Up: &quot;, n_up), hjust = 1, vjust = -0.5, color = &quot;#3d70b5&quot;, size = 5) +
      annotate(&quot;text&quot;, x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
               label = paste0(&quot;Down: &quot;, n_down), hjust = 0, vjust = -0.5, color = &quot;black&quot;, size = 5)

    # Save per cluster
    out_file &lt;- paste0(&quot;15.4_VolcanoPlot_DE_&quot;, cluster, &quot;_DE.pdf&quot;)
    print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
  }
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)</code></pre>
</div>
<div id="go-enrichment-analysis-fibroblast-de" class="section level3">
<h3>15.5 GO Enrichment Analysis (Fibroblast DE)</h3>
<p>Perform GO enrichment analysis on differentially expressed genes in
fibroblasts.</p>
<pre class="r"><code>set.seed(42)
read_all_sheets &lt;- function(path) {
  sheet_names &lt;- excel_sheets(path)
  sheets &lt;- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) &lt;- sheet_names
  return(sheets)
}

DE_MS_vs_Ctrl &lt;- read_all_sheets(file.path(result_dir, &quot;15.6_DE_SCT_Fibro_MS_vs_Ctrl.xlsx&quot;))

all_de_lists &lt;- list(
  MS_vs_Ctrl = DE_MS_vs_Ctrl
)

# Clusters of interest
target_clusters &lt;- as.character(Fibro_main_seurat@meta.data$seurat_clusters)
target_clusters &lt;- unique(target_clusters)
# Function for enrichment and plotting
run_enrichment_and_plotting &lt;- function(de_df, gene_list, direction, cluster, comparison) {
  if (length(gene_list) &lt; 5) {
    message(&quot;Not enough genes for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison)
    return(NULL)
  }
  ego &lt;- enrichGO(
    gene          = gene_list,
    OrgDb         = org.Hs.eg.db,
    keyType       = &quot;SYMBOL&quot;,
    ont           = &quot;ALL&quot;,
    pAdjustMethod = &quot;BH&quot;,
    qvalueCutoff  = 0.05,
    readable      = TRUE
  )
  if (is.null(ego) || nrow(ego) == 0) {
    message(&quot;No enrichment results for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison)
    return(NULL)
  }
  # Save GO table
  file_base &lt;- paste0(&quot;15.5_GO_DE_SCT_Fibro_&quot;, direction, &quot;&quot;, cluster, &quot;&quot;, comparison)
  write.xlsx(as.data.frame(ego), file = paste0(file_base, &quot;.xlsx&quot;))
  # Plots
#   pdf(paste0(file_base, &quot;.pdf&quot;), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;dotplot&quot;)
    print(barplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;barplot&quot;)
    sim &lt;- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste(&quot;Enrichment Map -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;emapplot&quot;)
    print(emapplot(sim, group = T) + ggtitle(paste(&quot;Cluster Map -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;emapplot_cluster&quot;)
    de_df &lt;- as.data.frame(de_df)
    rownames(de_df) &lt;- de_df$gene
    fc_vector &lt;- de_df[gene_list, &quot;avg_log2FC&quot;]
    names(fc_vector) &lt;- gene_list
    print(cnetplot(ego, categorySize = &quot;pvalue&quot;, foldChange = fc_vector) +
            ggtitle(paste(&quot;Cnetplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;cnetplot&quot;)
  }, error = function(e) {
    message(&quot;Plotting failed for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison, &quot;: &quot;, e$message)
  })
#   dev.off()
}

#Main loop
for (comparison in names(all_de_lists)) {
  print(comparison)
  de_list &lt;- all_de_lists[[comparison]]
  for (cluster in target_clusters) {
    print(cluster)
    cluster_name &lt;- paste0(&quot;Cluster_&quot;, cluster)
    if (!cluster_name %in% names(de_list)) {
      message(&quot;Skipping &quot;, cluster, &quot; in &quot;, comparison, &quot;  not found.&quot;)
      next
    }
    de_df &lt;- de_list[[cluster_name]]
    # Skip placeholder messages
    if (!&quot;avg_log2FC&quot; %in% colnames(de_df)) {
      message(&quot;Skipping &quot;, cluster, &quot; in &quot;, comparison, &quot;  not a valid DE result.&quot;)
      next
    }
    # UP-regulated
    gene_list_up &lt;- de_df %&gt;% filter(avg_log2FC &gt; 0.5 &amp; p_val_adj &lt; 0.001) %&gt;% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_up, &quot;Up&quot;, cluster, comparison)
    # DOWN-regulated
    gene_list_down &lt;- de_df %&gt;% filter(avg_log2FC &lt; -0.5 &amp; p_val_adj &lt; 0.001) %&gt;% pull(gene)
    run_enrichment_and_plotting(de_df, gene_list_down, &quot;Down&quot;, cluster, comparison)
  }
}</code></pre>
</div>
<div id="transfer-label" class="section level3">
<h3>15.6 Transfer Label</h3>
<p>Transfer annotations to the main fibroblast Seurat object and
visualize.</p>
<pre class="r"><code>Fibro_main_seurat$annotated_1 &lt;- Fibro_subset$annotated

Idents(Fibro_main_seurat) &lt;- &quot;annotated_1&quot;
p &lt;- DimPlot(Fibro_main_seurat, label = T)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.6_DimPlot_Fibro_main_with_annotated1.pdf&quot;), p, width = 6, height = 6)

p &lt;- DimPlot(Fibro_main_seurat, label = T, split.by = &quot;annotated_1&quot;)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.6_DimPlot_Fibro_main_split.by_annotated1.pdf&quot;), p, width = 20, height = 6)

cluster_colors = c(&quot;0&quot; = &quot;#66c69b&quot;, #main duraFibro2
                   &quot;1&quot; = &quot;#ee756d&quot;, #main duraFibro3
                   &quot;2&quot; = &quot;#d49005&quot;, #main duraFibro1
                   &quot;3&quot; = &quot;#7caee5&quot;, #main duraFibro5
                   &quot;4&quot; = &quot;#87be4d&quot;, #main arach_bordFibro
                   &quot;5&quot; = &quot;#3cac57&quot;, #main duraFibro4
                   &quot;6&quot; = &quot;#828dc6&quot;, #main mixFibro
                   &quot;7&quot; = &quot;#ef7e48&quot;, #main duraFibro6
                   &quot;8&quot; = &quot;#9584bd&quot;, #main ABC
                   &quot;9&quot; = &quot;#ec67a2&quot; #main duraFibro7
)

Idents(Fibro_main_seurat) &lt;- &quot;seurat_clusters&quot;
p &lt;- DimPlot(Fibro_main_seurat, label = T, cols = cluster_colors)
print(last_plot()) # ggsave(file.path(result_dir, &quot;15.6_DimPlot_Fibro_reclustered_res0.15_newcolor.pdf&quot;), p, width = 6, height = 6)</code></pre>
</div>
<div id="fibroblast-trajectory-analysis" class="section level3">
<h3>15.7 Fibroblast Trajectory Analysis</h3>
<p>Analyze the developmental trajectory of fibroblast cells using
Monocle3.</p>
<div id="pseudotime-calculation-2" class="section level4">
<h4>15.7.0 Pseudotime Calculation</h4>
<p>Convert fibroblast Seurat object to Monocle3 and calculate
pseudotime.</p>
<pre class="r"><code>Idents(Fibro_seurat) &lt;- &quot;seurat_clusters&quot;
Fibro_seurat$annotated_prev &lt;- Fibro_seurat$annotated
Fibro_seurat$annotated &lt;- Fibro_seurat$seurat_clusters
data &lt;- as(as.matrix(GetAssayData(Fibro_seurat, assay = &quot;SCT&quot;, slot = &quot;counts&quot;)), &#39;sparseMatrix&#39;) #normally on RNA
pd &lt;- data.frame(Fibro_seurat@meta.data)
pData &lt;- pd %&gt;% dplyr::select(orig.ident, nCount_RNA, nFeature_RNA, annotated, annotated_prev, sample, condition)
fData &lt;- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

Fibro_monocle &lt;- new_cell_data_set(expression_data = data, cell_metadata = pData, gene_metadata = fData)

#create data for Monocle to work with Seurat generated data
fData(Fibro_monocle)$gene_short_name &lt;- rownames(fData(Fibro_monocle))
recreate.partitions &lt;- c(rep(1, length(Fibro_monocle@colData@rownames)))
names(recreate.partitions) &lt;- Fibro_monocle@colData@rownames
recreate.partitions &lt;- as.factor(recreate.partitions)
recreate.partitions
Fibro_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;partitions&quot;]] &lt;- recreate.partitions

#get active.ident and cell embeddings from Seurat object and write into Monocle object as the data is not converted automatically
list.cluster &lt;- Fibro_seurat@active.ident
Fibro_monocle@clusters@listData[[&quot;UMAP&quot;]][[&quot;clusters&quot;]] &lt;- list.cluster
Fibro_monocle@int_colData@listData[[&quot;reducedDims&quot;]]@listData[[&quot;UMAP&quot;]] &lt;- Fibro_seurat@reductions$umap@cell.embeddings

#check if Seurat clustering is correctly transfered into Monocle
#pull cluster colors from Seurat object
cluster_colors = c(&quot;0&quot; = &quot;#66c69b&quot;, #main duraFibro2
                   &quot;1&quot; = &quot;#ee756d&quot;, #main duraFibro3
                   &quot;2&quot; = &quot;#d49005&quot;, #main duraFibro1
                   &quot;3&quot; = &quot;#7caee5&quot;, #main duraFibro5
                   &quot;4&quot; = &quot;#87be4d&quot;, #main arach_bordFibro
                   &quot;5&quot; = &quot;#3cac57&quot;, #main duraFibro4
                   &quot;6&quot; = &quot;#828dc6&quot;, #main mixFibro
                   &quot;7&quot; = &quot;#ef7e48&quot;, #main duraFibro6
                   &quot;8&quot; = &quot;#9584bd&quot;, #main ABC
                   &quot;9&quot; = &quot;#ec67a2&quot; #main duraFibro7
)

cluster.before.traj &lt;- plot_cells(Fibro_monocle, label_groups_by_cluster = F,
                                  group_label_size = 4) + theme(legend.position = &quot;right&quot;) +  scale_color_manual(values = cluster_colors)

# pdf(&quot;15.7.0_Fibro_before_traj_plot.pdf&quot;, width = 6, height = 6)
cluster.before.traj
# dev.off()

#let it calculate trajectory
#Fibro_monocle &lt;- learn_graph(Fibro_monocle, use_partition = F, verbose = T, learn_graph_control=list(ncenter=275))
#if no loop trajectory makes sense do
set.seed(123)
Fibro_monocle &lt;- learn_graph(Fibro_monocle, use_partition = F, verbose = T, close_loop = F, learn_graph_control=list(ncenter=250)) #changed ncenter to reduce branches

#plot trajectory into UMAP
p &lt;- plot_cells(Fibro_monocle, label_groups_by_cluster = F,
                label_branch_points = T, label_roots = T, label_leaves = F,
                group_label_size = 4) + scale_color_manual(values = cluster_colors)
p$layers[[4]]$aes_params$size &lt;- 6   # branchpoints
p$layers[[6]]$aes_params$size &lt;- 10    # roots
p$layers[[3]]$aes_params$size &lt;- 1.2  #traj edges
p$layers[[7]]$aes_params$size &lt;- 6  # root numbers
# pdf(&quot;15.7.0_Fibro_traj_plot_thicker.pdf&quot;, width = 6, height = 6)
p
# dev.off()


#order the cells in pseudotime
#Fibro_monocle &lt;- order_cells(Fibro_monocle, reduction_method = &quot;UMAP&quot;, root_cells = colnames(Fibro_monocle[, clusters(Fibro_monocle) == 5]))
#if this Error appears &quot;Error in Y[, root_pr_nodes, drop = FALSE] : subscript out of bounds&quot;, leave root_cells = NULL to manually select starting point
Fibro_monocle &lt;- order_cells(Fibro_monocle, reduction_method = &quot;UMAP&quot;, root_cells = NULL)

# pdf(&quot;15.7.0_Fibro_traj_plot_UMAP_pseudotime.pdf&quot;, width = 5, height = 4)
plot_cells(Fibro_monocle, color_cells_by = &quot;pseudotime&quot;, label_groups_by_cluster = T,
           label_branch_points = T, label_roots = F, label_leaves = F)
# dev.off()

#create graph depicting where clusters are in the pseudotime
Fibro_monocle$monocle3_pseudotime &lt;- pseudotime(Fibro_monocle)
data.pseudo &lt;- as.data.frame(colData(Fibro_monocle))

# pdf(&quot;15.7.0_Fibro_traj_pseudotime.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, annotated, fill = annotated)) + geom_boxplot() +
  scale_fill_manual(values = cluster_colors) + ylab(&quot;&quot;)
# dev.off()
#or alternatively order by pseudotime
# pdf(&quot;15.7.0_Fibro_traj_pseudotime_order.pdf&quot;, width = 8, height = 5)
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(annotated, monocle3_pseudotime), fill = annotated)) +
  geom_boxplot() + scale_fill_manual(values = cluster_colors) + xlab(&quot;pseudotime&quot;) + ylab(&quot;&quot;)
# dev.off()

qsave(Fibro_monocle, &quot;15.7.0_Fibro_monocle.qs&quot;)</code></pre>
</div>
<div id="genes-along-pseudotime-1" class="section level4">
<h4>15.7.1 Genes Along Pseudotime</h4>
<p>Identify genes changing along the fibroblast trajectory.</p>
<pre class="r"><code>#find genes that change in pseudotime
deg &lt;- graph_test(Fibro_monocle, neighbor_graph = &quot;principal_graph&quot;, verbose = TRUE)
deg |&gt; arrange(q_value, desc(morans_I)) |&gt; filter(status == &quot;OK&quot;) |&gt; head()

#deg gene list can be looked at and saved
#Moran&#39;s value -1 shows for equal distribution, value +1 means local accumulation
write.xlsx(deg, &quot;15.7.1_Fibros_monocle_DEG.xlsx&quot;)

#one can also save pseudotime values into Seurat object and then plot for
Fibro_seurat$pseudotime &lt;- pseudotime(Fibro_monocle)
# pdf(&quot;15.7.1_Fibro_FP_pseudotime.pdf&quot;, width = 4, height = 3)
FeaturePlot(Fibro_seurat, features = &quot;pseudotime&quot;)
# dev.off()</code></pre>
</div>
<div id="plot-genes-of-interest-1" class="section level4">
<h4>15.7.2 Plot Genes of Interest</h4>
<p>Visualize expression of specific genes along the fibroblast
pseudotime.</p>
<pre class="r"><code>#one can do multiple expression plots with certain identified genes
# pdf(&quot;15.7.2_Fibro_pseudotime_RP_genes_of_ineterest.pdf&quot;, width = 8, height = 9)
RidgePlot(Fibro_seurat, features = c(&quot;SVEP1&quot;, &quot;FGF7&quot;, &quot;LEPR&quot;, &quot;FBLN1&quot;, &quot;CLU&quot;, &quot;TAGLN&quot;, &quot;CFH&quot;, &quot;ANGPT1&quot;, &quot;NCAM1&quot;, &quot;AKAP12&quot;, &quot;SLC4A4&quot;, &quot;KCNMA1&quot;, &quot;F13A1&quot;, &quot;CTSB&quot;, &quot;PI16&quot;, &quot;MFAP5&quot;, &quot;KLF9&quot;, &quot;DHRS3&quot;, &quot;PHLDB2&quot;), sort = F, cols = cluster_colors)
# dev.off()


my_genes &lt;- c(&quot;SVEP1&quot;, &quot;FGF7&quot;, &quot;LEPR&quot;, &quot;FBLN1&quot;, &quot;CLU&quot;, &quot;TAGLN&quot;, &quot;CFH&quot;, &quot;ANGPT1&quot;, &quot;NCAM1&quot;, &quot;AKAP12&quot;, &quot;SLC4A4&quot;, &quot;KCNMA1&quot;, &quot;F13A1&quot;, &quot;CTSB&quot;, &quot;PI16&quot;, &quot;MFAP5&quot;, &quot;KLF9&quot;, &quot;DHRS3&quot;, &quot;PHLDB2&quot;)
Fibro_monocle &lt;- Fibro_monocle[my_genes,]
plot_genes_in_pseudotime(Fibro_monocle_subset, color_cells_by = &quot;monocle3_pseudotime&quot; )
#or
# pdf(&quot;15.7.2_Fibro_genes_of_interest_traj_pseudocolor.pdf&quot;, width = 5, height = 20)
plot_genes_in_pseudotime(Fibro_monocle, color_cells_by = &quot;monocle3_pseudotime&quot; )
# dev.off()

# pdf(&quot;15.7.2_Fibro_genes_of_ineterest_traj_annotated.pdf&quot;, width = 5, height = 20)
plot_genes_in_pseudotime(Fibro_monocle, color_cells_by = &quot;annotated&quot; )
# dev.off()</code></pre>
</div>
<div id="top-changing-genes-in-pseudotime-2" class="section level4">
<h4>15.7.3 Top Changing Genes in Pseudotime</h4>
<p>Visualize the top 5 most significant genes per cluster along the
fibroblast pseudotime.</p>
<pre class="r"><code>#plot top5 genes that change over pseudotime in each cluster
deg_sig &lt;- deg %&gt;% filter(q_value &lt; 0.05, status == &quot;OK&quot;)

deg_sig$cluster &lt;- Fibro_monocle$annotated[ match(deg_sig$gene_short_name,
                                                  rownames(Fibro_monocle)) ]

top5_per_cluster &lt;- deg_sig %&gt;%
  group_by(cluster) %&gt;%
  slice_max(order_by = morans_I, n = 5)

genes_to_plot &lt;- unique(top5_per_cluster$gene_short_name)
genes_to_plot

# pdf(&quot;15.7.3_Fibro_top_genes_pseudotime.pdf&quot;, width = 5, height = 25)

plot_genes_in_pseudotime(
  Fibro_monocle[genes_to_plot, ],
  color_cells_by = &quot;annotated&quot;,
  min_expr = 0.1
)

# dev.off()</code></pre>
</div>
<div id="condition-dependent-gene-expression-1" class="section level4">
<h4>15.7.4 Condition-Dependent Gene Expression</h4>
<p>Identify genes that vary across conditions along the pseudotime
trajectory.</p>
<pre class="r"><code>#find genes that vary across condition
gene_fits &lt;- fit_models(Fibro_monocle, model_formula_str = &quot;~condition&quot;)
gene_fits_tbl &lt;- coefficient_table(gene_fits)
write.xlsx(gene_fits_tbl, &quot;15.7.4_Fibros_pseudotime_condition.xlsx&quot;)

# Keep only the condition coefficients
deg_cond &lt;- gene_fits_tbl %&gt;%
  filter(term != &quot;(Intercept)&quot;)

# Significant genes
sig_genes &lt;- deg_cond %&gt;%
  filter(q_value &lt; 0.05)

# Rank for labeling: first q-value, then |estimate|
top_genes &lt;- sig_genes %&gt;%
  arrange(q_value, desc(abs(estimate))) %&gt;%
  slice_head(n = 50) %&gt;%
  pull(gene_short_name)

deg_volcano &lt;- deg_cond %&gt;%
  mutate(
    logFC = estimate,
    negLogQ = -log10(q_value),
    DE = case_when(
      estimate &gt; 0.5  &amp; q_value &lt; 0.05 ~ &quot;Up&quot;,
      estimate &lt; -0.5 &amp; q_value &lt; 0.05 ~ &quot;Down&quot;,
      TRUE                              ~ &quot;NO&quot;
    ),
    logP = pmin(negLogQ, 50),      # cap values for nicer plot
    label_it = ifelse(gene_short_name %in% top_genes, gene_short_name, NA)
  )


deg_volcano$label_italic &lt;- ifelse(
  is.na(deg_volcano$label_it),
  NA,
  paste0(&quot;italic(&#39;&quot;, deg_volcano$label_it, &quot;&#39;)&quot;)
)

p &lt;- ggplot(deg_volcano, aes(x = logFC, y = logP, color = DE)) +
  geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
  geom_hline(yintercept = -log10(0.05), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
  geom_point(size = 3, alpha = 0.8) +

  scale_color_manual(
    values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
    labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)
  ) +

  ggrepel::geom_text_repel(
    aes(label = label_italic),
    parse = TRUE,
    max.overlaps = 50,
    size = 3
  ) +

  theme_classic(base_size = 14) +
  labs(
    title = &quot;Condition-dependent DEGs along trajectory&quot;,
    x = &quot;log Fold Change&quot;,
    y = expression(-log[10](&quot;adjusted p-value&quot;)),
    color = &quot;Regulation&quot;
  )

print(last_plot()) # ggsave(file.path(result_dir, &quot;15.7.4_Fibro_pseudotime_VolcanoPlot_DE_MS_vs_ctrl.pdf&quot;), p , width = 10, height = 7)

#plot genes over pseudotime
top_genes &lt;- top_sig$gene_short_name

p &lt;- plot_genes_in_pseudotime(
  Fibro_monocle[top_genes, ],
  color_cells_by = &quot;condition&quot;
)

print(last_plot()) # ggsave(file.path(result_dir, &quot;15.7.4_Fibro_pseudotime_along_traj_Plot_DE_MS_vs_ctrl.pdf&quot;), p , width = 5, height = 25)</code></pre>
</div>
</div>
<div id="overall-fibroblast-differential-expression"
class="section level3">
<h3>15.8 Overall Fibroblast Differential Expression</h3>
<p>Perform differential expression analysis on the overall fibroblast
population (duraFibro clusters) between MS and Ctrl conditions.</p>
<pre class="r"><code>Idents(Fibro_main_seurat) &lt;- &quot;seurat_clusters&quot;
duraFibro_seurat &lt;- subset(Fibro_main_seurat, idents = c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;9&quot;))

Idents(duraFibro_seurat) &lt;- &quot;condition&quot;

DefaultAssay(duraFibro_seurat) &lt;- &quot;SCT&quot;
DE_duraFibro_overall &lt;- FindMarkers(
  duraFibro_seurat,
  ident.1 = &quot;MS&quot;,
  ident.2 = &quot;Ctrl&quot;,
  group.by = &quot;condition&quot;,
  recorrect_umi = FALSE
)

DE_duraFibro_overall &lt;- DE_duraFibro_overall %&gt;%
  rownames_to_column(var = &quot;gene&quot;) %&gt;%
  arrange(p_val_adj, desc(avg_log2FC))

write_xlsx(DE_duraFibro_overall, &quot;15.8_DE_duraFibro_overall.xlsx&quot;)</code></pre>
</div>
<div id="go-enrichment-for-overall-fibroblast-de"
class="section level3">
<h3>15.8.1 GO Enrichment for Overall Fibroblast DE</h3>
<p>Perform Gene Ontology enrichment analysis on the differentially
expressed genes found in the overall fibroblast analysis.</p>
<pre class="r"><code>set.seed(42)

read_all_sheets &lt;- function(path) {
  sheet_names &lt;- excel_sheets(path)
  sheets &lt;- lapply(sheet_names, function(s) read_excel(path, sheet = s))
  names(sheets) &lt;- sheet_names
  return(sheets)
}
DE_MS_vs_Ctrl &lt;- read_all_sheets(file.path(result_dir, &quot;15.8_DE_duraFibro_overall.xlsx&quot;))

# Function for enrichment and plotting
run_enrichment_and_plotting &lt;- function(de_df, gene_list, direction, cluster, comparison) {
  if (length(gene_list) &lt; 5) {
    message(&quot;Not enough genes for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison)
    return(NULL)
  }
  ego &lt;- enrichGO(
    gene          = gene_list,
    OrgDb         = org.Hs.eg.db,
    keyType       = &quot;SYMBOL&quot;,
    ont           = &quot;ALL&quot;,
    pAdjustMethod = &quot;BH&quot;,
    qvalueCutoff  = 0.05,
    readable      = TRUE
  )
  if (is.null(ego) || nrow(ego) == 0) {
    message(&quot;No enrichment results for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison)
    return(NULL)
  }
  # Save GO table
  file_base &lt;- paste0(&quot;15.8.1_GO_DE_duraFibro_&quot;, direction, &quot;&quot;, cluster, &quot;&quot;, comparison)
  write.xlsx(as.data.frame(ego), file = paste0(file_base, &quot;.xlsx&quot;))
  # Plots
#   pdf(paste0(file_base, &quot;.pdf&quot;), width = 8, height = 6)
  tryCatch({
    print(dotplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;dotplot&quot;)
    print(barplot(ego) + ggtitle(paste(&quot;Dotplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;barplot&quot;)
    sim &lt;- pairwise_termsim(ego)
    print(emapplot(sim) + ggtitle(paste(&quot;Enrichment Map -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;emapplot&quot;)
    print(emapplot(sim, group = T) + ggtitle(paste(&quot;Cluster Map -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;emapplot_cluster&quot;)
    de_df &lt;- as.data.frame(de_df)
    rownames(de_df) &lt;- de_df$gene
    fc_vector &lt;- de_df[gene_list, &quot;avg_log2FC&quot;]
    names(fc_vector) &lt;- gene_list
    print(cnetplot(ego, categorySize = &quot;pvalue&quot;, foldChange = fc_vector) +
            ggtitle(paste(&quot;Cnetplot -&quot;, direction, &quot;-&quot;, cluster, &quot;-&quot;, comparison)))
    print(&quot;cnetplot&quot;)
  }, error = function(e) {
    message(&quot;Plotting failed for &quot;, direction, &quot;regulated &quot;, cluster, &quot; in &quot;, comparison, &quot;: &quot;, e$message)
  })
#   dev.off()
}

#Main loop
de_df &lt;- DE_MS_vs_Ctrl[[&quot;Sheet1&quot;]]

# Upregulated genes
gene_list_up &lt;- de_df %&gt;%
  filter(avg_log2FC &gt; 0.5 &amp; p_val_adj &lt; 0.001) %&gt;%
  pull(gene)

run_enrichment_and_plotting(de_df, gene_list_up, &quot;Up&quot;, &quot;All_duraFibros&quot;, &quot;MS_vs_Ctrl&quot;)

# Downregulated genes
gene_list_down &lt;- de_df %&gt;%
  filter(avg_log2FC &lt; -0.5 &amp; p_val_adj &lt; 0.001) %&gt;%
  pull(gene)

run_enrichment_and_plotting(de_df, gene_list_down, &quot;Down&quot;, &quot;All_duraFibros&quot;, &quot;MS_vs_Ctrl&quot;)</code></pre>
</div>
<div id="volcano-plot-top-genes" class="section level3">
<h3>15.8.2 Volcano Plot (Top Genes)</h3>
<p>Visualize the overall fibroblast DE results using a volcano plot,
labeling the top significant genes.</p>
<pre class="r"><code>de_file &lt;- &quot;15.8_DE_duraFibro_overall.xlsx&quot;

all_clusters &lt;- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message(&quot;Processing cluster: &quot;, cluster)

  # Read cluster sheet
  de_data &lt;- read.xlsx(de_file, sheet = cluster)
  volcano_genes &lt;- de_data

  #remove MT, RPL, RPS genes and Lnc
  volcano_genes &lt;- volcano_genes %&gt;% filter(!grepl(&quot;^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.&quot;, gene))
  #Define sig. up/down-reg genes
  volcano_genes$DE &lt;- &quot;NO&quot;
  volcano_genes$DE[volcano_genes$avg_log2FC &gt; 0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Up&quot;
  volcano_genes$DE[volcano_genes$avg_log2FC &lt; -0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Down&quot;
  #sign. up &amp; down
  volcano_genes$sig &lt;- ifelse(volcano_genes$DE == &quot;NO&quot;, &quot;&quot;, volcano_genes$gene)
  sig &lt;- volcano_genes$sig
  volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
  volcano_genes$DE &lt;- factor(volcano_genes$DE, levels = c(&quot;Down&quot;, &quot;NO&quot;, &quot;Up&quot;))
  volcano_genes$logP &lt;- -log10(volcano_genes$p_val_adj)
  volcano_genes$logP &lt;- pmin(volcano_genes$logP, 50)

  # Count up- and down-regulated genes
  n_up &lt;- sum(volcano_genes$DE == &quot;Up&quot;, na.rm = TRUE)
  n_down &lt;- sum(volcano_genes$DE == &quot;Down&quot;, na.rm = TRUE)

  # Filter only significant DE genes
  sig_genes &lt;- volcano_genes %&gt;%
    filter(DE != &quot;NO&quot;)
  # Rank first by adjusted p-value, then by absolute log2FC
  top_genes &lt;- sig_genes %&gt;%
    arrange(p_val_adj, desc(abs(avg_log2FC))) %&gt;%  # first p-value, then log2FC
    slice_head(n = 400) %&gt;%                         # top 500 genes
    pull(gene)

  # Update sig column to label only top 400 genes
  volcano_genes$interest &lt;- ifelse(volcano_genes$gene %in% top_genes, volcano_genes$gene, NA)

  p &lt;- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP, color = DE, label = sig)) +
    geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
    geom_hline(yintercept = -log10(0.001), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
    geom_point(size = 3, alpha = 0.8) +
    scale_color_manual(values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;),
                       labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)) +
    geom_text_repel(max.overlaps = 50, size = 3) +
    theme_classic(base_size = 14) +
    labs(
      x = &quot;log Fold Change&quot;,
      y = expression(-log[10](&quot;adjusted p-value&quot;)),
      color = &quot;Regulation&quot;
    ) +
    annotate(&quot;text&quot;, x = max(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
             label = paste0(&quot;Up: &quot;, n_up), hjust = 1, vjust = -0.5, color = &quot;#3d70b5&quot;, size = 5) +
    annotate(&quot;text&quot;, x = min(volcano_genes$avg_log2FC), y = max(volcano_genes$logP),
             label = paste0(&quot;Down: &quot;, n_down), hjust = 0, vjust = -0.5, color = &quot;black&quot;, size = 5)

  # Save per cluster
  out_file &lt;- paste0(&quot;15.8.2_VolcanoPlot_duraFibro_&quot;, cluster, &quot;_DE.pdf&quot;)
  print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)</code></pre>
</div>
<div id="volcano-plot-genes-of-interest" class="section level3">
<h3>15.8.3 Volcano Plot (Genes of Interest)</h3>
<p>Visualize the overall fibroblast DE results, highlighting specific
genes of interest (ECM and proliferation markers).</p>
<pre class="r"><code>de_file &lt;- &quot;15.8_DE_duraFibro_overall.xlsx&quot;

all_clusters &lt;- getSheetNames(de_file)

#Loop over clusters
library(ggrepel)
for (cluster in all_clusters) {

  message(&quot;Processing cluster: &quot;, cluster)

  # Read cluster sheet
  de_data &lt;- read.xlsx(de_file, sheet = cluster)
  volcano_genes &lt;- de_data

  #remove MT, RPL, RPS genes and Lnc
  volcano_genes &lt;- volcano_genes %&gt;% filter(!grepl(&quot;^MT|^RPL|^RPS|^ZNF|orf|^LINC|^ENSG|\\.&quot;, gene))
  #Define sig. up/down-reg genes
  volcano_genes$DE &lt;- &quot;NO&quot;
  volcano_genes$DE[volcano_genes$avg_log2FC &gt; 0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Up&quot;
  volcano_genes$DE[volcano_genes$avg_log2FC &lt; -0.5 &amp; volcano_genes$p_val_adj &lt; 0.001] &lt;- &quot;Down&quot;
  #sign. up &amp; down
  volcano_genes$sig &lt;- ifelse(volcano_genes$DE == &quot;NO&quot;, &quot;&quot;, volcano_genes$gene)
  sig &lt;- volcano_genes$sig
  volcano_genes$sig &lt;- ifelse(volcano_genes$gene %in% sig, volcano_genes$gene, NA)
  volcano_genes$DE &lt;- factor(volcano_genes$DE, levels = c(&quot;Down&quot;, &quot;NO&quot;, &quot;Up&quot;))
  volcano_genes$logP &lt;- -log10(volcano_genes$p_val_adj)
  volcano_genes$logP &lt;- pmin(volcano_genes$logP, 50)

  # Count up- and down-regulated genes
  n_up &lt;- sum(volcano_genes$DE == &quot;Up&quot;, na.rm = TRUE)
  n_down &lt;- sum(volcano_genes$DE == &quot;Down&quot;, na.rm = TRUE)

  # Filter only significant DE genes
  sig_genes &lt;- volcano_genes %&gt;%
    filter(DE != &quot;NO&quot;)
  # Rank first by adjusted p-value, then by absolute log2FC
  top_genes &lt;- sig_genes %&gt;%
    arrange(p_val_adj, desc(abs(avg_log2FC))) %&gt;%  # first p-value, then log2FC
    slice_head(n = 400) %&gt;%                         # top 500 genes
    pull(gene)

  # label genes of interest
  genes_of_interest &lt;- read_csv(&quot;genes_ECM_prolif.txt&quot;, col_names = FALSE) %&gt;%
    pull(X1) %&gt;%
    trimws() %&gt;%           # remove spaces
    toupper()              # make uppercase, assuming your DE gene names are uppercase


  # assign color based on fold change
  volcano_genes$interest &lt;- ifelse(volcano_genes$gene %in% genes_of_interest, volcano_genes$gene, NA)
  volcano_genes$interest_color &lt;- NA
  volcano_genes$interest_color[volcano_genes$gene %in% genes_of_interest &amp;
                                 volcano_genes$avg_log2FC &gt; 0] &lt;- &quot;#3d70b5&quot;   # upregulated  blue
  volcano_genes$interest_color[volcano_genes$gene %in% genes_of_interest &amp;
                                 volcano_genes$avg_log2FC &lt; 0] &lt;- &quot;black&quot;      # downregulated  black

  p &lt;- ggplot(volcano_genes, aes(x = avg_log2FC, y = logP)) +
    geom_vline(xintercept = c(-0.5, 0.5), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +
    geom_hline(yintercept = -log10(0.001), color = &quot;gray40&quot;, linetype = &quot;dashed&quot;) +

    # all genes by DE
    geom_point(aes(color = DE), size = 3, alpha = 0.8) +

    # genes of interest colored by fold change
    geom_point(data = subset(volcano_genes, !is.na(interest)),
               aes(x = avg_log2FC, y = logP, color = interest_color),
               size = 3) +

    # labels for genes of interest
    geom_text_repel(
      aes(label = interest, color = interest_color),
      max.overlaps = 50,
      size = 3,
      show.legend = FALSE      # optional: hide from legend
    ) +

    # set colors for DE categories (non-interest genes)
    scale_color_manual(values = c(&quot;Down&quot; = &quot;black&quot;, &quot;NO&quot; = &quot;grey70&quot;, &quot;Up&quot; = &quot;#3d70b5&quot;,
                                  &quot;#3d70b5&quot; = &quot;#3d70b5&quot;, &quot;black&quot; = &quot;black&quot;),
                       labels = c(&quot;Down&quot;, &quot;ns&quot;, &quot;Up&quot;)) +

    theme_classic(base_size = 14) +
    labs(
      x = &quot;log Fold Change&quot;,
      y = expression(-log[10](&quot;adjusted p-value&quot;)),
      color = &quot;Regulation&quot;
    )

  # Save per cluster
  out_file &lt;- paste0(&quot;15.8.3_VolcanoPlot_duraFibro_genes_of_interest_&quot;, cluster, &quot;_DE.pdf&quot;)
  print(last_plot()) # ggsave(out_file, plot = p, width = 10, height = 7)
}

rm(de_data, p, sig_genes, volcano_genes, all_clusters, cluster, de_file, n_down, n_up, out_file, sig, top_genes)</code></pre>
</div>
<div id="nichenet-analysis-ms-vs-ctrl" class="section level3">
<h3>15.9 NicheNet Analysis (MS vs Ctrl)</h3>
<p>Perform NicheNet analysis to infer ligand-receptor interactions
driving the structural fibroblast response in MS.</p>
<pre class="r"><code>#convert Seurat to single cell experiment and define meta data
samples_seurat$Fibro &lt;- dplyr::case_when(
  samples_seurat$annotated_manuscript %in% c(&quot;duraFibro1&quot;, &quot;duraFibro2&quot;, &quot;duraFibro3&quot;, &quot;duraFibro4&quot;, &quot;duraFibro5&quot;, &quot;duraFibro6&quot;, &quot;duraFibro7&quot;, &quot;duraFibro8&quot;) ~ &quot;duraFibro&quot;,
  TRUE ~ as.character(samples_seurat$annotated)
)

sce &lt;- Seurat::as.SingleCellExperiment(samples_seurat, assay = &quot;SCT&quot;)
sce &lt;- alias_to_symbol_SCE(sce, &quot;human&quot;) |&gt; makenames_SCE()

sample_id &lt;- &quot;sample_id&quot;
group_id &lt;- &quot;condition&quot;
celltype_id &lt;- &quot;Fibro&quot;
covariates &lt;- NA
batches &lt;- NA

#define organism
organism = &quot;human&quot;

if(organism == &quot;human&quot;){
  lr_network = readRDS(url(&quot;https://zenodo.org/record/7074291/files/lr_network_human_21122021.rds&quot;))
  lr_network = lr_network |&gt; dplyr::rename(ligand = from, receptor = to) |&gt; distinct(ligand, receptor) |&gt; mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url(&quot;https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds&quot;))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |&gt; make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |&gt; make.names()
} else if(organism == &quot;mouse&quot;){
  lr_network = readRDS(url(&quot;https://zenodo.org/record/7074291/files/lr_network_mouse_21122021.rds&quot;))
  lr_network = lr_network |&gt; dplyr::rename(ligand = from, receptor = to) |&gt; distinct(ligand, receptor) |&gt; mutate(ligand = make.names(ligand), receptor = make.names(receptor))
  ligand_target_matrix = readRDS(url(&quot;https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds&quot;))
  colnames(ligand_target_matrix) = colnames(ligand_target_matrix) |&gt; make.names()
  rownames(ligand_target_matrix) = rownames(ligand_target_matrix) |&gt; make.names()
}

#change names because _ and dots are not allowed
colData(sce)[, celltype_id] &lt;- factor(gsub(&quot;-&quot;, &quot;_&quot;, colData(sce)[, celltype_id]))
levels(colData(sce)[, celltype_id])

#Sender and receiver cell types need to be defined. Here all cell types in the dataset are used
senders_oi &lt;- SummarizedExperiment::colData(sce)[,celltype_id] |&gt; unique()
receivers_oi &lt;- SummarizedExperiment::colData(sce)[,celltype_id] |&gt; unique()

sce &lt;- sce[, SummarizedExperiment::colData(sce)[,celltype_id] %in% c(senders_oi, receivers_oi)]

min_cells &lt;- 10

abundance_info = get_abundance_info(
  sce = sce,
  sample_id = sample_id,
  group_id = group_id,
  celltype_id = celltype_id,
  min_cells = min_cells,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  batches = batches)

## check for condition-specific cell types
abundance_df_summarized = abundance_info$abundance_data %&gt;% mutate(keep = as.logical(keep)) %&gt;% group_by(group_id, celltype_id) %&gt;% summarise(samples_present = sum((keep)))
celltypes_absent_one_condition = abundance_df_summarized %&gt;% filter(samples_present == 0) %&gt;% pull(celltype_id) %&gt;% unique() # find truly condition-specific cell types by searching for cell types truely absent in at least one condition
celltypes_present_one_condition = abundance_df_summarized %&gt;% filter(samples_present &gt;= 2) %&gt;% pull(celltype_id) %&gt;% unique() # require presence in at least 2 samples of one group so it is really present in at least one condition
condition_specific_celltypes = intersect(celltypes_absent_one_condition, celltypes_present_one_condition)

condition_specific_celltypes_senders = condition_specific_celltypes %&gt;% intersect(senders_oi)
condition_specific_celltypes_receivers = condition_specific_celltypes %&gt;% intersect(receivers_oi)

fraction_cutoff &lt;- 0.05
min_sample_prop &lt;- 0.5
frq_list = get_frac_exprs(sce = sce, sample_id = sample_id, celltype_id =  celltype_id, group_id = group_id, batches = batches, min_cells = min_cells, fraction_cutoff = fraction_cutoff, min_sample_prop = min_sample_prop)

abundance_expression_info &lt;- process_abundance_expression_info(
  sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, min_cells = min_cells,
  senders_oi = union(senders_oi, condition_specific_celltypes_senders),
  receivers_oi = union(receivers_oi, condition_specific_celltypes_receivers),
  lr_network = lr_network, batches = batches, frq_list = frq_list, abundance_info = abundance_info)

table(colData(sce)[,celltype_id], colData(sce)[,sample_id])

#If you compare against two groups, you should divide by 2, if you compare against three groups, you should divide by 3 etcetera
contrasts_oi &lt;- c(&quot;&#39;M-(S+A)/2&#39;,&#39;S-(M+A)/2&#39;,&#39;A-(S+M)/2&#39;&quot;)
#if compare against two groups
contrasts_oi &lt;- c(&quot;&#39;MS-Ctrl&#39;,&#39;Ctrl-MS&#39;&quot;)
contrast_tbl &lt;- tibble(contrast = c(&quot;MS-Ctrl&quot;,&quot;Ctrl-MS&quot;), group = c(&quot;MS&quot;,&quot;Ctrl&quot;))

assay_oi_pb &lt;- &quot;counts&quot;
fun_oi_pb &lt;- &quot;sum&quot;
de_method_oi &lt;- &quot;edgeR&quot;
findMarkers &lt;- FALSE

DE_info = get_DE_info(sce = sce, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, batches = batches, covariates = covariates, contrasts_oi = contrasts_oi, min_cells = min_cells,
                      assay_oi_pb = assay_oi_pb,
                      fun_oi_pb = fun_oi_pb,
                      de_method_oi = de_method_oi,
                      findMarkers = findMarkers,
                      expressed_df = frq_list$expressed_df)

#check p-value distribution#should be quite straight horizontal line
DE_info$hist_pvals

#if it looks ok, run &quot;empirical_pval == FALSE
empirical_pval = FALSE
#if it looks suboptimal run empirical_pval == TRUE and check quality
empirical_pval = TRUE

if(empirical_pval == TRUE){
  DE_info_emp = get_empirical_pvals(DE_info$celltype_de$de_output_tidy)
}
DE_info_emp$hist_pvals_emp

if(empirical_pval == FALSE){
  celltype_de = DE_info$celltype_de$de_output_tidy
} else {
  celltype_de = DE_info_emp$de_output_tidy_emp %&gt;% dplyr::select(-p_val, -p_adj) %&gt;% dplyr::rename(p_val = p_emp, p_adj = p_adj_emp)
}

sender_receiver_de = combine_sender_receiver_de(
  sender_de = celltype_de,
  receiver_de = celltype_de,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  lr_network = lr_network
)

logFC_threshold = 0.50
p_val_threshold = 0.05
fraction_cutoff = 0.05


# p_val_adj = TRUE #In case of more samples per group + sufficient high number of DE genes per group-celltype (&gt; 20-50), use p_val_adj = TRUE
p_val_adj = T

top_n_target = 400

verbose = TRUE
cores_system = 8
n.cores = min(cores_system, sender_receiver_de$receiver %&gt;% unique() %&gt;% length()) # use one core per receiver cell type

ligand_activities_targets_DEgenes = suppressMessages(suppressWarnings(get_ligand_activities_targets_DEgenes(
  receiver_de = celltype_de,
  receivers_oi = receivers_oi,
  ligand_target_matrix = ligand_target_matrix,
  logFC_threshold = logFC_threshold,
  p_val_threshold = p_val_threshold,
  p_val_adj = T,
  top_n_target = top_n_target,
  verbose = T,
  n.cores = n.cores
)))

prioritizing_weights_DE = c(&quot;de_ligand&quot; = 1,
                            &quot;de_receptor&quot; = 1)
prioritizing_weights_activity = c(&quot;activity_scaled&quot; = 2)

prioritizing_weights_expression_specificity = c(&quot;exprs_ligand&quot; = 2,
                                                &quot;exprs_receptor&quot; = 2)

prioritizing_weights_expression_sufficiency = c(&quot;frac_exprs_ligand_receptor&quot; = 1)

prioritizing_weights_relative_abundance = c( &quot;abund_sender&quot; = 0,
                                             &quot;abund_receiver&quot; = 0)

prioritizing_weights = c(prioritizing_weights_DE,
                         prioritizing_weights_activity,
                         prioritizing_weights_expression_specificity,
                         prioritizing_weights_expression_sufficiency,
                         prioritizing_weights_relative_abundance)

sender_receiver_tbl = sender_receiver_de |&gt; dplyr::distinct(sender, receiver)

metadata_combined = SummarizedExperiment::colData(sce) |&gt; tibble::as_tibble()

if(!is.na(batches)){
  grouping_tbl = metadata_combined[,c(sample_id, group_id, batches)] |&gt; tibble::as_tibble() |&gt; dplyr::distinct()
  colnames(grouping_tbl) = c(&quot;sample&quot;,&quot;group&quot;,batches)
} else {
  grouping_tbl = metadata_combined[,c(sample_id, group_id)] |&gt; tibble::as_tibble() |&gt; dplyr::distinct()
  colnames(grouping_tbl) = c(&quot;sample&quot;,&quot;group&quot;)
}

scenario &lt;- &quot;regular&quot; # all prioritization criteria will be weighted equally
ligand_activity_down &lt;- FALSE # use only upregulatory ligand activities to prioritize

prioritization_tables = suppressMessages(generate_prioritization_tables(
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de = sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  contrast_tbl = contrast_tbl,
  sender_receiver_tbl = sender_receiver_tbl,
  grouping_tbl = grouping_tbl,
  scenario = scenario,
  fraction_cutoff = fraction_cutoff,
  abundance_data_receiver = abundance_expression_info$abundance_data_receiver,
  abundance_data_sender = abundance_expression_info$abundance_data_sender,
  ligand_activity_down = ligand_activity_down
))

lr_target_prior_cor = lr_target_prior_cor_inference(prioritization_tables$group_prioritization_tbl$receiver |&gt; unique(), abundance_expression_info, celltype_de, grouping_tbl, prioritization_tables, ligand_target_matrix, logFC_threshold = logFC_threshold, p_val_threshold = p_val_threshold, p_val_adj = p_val_adj)

#extract MS-specific strucFibro interactions
interactions_MS &lt;- prioritization_tables$group_prioritization_tbl %&gt;%
  filter(group == &quot;MS&quot;)

duraFibro_MS_interactions &lt;- interactions_MS %&gt;%
  filter(sender == &quot;duraFibro&quot; | receiver == &quot;duraFibro&quot;) %&gt;%
  arrange(desc(prioritization_score))

# Inspect partners
unique_senders_MS &lt;- setdiff(unique(duraFibro_MS_interactions$sender), &quot;duraFibro&quot;)
unique_receivers_MS &lt;- setdiff(unique(duraFibro_MS_interactions$receiver), &quot;duraFibro&quot;)

cat(&quot;Senders to strucFibro in MS:\n&quot;)
print(unique_senders_MS)

cat(&quot;Receivers from strucFibro in MS:\n&quot;)
print(unique_receivers_MS)

# Save table
write.csv(duraFibro_MS_interactions, &quot;15.9_MS_duraFibro_interactions.csv&quot;, row.names = FALSE)

#save previous calculations as one large list
multinichenet_output = list(
  celltype_info = abundance_expression_info$celltype_info,
  celltype_de = celltype_de,
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de =  sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  prioritization_tables = prioritization_tables,
  grouping_tbl = grouping_tbl,
  lr_target_prior_cor = lr_target_prior_cor
)
multinichenet_output = make_lite_output(multinichenet_output)

saveRDS(multinichenet_output, file = &quot;15.9_multinichenet_MS_duraFibro.rds&quot;)</code></pre>
<div id="circos-plot-visualization-1" class="section level4">
<h4>15.9.1 Circos Plot Visualization</h4>
<p>Visualize the prioritized ligand-receptor interactions using Circos
plots.</p>
<pre class="r"><code>#top20
duraFibro_MS_top20 &lt;- duraFibro_MS_interactions %&gt;%
  arrange(desc(prioritization_score)) %&gt;%
  slice(1:20)
senders_receivers &lt;- union(duraFibro_MS_top20$sender %&gt;% unique(),
                           duraFibro_MS_top20$receiver %&gt;% unique()) %&gt;% sort()
colors_sender &lt;- cluster_colors[senders_receivers]
colors_receiver &lt;- cluster_colors[senders_receivers]

# pdf(&quot;15.9.1_top20_circos_plot_MS_duraFibro.pdf&quot;, width = 10, height = 10)
circos_list &lt;- make_circos_group_comparison(duraFibro_MS_top20, colors_sender, colors_receiver)
# dev.off()

#split bei receiver
library(circlize)
library(dplyr)

# Open multi-page PDF
# pdf(&quot;15.9.1_circos_split_by_receiver.pdf&quot;, width = 10, height = 10)

unique_receivers &lt;- sort(unique(prioritized_tbl_oi$receiver))

for(receiver in unique_receivers) {

  # Subset top interactions for this receiver
  subset_tbl &lt;- prioritized_tbl_oi %&gt;% filter(receiver == !!receiver)
  if(nrow(subset_tbl) == 0) next

  # Create circos object
  circos_list &lt;- make_circos_group_comparison(subset_tbl, colors_sender, colors_receiver)

  circos.clear()
  circos.par(gap.degree = 5)

  # Initialize sectors
  cell_types &lt;- circos_list$cell_types
  xlim_list &lt;- lapply(cell_types, function(x) c(0,1))
  names(xlim_list) &lt;- cell_types
  for(sector in cell_types){
    circos.initialize(factors = sector, xlim = xlim_list[[sector]])
  }

  # Draw arcs and labels
  cell_colors &lt;- circos_list$colors
  for(sector in cell_types){
    circos.trackPlotRegion(factors = sector, y = c(0,1),
                           bg.col = cell_colors[sector], bg.border = NA,
                           panel.fun = function(x, y){
                             circos.text(CELL_META$xcenter, CELL_META$ycenter,
                                         CELL_META$sector.index,
                                         facing = &quot;clockwise&quot;, niceFacing = TRUE, cex = 0.8)
                           })
  }

  # Draw links
  if(!is.null(circos_list$links) &amp;&amp; nrow(circos_list$links) &gt; 0){
    for(i in seq_len(nrow(circos_list$links))){
      link &lt;- circos_list$links[i, ]
      circos.link(sector.index1 = link$sender, point1 = 0.5,
                  sector.index2 = link$receiver, point2 = 0.5,
                  col = rgb(0,0,0,0.3), border = NA)
    }
  }

  # Each iteration creates a **new page** in the PDF
}

# Close PDF device
# dev.off()</code></pre>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
